// Copyright 2023 - Nym Technologies SA <contact@nymtech.net>
// SPDX-License-Identifier: Apache-2.0

#![allow(unknown_lints)]
// clippy::empty_docs is not on stable as of 1.77

// due to the code generated by Tsify
#![allow(clippy::empty_docs)]

use super::{
    AcknowledgementsWasm, CoverTrafficWasm, DebugWasm, ForgetMeWasm, GatewayConnectionWasm,
    RememberMeWasm, ReplySurbsWasm, StatsReportingWasm, TopologyWasm, TrafficWasm,
};
use crate::config::ConfigDebug;
use serde::{Deserialize, Serialize};
use tsify::Tsify;

// just a helper structure to more easily pass through the JS boundary
#[derive(Tsify, Debug, Clone, Serialize, Deserialize)]
#[tsify(into_wasm_abi, from_wasm_abi)]
#[serde(rename_all = "camelCase")]
pub struct DebugWasmOverride {
    /// Defines all configuration options related to traffic streams.
    #[tsify(optional)]
    pub traffic: Option<TrafficWasmOverride>,

    /// Defines all configuration options related to cover traffic stream(s).
    #[tsify(optional)]
    pub cover_traffic: Option<CoverTrafficWasmOverride>,

    /// Defines all configuration options related to the gateway connection.
    #[tsify(optional)]
    pub gateway_connection: Option<GatewayConnectionWasmOverride>,

    /// Defines all configuration options related to acknowledgements, such as delays or wait timeouts.
    #[tsify(optional)]
    pub acknowledgements: Option<AcknowledgementsWasmOverride>,

    /// Defines all configuration options related topology, such as refresh rates or timeouts.
    #[tsify(optional)]
    pub topology: Option<TopologyWasmOverride>,

    /// Defines all configuration options related to reply SURBs.
    #[tsify(optional)]
    pub reply_surbs: Option<ReplySurbsWasmOverride>,

    /// Defines all configuration options related to stats reporting.
    #[tsify(optional)]
    pub stats_reporting: Option<StatsReportingWasmOverride>,

    #[tsify(optional)]
    pub forget_me: Option<ForgetMeWasmOverride>,

    #[tsify(optional)]
    pub remember_me: Option<RememberMeWasmOverride>,
}

impl From<DebugWasmOverride> for DebugWasm {
    fn from(value: DebugWasmOverride) -> Self {
        DebugWasm {
            traffic: value.traffic.map(Into::into).unwrap_or_default(),
            cover_traffic: value.cover_traffic.map(Into::into).unwrap_or_default(),
            gateway_connection: value.gateway_connection.map(Into::into).unwrap_or_default(),
            acknowledgements: value.acknowledgements.map(Into::into).unwrap_or_default(),
            topology: value.topology.map(Into::into).unwrap_or_default(),
            reply_surbs: value.reply_surbs.map(Into::into).unwrap_or_default(),
            stats_reporting: value.stats_reporting.map(Into::into).unwrap_or_default(),
            forget_me: value.forget_me.map(Into::into).unwrap_or_default(),
            remember_me: value.remember_me.map(Into::into).unwrap_or_default(),
        }
    }
}

impl From<DebugWasmOverride> for ConfigDebug {
    fn from(value: DebugWasmOverride) -> Self {
        let debug_wasm: DebugWasm = value.into();
        debug_wasm.into()
    }
}

#[derive(Tsify, Debug, Copy, Clone, Serialize, Deserialize)]
#[tsify(into_wasm_abi, from_wasm_abi)]
#[serde(rename_all = "camelCase")]
pub struct TrafficWasmOverride {
    /// The parameter of Poisson distribution determining how long, on average,
    /// sent packet is going to be delayed at any given mix node.
    /// So for a packet going through three mix nodes, on average, it will take three times this value
    /// until the packet reaches its destination.
    #[tsify(optional)]
    pub average_packet_delay_ms: Option<u32>,

    /// The parameter of Poisson distribution determining how long, on average,
    /// it is going to take another 'real traffic stream' message to be sent.
    /// If no real packets are available and cover traffic is enabled,
    /// a loop cover message is sent instead in order to preserve the rate.
    #[tsify(optional)]
    pub message_sending_average_delay_ms: Option<u32>,

    /// Specify how many times particular packet can be retransmitted
    #[tsify(optional)]
    pub maximum_number_of_retransmissions: Option<u32>,

    /// Specify whether route selection should be determined by the packet header.
    #[tsify(optional)]
    pub deterministic_route_selection: Option<bool>,

    /// Controls whether the main packet stream constantly produces packets according to the predefined
    /// poisson distribution.
    #[tsify(optional)]
    pub disable_main_poisson_packet_distribution: Option<bool>,

    /// Controls whether the sent sphinx packet use the NON-DEFAULT bigger size.
    #[tsify(optional)]
    pub use_extended_packet_size: Option<bool>,

    /// Specify whether any constructed sphinx packets should use the legacy format,
    /// where the payload keys are explicitly attached rather than using the seeds
    /// this affects any forward packets, acks and reply surbs
    /// this flag should remain disabled until sufficient number of nodes on the network has upgraded
    /// and support updated format.
    /// in the case of reply surbs, the recipient must also understand the new encoding
    #[tsify(optional)]
    pub use_legacy_sphinx_format: Option<bool>,

    /// Controls whether the sent packets should use outfox as opposed to the default sphinx.
    #[tsify(optional)]
    pub use_outfox: Option<bool>,
}

impl From<TrafficWasmOverride> for TrafficWasm {
    fn from(value: TrafficWasmOverride) -> Self {
        let def = TrafficWasm::default();

        TrafficWasm {
            average_packet_delay_ms: value
                .average_packet_delay_ms
                .unwrap_or(def.average_packet_delay_ms),
            message_sending_average_delay_ms: value
                .message_sending_average_delay_ms
                .unwrap_or(def.message_sending_average_delay_ms),
            maximum_number_of_retransmissions: value.maximum_number_of_retransmissions,
            deterministic_route_selection: value
                .deterministic_route_selection
                .unwrap_or(def.deterministic_route_selection),
            disable_main_poisson_packet_distribution: value
                .disable_main_poisson_packet_distribution
                .unwrap_or(def.disable_main_poisson_packet_distribution),
            use_legacy_sphinx_format: value
                .use_legacy_sphinx_format
                .unwrap_or(def.use_legacy_sphinx_format),
            use_extended_packet_size: value
                .use_extended_packet_size
                .unwrap_or(def.use_extended_packet_size),
            use_outfox: value.use_outfox.unwrap_or(def.use_outfox),
            disable_mix_hops: false, // not configured from js config override yet
        }
    }
}

#[derive(Tsify, Debug, Copy, Clone, Serialize, Deserialize)]
#[tsify(into_wasm_abi, from_wasm_abi)]
#[serde(rename_all = "camelCase")]
pub struct CoverTrafficWasmOverride {
    /// The parameter of Poisson distribution determining how long, on average,
    /// it is going to take for another loop cover traffic message to be sent.
    #[tsify(optional)]
    pub loop_cover_traffic_average_delay_ms: Option<u32>,

    /// Specifies the ratio of `primary_packet_size` to `secondary_packet_size` used in cover traffic.
    /// Only applicable if `secondary_packet_size` is enabled.
    #[tsify(optional)]
    pub cover_traffic_primary_size_ratio: Option<f64>,

    /// Controls whether the dedicated loop cover traffic stream should be enabled.
    /// (and sending packets, on average, every [Self::loop_cover_traffic_average_delay])
    #[tsify(optional)]
    pub disable_loop_cover_traffic_stream: Option<bool>,
}

impl From<CoverTrafficWasmOverride> for CoverTrafficWasm {
    fn from(value: CoverTrafficWasmOverride) -> Self {
        let def = CoverTrafficWasm::default();

        CoverTrafficWasm {
            loop_cover_traffic_average_delay_ms: value
                .loop_cover_traffic_average_delay_ms
                .unwrap_or(def.loop_cover_traffic_average_delay_ms),
            cover_traffic_primary_size_ratio: value
                .cover_traffic_primary_size_ratio
                .unwrap_or(def.cover_traffic_primary_size_ratio),
            disable_loop_cover_traffic_stream: value
                .disable_loop_cover_traffic_stream
                .unwrap_or(def.disable_loop_cover_traffic_stream),
        }
    }
}

#[derive(Tsify, Debug, Copy, Clone, Serialize, Deserialize)]
#[tsify(into_wasm_abi, from_wasm_abi)]
#[serde(rename_all = "camelCase")]
pub struct GatewayConnectionWasmOverride {
    /// How long we're willing to wait for a response to a message sent to the gateway,
    /// before giving up on it.
    #[tsify(optional)]
    pub gateway_response_timeout_ms: Option<u32>,
}

impl From<GatewayConnectionWasmOverride> for GatewayConnectionWasm {
    fn from(value: GatewayConnectionWasmOverride) -> Self {
        let def = GatewayConnectionWasm::default();

        GatewayConnectionWasm {
            gateway_response_timeout_ms: value
                .gateway_response_timeout_ms
                .unwrap_or(def.gateway_response_timeout_ms),
        }
    }
}

#[derive(Tsify, Debug, Copy, Clone, Serialize, Deserialize)]
#[tsify(into_wasm_abi, from_wasm_abi)]
#[serde(rename_all = "camelCase")]
pub struct AcknowledgementsWasmOverride {
    /// The parameter of Poisson distribution determining how long, on average,
    /// sent acknowledgement is going to be delayed at any given mix node.
    /// So for an ack going through three mix nodes, on average, it will take three times this value
    /// until the packet reaches its destination.
    #[tsify(optional)]
    pub average_ack_delay_ms: Option<u32>,

    /// Value multiplied with the expected round trip time of an acknowledgement packet before
    /// it is assumed it was lost and retransmission of the data packet happens.
    /// In an ideal network with 0 latency, this value would have been 1.
    #[tsify(optional)]
    pub ack_wait_multiplier: Option<f64>,

    /// Value added to the expected round trip time of an acknowledgement packet before
    /// it is assumed it was lost and retransmission of the data packet happens.
    /// In an ideal network with 0 latency, this value would have been 0.
    #[tsify(optional)]
    pub ack_wait_addition_ms: Option<u32>,
}

impl From<AcknowledgementsWasmOverride> for AcknowledgementsWasm {
    fn from(value: AcknowledgementsWasmOverride) -> Self {
        let def = AcknowledgementsWasm::default();

        AcknowledgementsWasm {
            average_ack_delay_ms: value
                .average_ack_delay_ms
                .unwrap_or(def.average_ack_delay_ms),
            ack_wait_multiplier: value.ack_wait_multiplier.unwrap_or(def.ack_wait_multiplier),
            ack_wait_addition_ms: value
                .ack_wait_addition_ms
                .unwrap_or(def.ack_wait_addition_ms),
        }
    }
}

#[derive(Tsify, Debug, Copy, Clone, Serialize, Deserialize)]
#[tsify(into_wasm_abi, from_wasm_abi)]
#[serde(rename_all = "camelCase")]
pub struct TopologyWasmOverride {
    /// The uniform delay every which clients are querying the directory server
    /// to try to obtain a compatible network topology to send sphinx packets through.
    #[tsify(optional)]
    pub topology_refresh_rate_ms: Option<u32>,

    /// During topology refresh, test packets are sent through every single possible network
    /// path. This timeout determines waiting period until it is decided that the packet
    /// did not reach its destination.
    #[tsify(optional)]
    pub topology_resolution_timeout_ms: Option<u32>,

    /// Defines how long the client is going to wait on startup for its gateway to come online,
    /// before abandoning the procedure.
    #[tsify(optional)]
    pub max_startup_gateway_waiting_period_ms: Option<u32>,

    /// Specifies whether the client should not refresh the network topology after obtaining
    /// the first valid instance.
    /// Supersedes `topology_refresh_rate_ms`.
    #[tsify(optional)]
    pub disable_refreshing: Option<bool>,

    /// Specifies a minimum performance of a mixnode that is used on route construction.
    /// This setting is only applicable when `NymApi` topology is used.
    #[tsify(optional)]
    pub minimum_mixnode_performance: Option<u8>,

    /// Specifies a minimum performance of a gateway that is used on route construction.
    /// This setting is only applicable when `NymApi` topology is used.
    #[tsify(optional)]
    pub minimum_gateway_performance: Option<u8>,

    /// Specifies whether this client should attempt to retrieve all available network nodes
    /// as opposed to just active mixnodes/gateways.
    #[tsify(optional)]
    pub use_extended_topology: Option<bool>,

    /// Specifies whether this client should ignore the current epoch role of the target egress node
    /// when constructing the final hop packets.
    #[tsify(optional)]
    pub ignore_egress_epoch_role: Option<bool>,

    /// Specifies whether this client should ignore the current epoch role of the ingress node
    /// when attempting to establish new connection
    #[tsify(optional)]
    pub ignore_ingress_epoch_role: Option<bool>,
}

impl From<TopologyWasmOverride> for TopologyWasm {
    fn from(value: TopologyWasmOverride) -> Self {
        let def = TopologyWasm::default();

        TopologyWasm {
            topology_refresh_rate_ms: value
                .topology_refresh_rate_ms
                .unwrap_or(def.topology_refresh_rate_ms),
            topology_resolution_timeout_ms: value
                .topology_resolution_timeout_ms
                .unwrap_or(def.topology_resolution_timeout_ms),
            max_startup_gateway_waiting_period_ms: value
                .max_startup_gateway_waiting_period_ms
                .unwrap_or(def.max_startup_gateway_waiting_period_ms),
            disable_refreshing: value.disable_refreshing.unwrap_or(def.disable_refreshing),
            minimum_mixnode_performance: value
                .minimum_mixnode_performance
                .unwrap_or(def.minimum_mixnode_performance),
            minimum_gateway_performance: value
                .minimum_gateway_performance
                .unwrap_or(def.minimum_gateway_performance),
            use_extended_topology: value
                .use_extended_topology
                .unwrap_or(def.use_extended_topology),
            ignore_egress_epoch_role: value
                .ignore_egress_epoch_role
                .unwrap_or(def.ignore_egress_epoch_role),
            ignore_ingress_epoch_role: value
                .ignore_ingress_epoch_role
                .unwrap_or(def.ignore_ingress_epoch_role),
        }
    }
}

#[derive(Tsify, Debug, Copy, Clone, Serialize, Deserialize)]
#[tsify(into_wasm_abi, from_wasm_abi)]
#[serde(rename_all = "camelCase")]
pub struct ReplySurbsWasmOverride {
    /// Defines the minimum number of reply surbs the client wants to keep in its storage at all times.
    /// It can only allow to go below that value if its to request additional reply surbs.
    #[tsify(optional)]
    pub minimum_reply_surb_storage_threshold: Option<usize>,

    /// Defines the maximum number of reply surbs the client wants to keep in its storage at any times.
    #[tsify(optional)]
    pub maximum_reply_surb_storage_threshold: Option<usize>,

    /// Defines the soft threshold ontop of the minimum reply surb storage threshold for when the client
    /// should proactively request additional reply surbs.
    #[tsify(optional)]
    pub minimum_reply_surb_threshold_buffer: Option<usize>,

    /// Defines the minimum number of reply surbs the client would request.
    #[tsify(optional)]
    pub minimum_reply_surb_request_size: Option<u32>,

    /// Defines the maximum number of reply surbs the client would request.
    #[tsify(optional)]
    pub maximum_reply_surb_request_size: Option<u32>,

    /// Defines the maximum number of reply surbs a remote party is allowed to request from this client at once.
    #[tsify(optional)]
    pub maximum_allowed_reply_surb_request_size: Option<u32>,

    /// Defines maximum amount of time the client is going to wait for reply surbs before explicitly asking
    /// for more even though in theory they wouldn't need to.
    #[tsify(optional)]
    pub maximum_reply_surb_rerequest_waiting_period_ms: Option<u32>,

    /// Defines maximum amount of time the client is going to wait for reply surbs before
    /// deciding it's never going to get them and would drop all pending messages
    #[tsify(optional)]
    pub maximum_reply_surb_drop_waiting_period_ms: Option<u32>,

    /// Defines maximum amount of time given reply key is going to be valid for.
    /// This is going to be superseded by key rotation once implemented.
    #[tsify(optional)]
    pub maximum_reply_key_age_ms: Option<u32>,

    /// Defines maximum number of times the client is going to re-request reply surbs
    /// for clearing pending messages before giving up after making no progress.
    #[tsify(optional)]
    pub maximum_reply_surbs_rerequests: Option<usize>,

    #[tsify(optional)]
    pub surb_mix_hops: Option<u8>,

    /// Specifies if we should reset all the sender tags on startup
    pub fresh_sender_tags: bool,
}

impl From<ReplySurbsWasmOverride> for ReplySurbsWasm {
    fn from(value: ReplySurbsWasmOverride) -> Self {
        let def = ReplySurbsWasm::default();

        ReplySurbsWasm {
            minimum_reply_surb_storage_threshold: value
                .minimum_reply_surb_storage_threshold
                .unwrap_or(def.minimum_reply_surb_storage_threshold),
            maximum_reply_surb_storage_threshold: value
                .maximum_reply_surb_storage_threshold
                .unwrap_or(def.maximum_reply_surb_storage_threshold),
            minimum_reply_surb_threshold_buffer: value
                .minimum_reply_surb_threshold_buffer
                .unwrap_or(def.minimum_reply_surb_threshold_buffer),
            minimum_reply_surb_request_size: value
                .minimum_reply_surb_request_size
                .unwrap_or(def.minimum_reply_surb_request_size),
            maximum_reply_surb_request_size: value
                .maximum_reply_surb_request_size
                .unwrap_or(def.maximum_reply_surb_request_size),
            maximum_allowed_reply_surb_request_size: value
                .maximum_allowed_reply_surb_request_size
                .unwrap_or(def.maximum_allowed_reply_surb_request_size),
            maximum_reply_surb_rerequest_waiting_period_ms: value
                .maximum_reply_surb_rerequest_waiting_period_ms
                .unwrap_or(def.maximum_reply_surb_rerequest_waiting_period_ms),
            maximum_reply_surb_drop_waiting_period_ms: value
                .maximum_reply_surb_drop_waiting_period_ms
                .unwrap_or(def.maximum_reply_surb_drop_waiting_period_ms),
            maximum_reply_key_age_ms: value
                .maximum_reply_key_age_ms
                .unwrap_or(def.maximum_reply_key_age_ms),
            surb_mix_hops: value.surb_mix_hops,
            maximum_reply_surbs_rerequests: value
                .maximum_reply_surbs_rerequests
                .unwrap_or(def.maximum_reply_surbs_rerequests),
        }
    }
}

#[derive(Tsify, Debug, Clone, Serialize, Deserialize)]
#[tsify(into_wasm_abi, from_wasm_abi)]
#[serde(rename_all = "camelCase")]
pub struct ForgetMeWasmOverride {
    #[tsify(optional)]
    pub client: Option<bool>,

    #[tsify(optional)]
    pub stats: Option<bool>,
}

impl From<ForgetMeWasmOverride> for ForgetMeWasm {
    fn from(value: ForgetMeWasmOverride) -> Self {
        ForgetMeWasm {
            client: value.client.unwrap_or_default(),
            stats: value.stats.unwrap_or_default(),
        }
    }
}

#[derive(Tsify, Debug, Clone, Serialize, Deserialize)]
#[tsify(into_wasm_abi, from_wasm_abi)]
#[serde(rename_all = "camelCase")]
pub struct RememberMeWasmOverride {
    #[tsify(optional)]
    pub stats: Option<bool>,
}

impl From<RememberMeWasmOverride> for RememberMeWasm {
    fn from(value: RememberMeWasmOverride) -> Self {
        RememberMeWasm {
            stats: value.stats.unwrap_or_default(),
        }
    }
}

#[derive(Tsify, Debug, Clone, Serialize, Deserialize)]
#[tsify(into_wasm_abi, from_wasm_abi)]
#[serde(rename_all = "camelCase")]
pub struct StatsReportingWasmOverride {
    /// Is stats reporting enabled
    #[tsify(optional)]
    pub enabled: Option<bool>,

    /// Address of the stats collector. If this is none, no reporting will happen, regardless of `enabled`
    #[tsify(optional)]
    pub provider_address: Option<Option<String>>,

    /// With what frequence will statistics be sent
    #[tsify(optional)]
    pub reporting_interval_ms: Option<u32>,
}

impl From<StatsReportingWasmOverride> for StatsReportingWasm {
    fn from(value: StatsReportingWasmOverride) -> Self {
        let def = StatsReportingWasm::default();

        StatsReportingWasm {
            enabled: value.enabled.unwrap_or(def.enabled),
            provider_address: value.provider_address.unwrap_or(def.provider_address),
            reporting_interval_ms: value
                .reporting_interval_ms
                .unwrap_or(def.reporting_interval_ms),
        }
    }
}
