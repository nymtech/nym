{
  "contract_name": "nym-mixnet-contract",
  "contract_version": "1.5.1",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "type": "object",
    "required": [
      "epoch_duration",
      "epochs_in_interval",
      "initial_rewarding_params",
      "rewarding_denom",
      "rewarding_validator_address",
      "vesting_contract_address"
    ],
    "properties": {
      "epoch_duration": {
        "$ref": "#/definitions/Duration"
      },
      "epochs_in_interval": {
        "type": "integer",
        "format": "uint32",
        "minimum": 0.0
      },
      "initial_rewarding_params": {
        "$ref": "#/definitions/InitialRewardingParams"
      },
      "interval_operating_cost": {
        "default": {
          "maximum": "1000000000000000",
          "minimum": "0"
        },
        "allOf": [
          {
            "$ref": "#/definitions/RangedValue_for_Uint128"
          }
        ]
      },
      "profit_margin": {
        "default": {
          "maximum": "1",
          "minimum": "0"
        },
        "allOf": [
          {
            "$ref": "#/definitions/RangedValue_for_Percent"
          }
        ]
      },
      "rewarding_denom": {
        "type": "string"
      },
      "rewarding_validator_address": {
        "type": "string"
      },
      "vesting_contract_address": {
        "type": "string"
      }
    },
    "additionalProperties": false,
    "definitions": {
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "Duration": {
        "type": "object",
        "required": [
          "nanos",
          "secs"
        ],
        "properties": {
          "nanos": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0.0
          },
          "secs": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          }
        }
      },
      "InitialRewardingParams": {
        "type": "object",
        "required": [
          "active_set_work_factor",
          "initial_reward_pool",
          "initial_staking_supply",
          "interval_pool_emission",
          "rewarded_set_params",
          "staking_supply_scale_factor",
          "sybil_resistance"
        ],
        "properties": {
          "active_set_work_factor": {
            "$ref": "#/definitions/Decimal"
          },
          "initial_reward_pool": {
            "$ref": "#/definitions/Decimal"
          },
          "initial_staking_supply": {
            "$ref": "#/definitions/Decimal"
          },
          "interval_pool_emission": {
            "$ref": "#/definitions/Percent"
          },
          "rewarded_set_params": {
            "$ref": "#/definitions/RewardedSetParams"
          },
          "staking_supply_scale_factor": {
            "$ref": "#/definitions/Percent"
          },
          "sybil_resistance": {
            "$ref": "#/definitions/Percent"
          }
        },
        "additionalProperties": false
      },
      "Percent": {
        "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
        "allOf": [
          {
            "$ref": "#/definitions/Decimal"
          }
        ]
      },
      "RangedValue_for_Percent": {
        "type": "object",
        "required": [
          "maximum",
          "minimum"
        ],
        "properties": {
          "maximum": {
            "$ref": "#/definitions/Percent"
          },
          "minimum": {
            "$ref": "#/definitions/Percent"
          }
        },
        "additionalProperties": false
      },
      "RangedValue_for_Uint128": {
        "type": "object",
        "required": [
          "maximum",
          "minimum"
        ],
        "properties": {
          "maximum": {
            "$ref": "#/definitions/Uint128"
          },
          "minimum": {
            "$ref": "#/definitions/Uint128"
          }
        },
        "additionalProperties": false
      },
      "RewardedSetParams": {
        "type": "object",
        "required": [
          "entry_gateways",
          "exit_gateways",
          "mixnodes",
          "standby"
        ],
        "properties": {
          "entry_gateways": {
            "description": "The expected number of nodes assigned entry gateway role (i.e. [`Role::EntryGateway`])",
            "type": "integer",
            "format": "uint32",
            "minimum": 0.0
          },
          "exit_gateways": {
            "description": "The expected number of nodes assigned exit gateway role (i.e. [`Role::ExitGateway`])",
            "type": "integer",
            "format": "uint32",
            "minimum": 0.0
          },
          "mixnodes": {
            "description": "The expected number of nodes assigned the 'mixnode' role, i.e. total of [`Role::Layer1`], [`Role::Layer2`] and [`Role::Layer3`].",
            "type": "integer",
            "format": "uint32",
            "minimum": 0.0
          },
          "standby": {
            "description": "Number of nodes in the 'standby' set. (i.e. [`Role::Standby`])",
            "type": "integer",
            "format": "uint32",
            "minimum": 0.0
          }
        },
        "additionalProperties": false
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "description": "Change the admin",
        "type": "object",
        "required": [
          "update_admin"
        ],
        "properties": {
          "update_admin": {
            "type": "object",
            "required": [
              "admin"
            ],
            "properties": {
              "admin": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_rewarding_validator_address"
        ],
        "properties": {
          "update_rewarding_validator_address": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_contract_state_params"
        ],
        "properties": {
          "update_contract_state_params": {
            "type": "object",
            "required": [
              "updated_parameters"
            ],
            "properties": {
              "updated_parameters": {
                "$ref": "#/definitions/ContractStateParams"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_active_set_distribution"
        ],
        "properties": {
          "update_active_set_distribution": {
            "type": "object",
            "required": [
              "force_immediately",
              "update"
            ],
            "properties": {
              "force_immediately": {
                "type": "boolean"
              },
              "update": {
                "$ref": "#/definitions/ActiveSetUpdate"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_rewarding_params"
        ],
        "properties": {
          "update_rewarding_params": {
            "type": "object",
            "required": [
              "force_immediately",
              "updated_params"
            ],
            "properties": {
              "force_immediately": {
                "type": "boolean"
              },
              "updated_params": {
                "$ref": "#/definitions/IntervalRewardingParamsUpdate"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_interval_config"
        ],
        "properties": {
          "update_interval_config": {
            "type": "object",
            "required": [
              "epoch_duration_secs",
              "epochs_in_interval",
              "force_immediately"
            ],
            "properties": {
              "epoch_duration_secs": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              },
              "epochs_in_interval": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              "force_immediately": {
                "type": "boolean"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "begin_epoch_transition"
        ],
        "properties": {
          "begin_epoch_transition": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "reconcile_epoch_events"
        ],
        "properties": {
          "reconcile_epoch_events": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "assign_roles"
        ],
        "properties": {
          "assign_roles": {
            "type": "object",
            "required": [
              "assignment"
            ],
            "properties": {
              "assignment": {
                "$ref": "#/definitions/RoleAssignment"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "bond_mixnode"
        ],
        "properties": {
          "bond_mixnode": {
            "type": "object",
            "required": [
              "cost_params",
              "mix_node",
              "owner_signature"
            ],
            "properties": {
              "cost_params": {
                "$ref": "#/definitions/NodeCostParams"
              },
              "mix_node": {
                "$ref": "#/definitions/MixNode"
              },
              "owner_signature": {
                "$ref": "#/definitions/MessageSignature"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "bond_mixnode_on_behalf"
        ],
        "properties": {
          "bond_mixnode_on_behalf": {
            "type": "object",
            "required": [
              "cost_params",
              "mix_node",
              "owner",
              "owner_signature"
            ],
            "properties": {
              "cost_params": {
                "$ref": "#/definitions/NodeCostParams"
              },
              "mix_node": {
                "$ref": "#/definitions/MixNode"
              },
              "owner": {
                "type": "string"
              },
              "owner_signature": {
                "$ref": "#/definitions/MessageSignature"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "pledge_more"
        ],
        "properties": {
          "pledge_more": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "pledge_more_on_behalf"
        ],
        "properties": {
          "pledge_more_on_behalf": {
            "type": "object",
            "required": [
              "owner"
            ],
            "properties": {
              "owner": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "decrease_pledge"
        ],
        "properties": {
          "decrease_pledge": {
            "type": "object",
            "required": [
              "decrease_by"
            ],
            "properties": {
              "decrease_by": {
                "$ref": "#/definitions/Coin"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "decrease_pledge_on_behalf"
        ],
        "properties": {
          "decrease_pledge_on_behalf": {
            "type": "object",
            "required": [
              "decrease_by",
              "owner"
            ],
            "properties": {
              "decrease_by": {
                "$ref": "#/definitions/Coin"
              },
              "owner": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "unbond_mixnode"
        ],
        "properties": {
          "unbond_mixnode": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "unbond_mixnode_on_behalf"
        ],
        "properties": {
          "unbond_mixnode_on_behalf": {
            "type": "object",
            "required": [
              "owner"
            ],
            "properties": {
              "owner": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_cost_params"
        ],
        "properties": {
          "update_cost_params": {
            "type": "object",
            "required": [
              "new_costs"
            ],
            "properties": {
              "new_costs": {
                "$ref": "#/definitions/NodeCostParams"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_mixnode_cost_params_on_behalf"
        ],
        "properties": {
          "update_mixnode_cost_params_on_behalf": {
            "type": "object",
            "required": [
              "new_costs",
              "owner"
            ],
            "properties": {
              "new_costs": {
                "$ref": "#/definitions/NodeCostParams"
              },
              "owner": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_mixnode_config"
        ],
        "properties": {
          "update_mixnode_config": {
            "type": "object",
            "required": [
              "new_config"
            ],
            "properties": {
              "new_config": {
                "$ref": "#/definitions/MixNodeConfigUpdate"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_mixnode_config_on_behalf"
        ],
        "properties": {
          "update_mixnode_config_on_behalf": {
            "type": "object",
            "required": [
              "new_config",
              "owner"
            ],
            "properties": {
              "new_config": {
                "$ref": "#/definitions/MixNodeConfigUpdate"
              },
              "owner": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "migrate_mixnode"
        ],
        "properties": {
          "migrate_mixnode": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "bond_gateway"
        ],
        "properties": {
          "bond_gateway": {
            "type": "object",
            "required": [
              "gateway",
              "owner_signature"
            ],
            "properties": {
              "gateway": {
                "$ref": "#/definitions/Gateway"
              },
              "owner_signature": {
                "$ref": "#/definitions/MessageSignature"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "bond_gateway_on_behalf"
        ],
        "properties": {
          "bond_gateway_on_behalf": {
            "type": "object",
            "required": [
              "gateway",
              "owner",
              "owner_signature"
            ],
            "properties": {
              "gateway": {
                "$ref": "#/definitions/Gateway"
              },
              "owner": {
                "type": "string"
              },
              "owner_signature": {
                "$ref": "#/definitions/MessageSignature"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "unbond_gateway"
        ],
        "properties": {
          "unbond_gateway": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "unbond_gateway_on_behalf"
        ],
        "properties": {
          "unbond_gateway_on_behalf": {
            "type": "object",
            "required": [
              "owner"
            ],
            "properties": {
              "owner": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_gateway_config"
        ],
        "properties": {
          "update_gateway_config": {
            "type": "object",
            "required": [
              "new_config"
            ],
            "properties": {
              "new_config": {
                "$ref": "#/definitions/GatewayConfigUpdate"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_gateway_config_on_behalf"
        ],
        "properties": {
          "update_gateway_config_on_behalf": {
            "type": "object",
            "required": [
              "new_config",
              "owner"
            ],
            "properties": {
              "new_config": {
                "$ref": "#/definitions/GatewayConfigUpdate"
              },
              "owner": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "migrate_gateway"
        ],
        "properties": {
          "migrate_gateway": {
            "type": "object",
            "properties": {
              "cost_params": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/NodeCostParams"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "bond_nym_node"
        ],
        "properties": {
          "bond_nym_node": {
            "type": "object",
            "required": [
              "cost_params",
              "node",
              "owner_signature"
            ],
            "properties": {
              "cost_params": {
                "$ref": "#/definitions/NodeCostParams"
              },
              "node": {
                "$ref": "#/definitions/NymNode"
              },
              "owner_signature": {
                "$ref": "#/definitions/MessageSignature"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "unbond_nym_node"
        ],
        "properties": {
          "unbond_nym_node": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_node_config"
        ],
        "properties": {
          "update_node_config": {
            "type": "object",
            "required": [
              "update"
            ],
            "properties": {
              "update": {
                "$ref": "#/definitions/NodeConfigUpdate"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "delegate"
        ],
        "properties": {
          "delegate": {
            "type": "object",
            "required": [
              "node_id"
            ],
            "properties": {
              "node_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "delegate_to_mixnode_on_behalf"
        ],
        "properties": {
          "delegate_to_mixnode_on_behalf": {
            "type": "object",
            "required": [
              "delegate",
              "mix_id"
            ],
            "properties": {
              "delegate": {
                "type": "string"
              },
              "mix_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "undelegate"
        ],
        "properties": {
          "undelegate": {
            "type": "object",
            "required": [
              "node_id"
            ],
            "properties": {
              "node_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "undelegate_from_mixnode_on_behalf"
        ],
        "properties": {
          "undelegate_from_mixnode_on_behalf": {
            "type": "object",
            "required": [
              "delegate",
              "mix_id"
            ],
            "properties": {
              "delegate": {
                "type": "string"
              },
              "mix_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "reward_node"
        ],
        "properties": {
          "reward_node": {
            "type": "object",
            "required": [
              "node_id",
              "params"
            ],
            "properties": {
              "node_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              "params": {
                "$ref": "#/definitions/NodeRewardingParameters"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "withdraw_operator_reward"
        ],
        "properties": {
          "withdraw_operator_reward": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "withdraw_operator_reward_on_behalf"
        ],
        "properties": {
          "withdraw_operator_reward_on_behalf": {
            "type": "object",
            "required": [
              "owner"
            ],
            "properties": {
              "owner": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "withdraw_delegator_reward"
        ],
        "properties": {
          "withdraw_delegator_reward": {
            "type": "object",
            "required": [
              "node_id"
            ],
            "properties": {
              "node_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "withdraw_delegator_reward_on_behalf"
        ],
        "properties": {
          "withdraw_delegator_reward_on_behalf": {
            "type": "object",
            "required": [
              "mix_id",
              "owner"
            ],
            "properties": {
              "mix_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              "owner": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "migrate_vested_mix_node"
        ],
        "properties": {
          "migrate_vested_mix_node": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "migrate_vested_delegation"
        ],
        "properties": {
          "migrate_vested_delegation": {
            "type": "object",
            "required": [
              "mix_id"
            ],
            "properties": {
              "mix_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "testing_unchecked_bond_legacy_mixnode"
        ],
        "properties": {
          "testing_unchecked_bond_legacy_mixnode": {
            "type": "object",
            "required": [
              "node"
            ],
            "properties": {
              "node": {
                "$ref": "#/definitions/MixNode"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "testing_unchecked_bond_legacy_gateway"
        ],
        "properties": {
          "testing_unchecked_bond_legacy_gateway": {
            "type": "object",
            "required": [
              "node"
            ],
            "properties": {
              "node": {
                "$ref": "#/definitions/Gateway"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "ActiveSetUpdate": {
        "description": "Specification on how the active set should be updated.",
        "type": "object",
        "required": [
          "entry_gateways",
          "exit_gateways",
          "mixnodes"
        ],
        "properties": {
          "entry_gateways": {
            "description": "The expected number of nodes assigned entry gateway role (i.e. [`Role::EntryGateway`])",
            "type": "integer",
            "format": "uint32",
            "minimum": 0.0
          },
          "exit_gateways": {
            "description": "The expected number of nodes assigned exit gateway role (i.e. [`Role::ExitGateway`])",
            "type": "integer",
            "format": "uint32",
            "minimum": 0.0
          },
          "mixnodes": {
            "description": "The expected number of nodes assigned the 'mixnode' role, i.e. total of [`Role::Layer1`], [`Role::Layer2`] and [`Role::Layer3`].",
            "type": "integer",
            "format": "uint32",
            "minimum": 0.0
          }
        },
        "additionalProperties": false
      },
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "ContractStateParams": {
        "description": "Contract parameters that could be adjusted in a transaction by the contract admin.",
        "type": "object",
        "required": [
          "minimum_pledge"
        ],
        "properties": {
          "interval_operating_cost": {
            "description": "Defines the allowed interval operating cost range of operators. default: 0 - 1'000'000'000'000'000 (1 Billion native tokens - the total supply)",
            "default": {
              "maximum": "1000000000000000",
              "minimum": "0"
            },
            "allOf": [
              {
                "$ref": "#/definitions/RangedValue_for_Uint128"
              }
            ]
          },
          "minimum_delegation": {
            "description": "Minimum amount a delegator must stake in orders for his delegation to get accepted.",
            "anyOf": [
              {
                "$ref": "#/definitions/Coin"
              },
              {
                "type": "null"
              }
            ]
          },
          "minimum_pledge": {
            "description": "Minimum amount a node must pledge to get into the system.",
            "allOf": [
              {
                "$ref": "#/definitions/Coin"
              }
            ]
          },
          "profit_margin": {
            "description": "Defines the allowed profit margin range of operators. default: 0% - 100%",
            "default": {
              "maximum": "1",
              "minimum": "0"
            },
            "allOf": [
              {
                "$ref": "#/definitions/RangedValue_for_Percent"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "Gateway": {
        "description": "Information provided by the node operator during bonding that are used to allow other entities to use the services of this node.",
        "type": "object",
        "required": [
          "clients_port",
          "host",
          "identity_key",
          "location",
          "mix_port",
          "sphinx_key",
          "version"
        ],
        "properties": {
          "clients_port": {
            "description": "Port used by this gateway for listening for client requests.",
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "host": {
            "description": "Network address of this gateway, for example 1.1.1.1 or foo.gateway.com",
            "type": "string"
          },
          "identity_key": {
            "description": "Base58 encoded ed25519 EdDSA public key of the gateway used to derive shared keys with clients",
            "type": "string"
          },
          "location": {
            "description": "The physical, self-reported, location of this gateway.",
            "type": "string"
          },
          "mix_port": {
            "description": "Port used by this gateway for listening for mix packets.",
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "sphinx_key": {
            "description": "Base58-encoded x25519 public key used for sphinx key derivation.",
            "type": "string"
          },
          "version": {
            "description": "The self-reported semver version of this gateway.",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "GatewayConfigUpdate": {
        "type": "object",
        "required": [
          "clients_port",
          "host",
          "location",
          "mix_port",
          "version"
        ],
        "properties": {
          "clients_port": {
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "host": {
            "type": "string"
          },
          "location": {
            "type": "string"
          },
          "mix_port": {
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "version": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "IntervalRewardingParamsUpdate": {
        "description": "Specification on how the rewarding params should be updated.",
        "type": "object",
        "properties": {
          "active_set_work_factor": {
            "description": "Defines the new value of the active set work factor.",
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "interval_pool_emission": {
            "description": "Defines the new value of the interval pool emission rate.",
            "anyOf": [
              {
                "$ref": "#/definitions/Percent"
              },
              {
                "type": "null"
              }
            ]
          },
          "reward_pool": {
            "description": "Defines the new value of the reward pool.",
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "rewarded_set_params": {
            "description": "Defines the parameters of the rewarded set.",
            "anyOf": [
              {
                "$ref": "#/definitions/RewardedSetParams"
              },
              {
                "type": "null"
              }
            ]
          },
          "staking_supply": {
            "description": "Defines the new value of the staking supply.",
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "staking_supply_scale_factor": {
            "description": "Defines the new value of the staking supply scale factor.",
            "anyOf": [
              {
                "$ref": "#/definitions/Percent"
              },
              {
                "type": "null"
              }
            ]
          },
          "sybil_resistance_percent": {
            "description": "Defines the new value of the sybil resistance percent.",
            "anyOf": [
              {
                "$ref": "#/definitions/Percent"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "MessageSignature": {
        "type": "array",
        "items": {
          "type": "integer",
          "format": "uint8",
          "minimum": 0.0
        }
      },
      "MixNode": {
        "description": "Information provided by the node operator during bonding that are used to allow other entities to use the services of this node.",
        "type": "object",
        "required": [
          "host",
          "http_api_port",
          "identity_key",
          "mix_port",
          "sphinx_key",
          "verloc_port",
          "version"
        ],
        "properties": {
          "host": {
            "description": "Network address of this mixnode, for example 1.1.1.1 or foo.mixnode.com",
            "type": "string"
          },
          "http_api_port": {
            "description": "Port used by this mixnode for its http(s) API",
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "identity_key": {
            "description": "Base58-encoded ed25519 EdDSA public key.",
            "type": "string"
          },
          "mix_port": {
            "description": "Port used by this mixnode for listening for mix packets.",
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "sphinx_key": {
            "description": "Base58-encoded x25519 public key used for sphinx key derivation.",
            "type": "string"
          },
          "verloc_port": {
            "description": "Port used by this mixnode for listening for verloc requests.",
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "version": {
            "description": "The self-reported semver version of this mixnode.",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "MixNodeConfigUpdate": {
        "type": "object",
        "required": [
          "host",
          "http_api_port",
          "mix_port",
          "verloc_port",
          "version"
        ],
        "properties": {
          "host": {
            "type": "string"
          },
          "http_api_port": {
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "mix_port": {
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "verloc_port": {
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "version": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "NodeConfigUpdate": {
        "type": "object",
        "properties": {
          "custom_http_port": {
            "type": [
              "integer",
              "null"
            ],
            "format": "uint16",
            "minimum": 0.0
          },
          "host": {
            "type": [
              "string",
              "null"
            ]
          },
          "restore_default_http_port": {
            "default": false,
            "type": "boolean"
          }
        },
        "additionalProperties": false
      },
      "NodeCostParams": {
        "description": "The cost parameters, or the cost function, defined for the particular mixnode that influences how the rewards should be split between the node operator and its delegators.",
        "type": "object",
        "required": [
          "interval_operating_cost",
          "profit_margin_percent"
        ],
        "properties": {
          "interval_operating_cost": {
            "description": "Operating cost of the associated node per the entire interval.",
            "allOf": [
              {
                "$ref": "#/definitions/Coin"
              }
            ]
          },
          "profit_margin_percent": {
            "description": "The profit margin of the associated node, i.e. the desired percent of the reward to be distributed to the operator.",
            "allOf": [
              {
                "$ref": "#/definitions/Percent"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "NodeRewardingParameters": {
        "description": "Parameters used for rewarding particular node.",
        "type": "object",
        "required": [
          "performance",
          "work_factor"
        ],
        "properties": {
          "performance": {
            "description": "Performance of the particular node in the current epoch.",
            "allOf": [
              {
                "$ref": "#/definitions/Percent"
              }
            ]
          },
          "work_factor": {
            "description": "Amount of work performed by this node in the current epoch also known as 'omega' in the paper",
            "allOf": [
              {
                "$ref": "#/definitions/Decimal"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "NymNode": {
        "description": "Information provided by the node operator during bonding that are used to allow other entities to use the services of this node.",
        "type": "object",
        "required": [
          "host",
          "identity_key"
        ],
        "properties": {
          "custom_http_port": {
            "description": "Allow specifying custom port for accessing the http, and thus self-described, api of this node for the capabilities discovery.",
            "type": [
              "integer",
              "null"
            ],
            "format": "uint16",
            "minimum": 0.0
          },
          "host": {
            "description": "Network address of this nym-node, for example 1.1.1.1 or foo.mixnode.com that is used to discover other capabilities of this node.",
            "type": "string"
          },
          "identity_key": {
            "description": "Base58-encoded ed25519 EdDSA public key.",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "Percent": {
        "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
        "allOf": [
          {
            "$ref": "#/definitions/Decimal"
          }
        ]
      },
      "RangedValue_for_Percent": {
        "type": "object",
        "required": [
          "maximum",
          "minimum"
        ],
        "properties": {
          "maximum": {
            "$ref": "#/definitions/Percent"
          },
          "minimum": {
            "$ref": "#/definitions/Percent"
          }
        },
        "additionalProperties": false
      },
      "RangedValue_for_Uint128": {
        "type": "object",
        "required": [
          "maximum",
          "minimum"
        ],
        "properties": {
          "maximum": {
            "$ref": "#/definitions/Uint128"
          },
          "minimum": {
            "$ref": "#/definitions/Uint128"
          }
        },
        "additionalProperties": false
      },
      "RewardedSetParams": {
        "type": "object",
        "required": [
          "entry_gateways",
          "exit_gateways",
          "mixnodes",
          "standby"
        ],
        "properties": {
          "entry_gateways": {
            "description": "The expected number of nodes assigned entry gateway role (i.e. [`Role::EntryGateway`])",
            "type": "integer",
            "format": "uint32",
            "minimum": 0.0
          },
          "exit_gateways": {
            "description": "The expected number of nodes assigned exit gateway role (i.e. [`Role::ExitGateway`])",
            "type": "integer",
            "format": "uint32",
            "minimum": 0.0
          },
          "mixnodes": {
            "description": "The expected number of nodes assigned the 'mixnode' role, i.e. total of [`Role::Layer1`], [`Role::Layer2`] and [`Role::Layer3`].",
            "type": "integer",
            "format": "uint32",
            "minimum": 0.0
          },
          "standby": {
            "description": "Number of nodes in the 'standby' set. (i.e. [`Role::Standby`])",
            "type": "integer",
            "format": "uint32",
            "minimum": 0.0
          }
        },
        "additionalProperties": false
      },
      "Role": {
        "type": "string",
        "enum": [
          "eg",
          "l1",
          "l2",
          "l3",
          "xg",
          "stb"
        ]
      },
      "RoleAssignment": {
        "type": "object",
        "required": [
          "nodes",
          "role"
        ],
        "properties": {
          "nodes": {
            "type": "array",
            "items": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "role": {
            "$ref": "#/definitions/Role"
          }
        },
        "additionalProperties": false
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "admin"
        ],
        "properties": {
          "admin": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets build information of this contract, such as the commit hash used for the build or rustc version.",
        "type": "object",
        "required": [
          "get_contract_version"
        ],
        "properties": {
          "get_contract_version": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the stored contract version information that's required by the CW2 spec interface for migrations.",
        "type": "object",
        "required": [
          "get_cw2_contract_version"
        ],
        "properties": {
          "get_cw2_contract_version": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the address of the validator that's allowed to send rewarding transactions and transition the epoch.",
        "type": "object",
        "required": [
          "get_rewarding_validator_address"
        ],
        "properties": {
          "get_rewarding_validator_address": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the contract parameters that could be adjusted in a transaction by the contract admin.",
        "type": "object",
        "required": [
          "get_state_params"
        ],
        "properties": {
          "get_state_params": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the current state of the contract.",
        "type": "object",
        "required": [
          "get_state"
        ],
        "properties": {
          "get_state": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the current parameters used for reward calculation.",
        "type": "object",
        "required": [
          "get_rewarding_params"
        ],
        "properties": {
          "get_rewarding_params": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the status of the current rewarding epoch.",
        "type": "object",
        "required": [
          "get_epoch_status"
        ],
        "properties": {
          "get_epoch_status": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Get the details of the current rewarding interval.",
        "type": "object",
        "required": [
          "get_current_interval_details"
        ],
        "properties": {
          "get_current_interval_details": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the basic list of all currently bonded mixnodes.",
        "type": "object",
        "required": [
          "get_mix_node_bonds"
        ],
        "properties": {
          "get_mix_node_bonds": {
            "type": "object",
            "properties": {
              "limit": {
                "description": "Controls the maximum number of entries returned by the query. Note that too large values will be overwritten by a saner default.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "Pagination control for the values returned by the query. Note that the provided value itself will **not** be used for the response.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the detailed list of all currently bonded mixnodes.",
        "type": "object",
        "required": [
          "get_mix_nodes_detailed"
        ],
        "properties": {
          "get_mix_nodes_detailed": {
            "type": "object",
            "properties": {
              "limit": {
                "description": "Controls the maximum number of entries returned by the query. Note that too large values will be overwritten by a saner default.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "Pagination control for the values returned by the query. Note that the provided value itself will **not** be used for the response.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the basic list of all unbonded mixnodes.",
        "type": "object",
        "required": [
          "get_unbonded_mix_nodes"
        ],
        "properties": {
          "get_unbonded_mix_nodes": {
            "type": "object",
            "properties": {
              "limit": {
                "description": "Controls the maximum number of entries returned by the query. Note that too large values will be overwritten by a saner default.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "Pagination control for the values returned by the query. Note that the provided value itself will **not** be used for the response.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the basic list of all unbonded mixnodes that belonged to a particular owner.",
        "type": "object",
        "required": [
          "get_unbonded_mix_nodes_by_owner"
        ],
        "properties": {
          "get_unbonded_mix_nodes_by_owner": {
            "type": "object",
            "required": [
              "owner"
            ],
            "properties": {
              "limit": {
                "description": "Controls the maximum number of entries returned by the query. Note that too large values will be overwritten by a saner default.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "owner": {
                "description": "The address of the owner of the mixnodes used for the query.",
                "type": "string"
              },
              "start_after": {
                "description": "Pagination control for the values returned by the query. Note that the provided value itself will **not** be used for the response.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the basic list of all unbonded mixnodes that used the particular identity key.",
        "type": "object",
        "required": [
          "get_unbonded_mix_nodes_by_identity_key"
        ],
        "properties": {
          "get_unbonded_mix_nodes_by_identity_key": {
            "type": "object",
            "required": [
              "identity_key"
            ],
            "properties": {
              "identity_key": {
                "description": "The identity key (base58-encoded ed25519 public key) of the mixnode used for the query.",
                "type": "string"
              },
              "limit": {
                "description": "Controls the maximum number of entries returned by the query. Note that too large values will be overwritten by a saner default.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "Pagination control for the values returned by the query. Note that the provided value itself will **not** be used for the response.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the detailed mixnode information belonging to the particular owner.",
        "type": "object",
        "required": [
          "get_owned_mixnode"
        ],
        "properties": {
          "get_owned_mixnode": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "description": "Address of the mixnode owner to use for the query.",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the detailed mixnode information of a node with the provided id.",
        "type": "object",
        "required": [
          "get_mixnode_details"
        ],
        "properties": {
          "get_mixnode_details": {
            "type": "object",
            "required": [
              "mix_id"
            ],
            "properties": {
              "mix_id": {
                "description": "Id of the node to query.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the rewarding information of a mixnode with the provided id.",
        "type": "object",
        "required": [
          "get_mixnode_rewarding_details"
        ],
        "properties": {
          "get_mixnode_rewarding_details": {
            "type": "object",
            "required": [
              "mix_id"
            ],
            "properties": {
              "mix_id": {
                "description": "Id of the node to query.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the stake saturation of a mixnode with the provided id.",
        "type": "object",
        "required": [
          "get_stake_saturation"
        ],
        "properties": {
          "get_stake_saturation": {
            "type": "object",
            "required": [
              "mix_id"
            ],
            "properties": {
              "mix_id": {
                "description": "Id of the node to query.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the basic information of an unbonded mixnode with the provided id.",
        "type": "object",
        "required": [
          "get_unbonded_mix_node_information"
        ],
        "properties": {
          "get_unbonded_mix_node_information": {
            "type": "object",
            "required": [
              "mix_id"
            ],
            "properties": {
              "mix_id": {
                "description": "Id of the node to query.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the detailed mixnode information of a node given its current identity key.",
        "type": "object",
        "required": [
          "get_bonded_mixnode_details_by_identity"
        ],
        "properties": {
          "get_bonded_mixnode_details_by_identity": {
            "type": "object",
            "required": [
              "mix_identity"
            ],
            "properties": {
              "mix_identity": {
                "description": "The identity key (base58-encoded ed25519 public key) of the mixnode used for the query.",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the basic list of all currently bonded gateways.",
        "type": "object",
        "required": [
          "get_gateways"
        ],
        "properties": {
          "get_gateways": {
            "type": "object",
            "properties": {
              "limit": {
                "description": "Controls the maximum number of entries returned by the query. Note that too large values will be overwritten by a saner default.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "Pagination control for the values returned by the query. Note that the provided value itself will **not** be used for the response.",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the gateway details of a node given its identity key.",
        "type": "object",
        "required": [
          "get_gateway_bond"
        ],
        "properties": {
          "get_gateway_bond": {
            "type": "object",
            "required": [
              "identity"
            ],
            "properties": {
              "identity": {
                "description": "The identity key (base58-encoded ed25519 public key) of the gateway used for the query.",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the detailed gateway information belonging to the particular owner.",
        "type": "object",
        "required": [
          "get_owned_gateway"
        ],
        "properties": {
          "get_owned_gateway": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "description": "Address of the gateway owner to use for the query.",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Get the `NodeId`s of all the legacy gateways that they will get assigned once migrated into NymNodes",
        "type": "object",
        "required": [
          "get_preassigned_gateway_ids"
        ],
        "properties": {
          "get_preassigned_gateway_ids": {
            "type": "object",
            "properties": {
              "limit": {
                "description": "Controls the maximum number of entries returned by the query. Note that too large values will be overwritten by a saner default.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "Pagination control for the values returned by the query. Note that the provided value itself will **not** be used for the response.",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the basic list of all currently bonded nymnodes.",
        "type": "object",
        "required": [
          "get_nym_node_bonds_paged"
        ],
        "properties": {
          "get_nym_node_bonds_paged": {
            "type": "object",
            "properties": {
              "limit": {
                "description": "Controls the maximum number of entries returned by the query. Note that too large values will be overwritten by a saner default.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "Pagination control for the values returned by the query. Note that the provided value itself will **not** be used for the response.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the detailed list of all currently bonded nymnodes.",
        "type": "object",
        "required": [
          "get_nym_nodes_detailed_paged"
        ],
        "properties": {
          "get_nym_nodes_detailed_paged": {
            "type": "object",
            "properties": {
              "limit": {
                "description": "Controls the maximum number of entries returned by the query. Note that too large values will be overwritten by a saner default.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "Pagination control for the values returned by the query. Note that the provided value itself will **not** be used for the response.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the basic information of an unbonded nym-node with the provided id.",
        "type": "object",
        "required": [
          "get_unbonded_nym_node"
        ],
        "properties": {
          "get_unbonded_nym_node": {
            "type": "object",
            "required": [
              "node_id"
            ],
            "properties": {
              "node_id": {
                "description": "Id of the node to query.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the basic list of all unbonded nymnodes.",
        "type": "object",
        "required": [
          "get_unbonded_nym_nodes_paged"
        ],
        "properties": {
          "get_unbonded_nym_nodes_paged": {
            "type": "object",
            "properties": {
              "limit": {
                "description": "Controls the maximum number of entries returned by the query. Note that too large values will be overwritten by a saner default.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "Pagination control for the values returned by the query. Note that the provided value itself will **not** be used for the response.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the basic list of all unbonded nymnodes that belonged to a particular owner.",
        "type": "object",
        "required": [
          "get_unbonded_nym_nodes_by_owner_paged"
        ],
        "properties": {
          "get_unbonded_nym_nodes_by_owner_paged": {
            "type": "object",
            "required": [
              "owner"
            ],
            "properties": {
              "limit": {
                "description": "Controls the maximum number of entries returned by the query. Note that too large values will be overwritten by a saner default.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "owner": {
                "description": "The address of the owner of the nym-node used for the query",
                "type": "string"
              },
              "start_after": {
                "description": "Pagination control for the values returned by the query. Note that the provided value itself will **not** be used for the response.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the basic list of all unbonded nymnodes that used the particular identity key.",
        "type": "object",
        "required": [
          "get_unbonded_nym_nodes_by_identity_key_paged"
        ],
        "properties": {
          "get_unbonded_nym_nodes_by_identity_key_paged": {
            "type": "object",
            "required": [
              "identity_key"
            ],
            "properties": {
              "identity_key": {
                "description": "The identity key (base58-encoded ed25519 public key) of the node used for the query.",
                "type": "string"
              },
              "limit": {
                "description": "Controls the maximum number of entries returned by the query. Note that too large values will be overwritten by a saner default.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "Pagination control for the values returned by the query. Note that the provided value itself will **not** be used for the response.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the detailed nymnode information belonging to the particular owner.",
        "type": "object",
        "required": [
          "get_owned_nym_node"
        ],
        "properties": {
          "get_owned_nym_node": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "description": "Address of the node owner to use for the query.",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the detailed nymnode information of a node with the provided id.",
        "type": "object",
        "required": [
          "get_nym_node_details"
        ],
        "properties": {
          "get_nym_node_details": {
            "type": "object",
            "required": [
              "node_id"
            ],
            "properties": {
              "node_id": {
                "description": "Id of the node to query.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the detailed nym-node information given its current identity key.",
        "type": "object",
        "required": [
          "get_nym_node_details_by_identity_key"
        ],
        "properties": {
          "get_nym_node_details_by_identity_key": {
            "type": "object",
            "required": [
              "node_identity"
            ],
            "properties": {
              "node_identity": {
                "description": "The identity key (base58-encoded ed25519 public key) of the nym-node used for the query.",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the rewarding information of a nym-node with the provided id.",
        "type": "object",
        "required": [
          "get_node_rewarding_details"
        ],
        "properties": {
          "get_node_rewarding_details": {
            "type": "object",
            "required": [
              "node_id"
            ],
            "properties": {
              "node_id": {
                "description": "Id of the node to query.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the stake saturation of a nym-node with the provided id.",
        "type": "object",
        "required": [
          "get_node_stake_saturation"
        ],
        "properties": {
          "get_node_stake_saturation": {
            "type": "object",
            "required": [
              "node_id"
            ],
            "properties": {
              "node_id": {
                "description": "Id of the node to query.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_role_assignment"
        ],
        "properties": {
          "get_role_assignment": {
            "type": "object",
            "required": [
              "role"
            ],
            "properties": {
              "role": {
                "$ref": "#/definitions/Role"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_rewarded_set_metadata"
        ],
        "properties": {
          "get_rewarded_set_metadata": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets all delegations associated with particular node",
        "type": "object",
        "required": [
          "get_node_delegations"
        ],
        "properties": {
          "get_node_delegations": {
            "type": "object",
            "required": [
              "node_id"
            ],
            "properties": {
              "limit": {
                "description": "Controls the maximum number of entries returned by the query. Note that too large values will be overwritten by a saner default.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "node_id": {
                "description": "Id of the node to query.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "Pagination control for the values returned by the query. Note that the provided value itself will **not** be used for the response.",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets all delegations associated with particular delegator",
        "type": "object",
        "required": [
          "get_delegator_delegations"
        ],
        "properties": {
          "get_delegator_delegations": {
            "type": "object",
            "required": [
              "delegator"
            ],
            "properties": {
              "delegator": {
                "description": "The address of the owner of the delegations.",
                "type": "string"
              },
              "limit": {
                "description": "Controls the maximum number of entries returned by the query. Note that too large values will be overwritten by a saner default.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "Pagination control for the values returned by the query. Note that the provided value itself will **not** be used for the response.",
                "type": [
                  "array",
                  "null"
                ],
                "items": [
                  {
                    "type": "integer",
                    "format": "uint32",
                    "minimum": 0.0
                  },
                  {
                    "type": "string"
                  }
                ],
                "maxItems": 2,
                "minItems": 2
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets delegation information associated with particular mixnode - delegator pair",
        "type": "object",
        "required": [
          "get_delegation_details"
        ],
        "properties": {
          "get_delegation_details": {
            "type": "object",
            "required": [
              "delegator",
              "node_id"
            ],
            "properties": {
              "delegator": {
                "description": "The address of the owner of the delegation.",
                "type": "string"
              },
              "node_id": {
                "description": "Id of the node to query.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              "proxy": {
                "description": "Entity who made the delegation on behalf of the owner. If present, it's most likely the address of the vesting contract.",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets all delegations in the system",
        "type": "object",
        "required": [
          "get_all_delegations"
        ],
        "properties": {
          "get_all_delegations": {
            "type": "object",
            "properties": {
              "limit": {
                "description": "Controls the maximum number of entries returned by the query. Note that too large values will be overwritten by a saner default.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "Pagination control for the values returned by the query. Note that the provided value itself will **not** be used for the response.",
                "type": [
                  "array",
                  "null"
                ],
                "items": [
                  {
                    "type": "integer",
                    "format": "uint32",
                    "minimum": 0.0
                  },
                  {
                    "type": "string"
                  }
                ],
                "maxItems": 2,
                "minItems": 2
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the reward amount accrued by the node operator that has not yet been claimed.",
        "type": "object",
        "required": [
          "get_pending_operator_reward"
        ],
        "properties": {
          "get_pending_operator_reward": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "description": "Address of the operator to use for the query.",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the reward amount accrued by the particular mixnode that has not yet been claimed.",
        "type": "object",
        "required": [
          "get_pending_node_operator_reward"
        ],
        "properties": {
          "get_pending_node_operator_reward": {
            "type": "object",
            "required": [
              "node_id"
            ],
            "properties": {
              "node_id": {
                "description": "Id of the node to query.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the reward amount accrued by the particular delegator that has not yet been claimed.",
        "type": "object",
        "required": [
          "get_pending_delegator_reward"
        ],
        "properties": {
          "get_pending_delegator_reward": {
            "type": "object",
            "required": [
              "address",
              "node_id"
            ],
            "properties": {
              "address": {
                "description": "Address of the delegator to use for the query.",
                "type": "string"
              },
              "node_id": {
                "description": "Id of the node to query.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              "proxy": {
                "description": "Entity who made the delegation on behalf of the owner. If present, it's most likely the address of the vesting contract.",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Given the provided node performance, attempt to estimate the operator reward for the current epoch.",
        "type": "object",
        "required": [
          "get_estimated_current_epoch_operator_reward"
        ],
        "properties": {
          "get_estimated_current_epoch_operator_reward": {
            "type": "object",
            "required": [
              "estimated_performance",
              "node_id"
            ],
            "properties": {
              "estimated_performance": {
                "description": "The estimated performance for the current epoch of the given node.",
                "allOf": [
                  {
                    "$ref": "#/definitions/Percent"
                  }
                ]
              },
              "estimated_work": {
                "description": "The estimated work for the current epoch of the given node.",
                "anyOf": [
                  {
                    "$ref": "#/definitions/Decimal"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "node_id": {
                "description": "Id of the node to query.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Given the provided node performance, attempt to estimate the delegator reward for the current epoch.",
        "type": "object",
        "required": [
          "get_estimated_current_epoch_delegator_reward"
        ],
        "properties": {
          "get_estimated_current_epoch_delegator_reward": {
            "type": "object",
            "required": [
              "address",
              "estimated_performance",
              "node_id"
            ],
            "properties": {
              "address": {
                "description": "Address of the delegator to use for the query.",
                "type": "string"
              },
              "estimated_performance": {
                "description": "The estimated performance for the current epoch of the given node.",
                "allOf": [
                  {
                    "$ref": "#/definitions/Percent"
                  }
                ]
              },
              "estimated_work": {
                "description": "The estimated work for the current epoch of the given node.",
                "anyOf": [
                  {
                    "$ref": "#/definitions/Decimal"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "node_id": {
                "description": "Id of the node to query.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the list of all currently pending epoch events that will be resolved once the current epoch finishes.",
        "type": "object",
        "required": [
          "get_pending_epoch_events"
        ],
        "properties": {
          "get_pending_epoch_events": {
            "type": "object",
            "properties": {
              "limit": {
                "description": "Controls the maximum number of entries returned by the query. Note that too large values will be overwritten by a saner default.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "Pagination control for the values returned by the query. Note that the provided value itself will **not** be used for the response.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the list of all currently pending interval events that will be resolved once the current interval finishes.",
        "type": "object",
        "required": [
          "get_pending_interval_events"
        ],
        "properties": {
          "get_pending_interval_events": {
            "type": "object",
            "properties": {
              "limit": {
                "description": "Controls the maximum number of entries returned by the query. Note that too large values will be overwritten by a saner default.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "Pagination control for the values returned by the query. Note that the provided value itself will **not** be used for the response.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets detailed information about a pending epoch event given its id.",
        "type": "object",
        "required": [
          "get_pending_epoch_event"
        ],
        "properties": {
          "get_pending_epoch_event": {
            "type": "object",
            "required": [
              "event_id"
            ],
            "properties": {
              "event_id": {
                "description": "The unique id associated with the event.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets detailed information about a pending interval event given its id.",
        "type": "object",
        "required": [
          "get_pending_interval_event"
        ],
        "properties": {
          "get_pending_interval_event": {
            "type": "object",
            "required": [
              "event_id"
            ],
            "properties": {
              "event_id": {
                "description": "The unique id associated with the event.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the information about the number of currently pending epoch and interval events.",
        "type": "object",
        "required": [
          "get_number_of_pending_events"
        ],
        "properties": {
          "get_number_of_pending_events": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the signing nonce associated with the particular cosmos address.",
        "type": "object",
        "required": [
          "get_signing_nonce"
        ],
        "properties": {
          "get_signing_nonce": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "description": "Cosmos address used for the query of the signing nonce.",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "Percent": {
        "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
        "allOf": [
          {
            "$ref": "#/definitions/Decimal"
          }
        ]
      },
      "Role": {
        "type": "string",
        "enum": [
          "eg",
          "l1",
          "l2",
          "l3",
          "xg",
          "stb"
        ]
      }
    }
  },
  "migrate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "MigrateMsg",
    "type": "object",
    "properties": {
      "vesting_contract_address": {
        "type": [
          "string",
          "null"
        ]
      }
    },
    "additionalProperties": false
  },
  "sudo": null,
  "responses": {
    "admin": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AdminResponse",
      "description": "Returned from Admin.query_admin()",
      "type": "object",
      "properties": {
        "admin": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "get_all_delegations": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedAllDelegationsResponse",
      "description": "Response containing paged list of all delegations currently active.",
      "type": "object",
      "required": [
        "delegations"
      ],
      "properties": {
        "delegations": {
          "description": "Each individual delegation made.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Delegation"
          }
        },
        "start_next_after": {
          "description": "Field indicating paging information for the following queries if the caller wishes to get further entries.",
          "type": [
            "array",
            "null"
          ],
          "items": [
            {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            {
              "type": "string"
            }
          ],
          "maxItems": 2,
          "minItems": 2
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Delegation": {
          "description": "Information about tokens being delegated towards given mixnode in order to accrue rewards with their work.",
          "type": "object",
          "required": [
            "amount",
            "cumulative_reward_ratio",
            "height",
            "node_id",
            "owner"
          ],
          "properties": {
            "amount": {
              "description": "Original delegation amount. Note that it is never mutated as delegation accumulates rewards.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "cumulative_reward_ratio": {
              "description": "Value of the \"unit delegation\" associated with the mixnode at the time of delegation.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "height": {
              "description": "Block height where this delegation occurred.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "node_id": {
              "description": "Id of the Node that this delegation was performed against.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "owner": {
              "description": "Address of the owner of this delegation.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Proxy address used to delegate the funds on behalf of another address",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_bonded_mixnode_details_by_identity": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "MixnodeDetailsByIdentityResponse",
      "description": "Response containing details of a bonded mixnode with the provided identity key.",
      "type": "object",
      "required": [
        "identity_key"
      ],
      "properties": {
        "identity_key": {
          "description": "The identity key (base58-encoded ed25519 public key) of the mixnode.",
          "type": "string"
        },
        "mixnode_details": {
          "description": "If there exists a bonded mixnode with the provided identity key, this field contains its detailed information.",
          "anyOf": [
            {
              "$ref": "#/definitions/MixNodeDetails"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "MixNode": {
          "description": "Information provided by the node operator during bonding that are used to allow other entities to use the services of this node.",
          "type": "object",
          "required": [
            "host",
            "http_api_port",
            "identity_key",
            "mix_port",
            "sphinx_key",
            "verloc_port",
            "version"
          ],
          "properties": {
            "host": {
              "description": "Network address of this mixnode, for example 1.1.1.1 or foo.mixnode.com",
              "type": "string"
            },
            "http_api_port": {
              "description": "Port used by this mixnode for its http(s) API",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            },
            "mix_port": {
              "description": "Port used by this mixnode for listening for mix packets.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "sphinx_key": {
              "description": "Base58-encoded x25519 public key used for sphinx key derivation.",
              "type": "string"
            },
            "verloc_port": {
              "description": "Port used by this mixnode for listening for verloc requests.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "version": {
              "description": "The self-reported semver version of this mixnode.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "MixNodeBond": {
          "description": "Basic mixnode information provided by the node operator.",
          "type": "object",
          "required": [
            "bonding_height",
            "is_unbonding",
            "mix_id",
            "mix_node",
            "original_pledge",
            "owner"
          ],
          "properties": {
            "bonding_height": {
              "description": "Block height at which this mixnode has been bonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "is_unbonding": {
              "description": "Flag to indicate whether this node is in the process of unbonding, that will conclude upon the epoch finishing.",
              "type": "boolean"
            },
            "mix_id": {
              "description": "Unique id assigned to the bonded mixnode.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "mix_node": {
              "description": "Information provided by the operator for the purposes of bonding.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNode"
                }
              ]
            },
            "original_pledge": {
              "description": "Original amount pledged by the operator of this node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "owner": {
              "description": "Address of the owner of this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Entity who bonded this mixnode on behalf of the owner. If exists, it's most likely the address of the vesting contract.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          }
        },
        "MixNodeDetails": {
          "description": "Full details associated with given mixnode.",
          "type": "object",
          "required": [
            "bond_information",
            "rewarding_details"
          ],
          "properties": {
            "bond_information": {
              "description": "Basic bond information of this mixnode, such as owner address, original pledge, etc.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNodeBond"
                }
              ]
            },
            "pending_changes": {
              "description": "Adjustments to the mixnode that are ought to happen during future epoch transitions.",
              "default": {
                "cost_params_change": null,
                "pledge_change": null
              },
              "allOf": [
                {
                  "$ref": "#/definitions/PendingMixNodeChanges"
                }
              ]
            },
            "rewarding_details": {
              "description": "Details used for computation of rewarding related data.",
              "allOf": [
                {
                  "$ref": "#/definitions/NodeRewarding"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "NodeCostParams": {
          "description": "The cost parameters, or the cost function, defined for the particular mixnode that influences how the rewards should be split between the node operator and its delegators.",
          "type": "object",
          "required": [
            "interval_operating_cost",
            "profit_margin_percent"
          ],
          "properties": {
            "interval_operating_cost": {
              "description": "Operating cost of the associated node per the entire interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "profit_margin_percent": {
              "description": "The profit margin of the associated node, i.e. the desired percent of the reward to be distributed to the operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Percent"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "NodeRewarding": {
          "type": "object",
          "required": [
            "cost_params",
            "delegates",
            "last_rewarded_epoch",
            "operator",
            "total_unit_reward",
            "unique_delegations",
            "unit_delegation"
          ],
          "properties": {
            "cost_params": {
              "description": "Information provided by the operator that influence the cost function.",
              "allOf": [
                {
                  "$ref": "#/definitions/NodeCostParams"
                }
              ]
            },
            "delegates": {
              "description": "Total delegation and compounded reward earned by all node delegators.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "last_rewarded_epoch": {
              "description": "Marks the epoch when this node was last rewarded so that we wouldn't accidentally attempt to reward it multiple times in the same epoch.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "operator": {
              "description": "Total pledge and compounded reward earned by the node operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "total_unit_reward": {
              "description": "Cumulative reward earned by the \"unit delegation\" since the block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "unique_delegations": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "unit_delegation": {
              "description": "Value of the theoretical \"unit delegation\" that has delegated to this node at block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PendingMixNodeChanges": {
          "type": "object",
          "properties": {
            "cost_params_change": {
              "default": null,
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            },
            "pledge_change": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Percent": {
          "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_c_w2_contract_version": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ContractVersion",
      "type": "object",
      "required": [
        "contract",
        "version"
      ],
      "properties": {
        "contract": {
          "description": "contract is the crate name of the implementing contract, eg. `crate:cw20-base` we will use other prefixes for other languages, and their standard global namespacing",
          "type": "string"
        },
        "version": {
          "description": "version is any string that this implementation knows. It may be simple counter \"1\", \"2\". or semantic version on release tags \"v0.7.0\", or some custom feature flag list. the only code that needs to understand the version parsing is code that knows how to migrate from the given contract (and is tied to it's implementation somehow)",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "get_contract_version": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ContractBuildInformation",
      "type": "object",
      "required": [
        "build_timestamp",
        "build_version",
        "commit_branch",
        "commit_sha",
        "commit_timestamp",
        "rustc_version"
      ],
      "properties": {
        "build_timestamp": {
          "description": "Provides the build timestamp, for example `2021-02-23T20:14:46.558472672+00:00`.",
          "type": "string"
        },
        "build_version": {
          "description": "Provides the build version, for example `0.1.0-9-g46f83e1`.",
          "type": "string"
        },
        "cargo_debug": {
          "description": "Provides the cargo debug mode that was used for the build.",
          "default": "unknown",
          "type": "string"
        },
        "cargo_opt_level": {
          "description": "Provides the opt value set by cargo during the build",
          "default": "unknown",
          "type": "string"
        },
        "commit_branch": {
          "description": "Provides the name of the git branch that was used for the build, for example `master`.",
          "type": "string"
        },
        "commit_sha": {
          "description": "Provides the hash of the commit that was used for the build, for example `46f83e112520533338245862d366f6a02cef07d4`.",
          "type": "string"
        },
        "commit_timestamp": {
          "description": "Provides the timestamp of the commit that was used for the build, for example `2021-02-23T08:08:02-05:00`.",
          "type": "string"
        },
        "contract_name": {
          "description": "Provides the name of the binary, i.e. the content of `CARGO_PKG_NAME` environmental variable.",
          "default": "unknown",
          "type": "string"
        },
        "rustc_version": {
          "description": "Provides the rustc version that was used for the build, for example `1.52.0-nightly`.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "get_current_interval_details": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "CurrentIntervalResponse",
      "description": "Information about the current rewarding interval.",
      "type": "object",
      "required": [
        "current_blocktime",
        "interval",
        "is_current_epoch_over",
        "is_current_interval_over"
      ],
      "properties": {
        "current_blocktime": {
          "description": "The current blocktime",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "interval": {
          "description": "Detailed information about the underlying interval.",
          "allOf": [
            {
              "$ref": "#/definitions/Interval"
            }
          ]
        },
        "is_current_epoch_over": {
          "description": "Flag indicating whether the current epoch is over and it should be advanced.",
          "type": "boolean"
        },
        "is_current_interval_over": {
          "description": "Flag indicating whether the current interval is over and it should be advanced.",
          "type": "boolean"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Duration": {
          "type": "object",
          "required": [
            "nanos",
            "secs"
          ],
          "properties": {
            "nanos": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "secs": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          }
        },
        "Interval": {
          "type": "object",
          "required": [
            "current_epoch_id",
            "current_epoch_start",
            "epoch_length",
            "epochs_in_interval",
            "id",
            "total_elapsed_epochs"
          ],
          "properties": {
            "current_epoch_id": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "current_epoch_start": {
              "type": "string"
            },
            "epoch_length": {
              "$ref": "#/definitions/Duration"
            },
            "epochs_in_interval": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "id": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "total_elapsed_epochs": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          }
        }
      }
    },
    "get_delegation_details": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "NodeDelegationResponse",
      "description": "Response containing delegation details.",
      "type": "object",
      "required": [
        "mixnode_still_bonded",
        "node_still_bonded"
      ],
      "properties": {
        "delegation": {
          "description": "If the delegation exists, this field contains its detailed information.",
          "anyOf": [
            {
              "$ref": "#/definitions/Delegation"
            },
            {
              "type": "null"
            }
          ]
        },
        "mixnode_still_bonded": {
          "description": "Flag indicating whether the node towards which the delegation was made is still bonded in the network.",
          "deprecated": true,
          "type": "boolean"
        },
        "node_still_bonded": {
          "type": "boolean"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Delegation": {
          "description": "Information about tokens being delegated towards given mixnode in order to accrue rewards with their work.",
          "type": "object",
          "required": [
            "amount",
            "cumulative_reward_ratio",
            "height",
            "node_id",
            "owner"
          ],
          "properties": {
            "amount": {
              "description": "Original delegation amount. Note that it is never mutated as delegation accumulates rewards.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "cumulative_reward_ratio": {
              "description": "Value of the \"unit delegation\" associated with the mixnode at the time of delegation.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "height": {
              "description": "Block height where this delegation occurred.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "node_id": {
              "description": "Id of the Node that this delegation was performed against.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "owner": {
              "description": "Address of the owner of this delegation.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Proxy address used to delegate the funds on behalf of another address",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_delegator_delegations": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedDelegatorDelegationsResponse",
      "description": "Response containing paged list of all delegations made by the particular address.",
      "type": "object",
      "required": [
        "delegations"
      ],
      "properties": {
        "delegations": {
          "description": "Each individual delegation made.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Delegation"
          }
        },
        "start_next_after": {
          "description": "Field indicating paging information for the following queries if the caller wishes to get further entries.",
          "type": [
            "array",
            "null"
          ],
          "items": [
            {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            {
              "type": "string"
            }
          ],
          "maxItems": 2,
          "minItems": 2
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Delegation": {
          "description": "Information about tokens being delegated towards given mixnode in order to accrue rewards with their work.",
          "type": "object",
          "required": [
            "amount",
            "cumulative_reward_ratio",
            "height",
            "node_id",
            "owner"
          ],
          "properties": {
            "amount": {
              "description": "Original delegation amount. Note that it is never mutated as delegation accumulates rewards.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "cumulative_reward_ratio": {
              "description": "Value of the \"unit delegation\" associated with the mixnode at the time of delegation.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "height": {
              "description": "Block height where this delegation occurred.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "node_id": {
              "description": "Id of the Node that this delegation was performed against.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "owner": {
              "description": "Address of the owner of this delegation.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Proxy address used to delegate the funds on behalf of another address",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_epoch_status": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "EpochStatus",
      "description": "The status of the current rewarding epoch.",
      "type": "object",
      "required": [
        "being_advanced_by",
        "state"
      ],
      "properties": {
        "being_advanced_by": {
          "description": "Specifies either, which validator is currently performing progression into the following epoch (if the epoch is currently being progressed), or which validator was responsible for progressing into the current epoch (if the epoch is currently in progress)",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "state": {
          "description": "The concrete state of the epoch.",
          "allOf": [
            {
              "$ref": "#/definitions/EpochState"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "EpochState": {
          "description": "The state of the current rewarding epoch.",
          "oneOf": [
            {
              "description": "Represents the state of an epoch that's in progress (well, duh.) All actions are allowed to be issued.",
              "type": "string",
              "enum": [
                "in_progress"
              ]
            },
            {
              "description": "Represents the state of an epoch when the rewarding entity has been decided on, and the mixnodes are in the process of being rewarded for their work in this epoch.",
              "type": "object",
              "required": [
                "rewarding"
              ],
              "properties": {
                "rewarding": {
                  "type": "object",
                  "required": [
                    "final_node_id",
                    "last_rewarded"
                  ],
                  "properties": {
                    "final_node_id": {
                      "description": "The id of the last node that's going to be rewarded before progressing into the next state.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    },
                    "last_rewarded": {
                      "description": "The id of the last node that has already received its rewards.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Represents the state of an epoch when all mixnodes have already been rewarded for their work in this epoch and all issued actions should now get resolved before being allowed to advance into the next epoch.",
              "type": "string",
              "enum": [
                "reconciling_events"
              ]
            },
            {
              "description": "Represents the state of an epoch when all nodes have already been rewarded for their work in this epoch, all issued actions got resolved and node roles should now be assigned before advancing into the next epoch.",
              "type": "object",
              "required": [
                "role_assignment"
              ],
              "properties": {
                "role_assignment": {
                  "type": "object",
                  "required": [
                    "next"
                  ],
                  "properties": {
                    "next": {
                      "$ref": "#/definitions/Role"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Role": {
          "type": "string",
          "enum": [
            "eg",
            "l1",
            "l2",
            "l3",
            "xg",
            "stb"
          ]
        }
      }
    },
    "get_estimated_current_epoch_delegator_reward": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "EstimatedCurrentEpochRewardResponse",
      "description": "Response containing estimation of node rewards for the current epoch.",
      "type": "object",
      "properties": {
        "current_stake_value": {
          "description": "The current stake value given all past rewarding and compounding since the original staking was performed.",
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "current_stake_value_detailed_amount": {
          "description": "The current stake value. Note that it's nearly identical to `current_stake_value`, however, it contains few additional decimal points for more accurate reward calculation.",
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "detailed_estimation_amount": {
          "description": "The full reward estimation. Note that it's nearly identical to `estimation`, however, it contains few additional decimal points for more accurate reward calculation.",
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "estimation": {
          "description": "The reward estimation for the current epoch, i.e. the amount of tokens that could be claimable after the epoch finishes and the state of the network does not change.",
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "original_stake": {
          "description": "The amount of tokens initially staked.",
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_estimated_current_epoch_operator_reward": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "EstimatedCurrentEpochRewardResponse",
      "description": "Response containing estimation of node rewards for the current epoch.",
      "type": "object",
      "properties": {
        "current_stake_value": {
          "description": "The current stake value given all past rewarding and compounding since the original staking was performed.",
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "current_stake_value_detailed_amount": {
          "description": "The current stake value. Note that it's nearly identical to `current_stake_value`, however, it contains few additional decimal points for more accurate reward calculation.",
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "detailed_estimation_amount": {
          "description": "The full reward estimation. Note that it's nearly identical to `estimation`, however, it contains few additional decimal points for more accurate reward calculation.",
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "estimation": {
          "description": "The reward estimation for the current epoch, i.e. the amount of tokens that could be claimable after the epoch finishes and the state of the network does not change.",
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "original_stake": {
          "description": "The amount of tokens initially staked.",
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_gateway_bond": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "GatewayBondResponse",
      "description": "Response containing details of a gateway with the provided identity key.",
      "type": "object",
      "required": [
        "identity"
      ],
      "properties": {
        "gateway": {
          "description": "If there exists a gateway with the provided identity key, this field contains its details.",
          "anyOf": [
            {
              "$ref": "#/definitions/GatewayBond"
            },
            {
              "type": "null"
            }
          ]
        },
        "identity": {
          "description": "The identity key (base58-encoded ed25519 public key) of the gateway.",
          "type": "string"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Gateway": {
          "description": "Information provided by the node operator during bonding that are used to allow other entities to use the services of this node.",
          "type": "object",
          "required": [
            "clients_port",
            "host",
            "identity_key",
            "location",
            "mix_port",
            "sphinx_key",
            "version"
          ],
          "properties": {
            "clients_port": {
              "description": "Port used by this gateway for listening for client requests.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "host": {
              "description": "Network address of this gateway, for example 1.1.1.1 or foo.gateway.com",
              "type": "string"
            },
            "identity_key": {
              "description": "Base58 encoded ed25519 EdDSA public key of the gateway used to derive shared keys with clients",
              "type": "string"
            },
            "location": {
              "description": "The physical, self-reported, location of this gateway.",
              "type": "string"
            },
            "mix_port": {
              "description": "Port used by this gateway for listening for mix packets.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "sphinx_key": {
              "description": "Base58-encoded x25519 public key used for sphinx key derivation.",
              "type": "string"
            },
            "version": {
              "description": "The self-reported semver version of this gateway.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "GatewayBond": {
          "description": "Basic gateway information provided by the node operator.",
          "type": "object",
          "required": [
            "block_height",
            "gateway",
            "owner",
            "pledge_amount"
          ],
          "properties": {
            "block_height": {
              "description": "Block height at which this gateway has been bonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "gateway": {
              "description": "Information provided by the operator for the purposes of bonding.",
              "allOf": [
                {
                  "$ref": "#/definitions/Gateway"
                }
              ]
            },
            "owner": {
              "description": "Address of the owner of this gateway.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "pledge_amount": {
              "description": "Original amount pledged by the operator of this node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "proxy": {
              "description": "Entity who bonded this gateway on behalf of the owner. If exists, it's most likely the address of the vesting contract.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_gateways": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedGatewayResponse",
      "description": "Response containing paged list of all gateway bonds in the contract.",
      "type": "object",
      "required": [
        "nodes",
        "per_page"
      ],
      "properties": {
        "nodes": {
          "description": "The gateway bond information present in the contract.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/GatewayBond"
          }
        },
        "per_page": {
          "description": "Maximum number of entries that could be included in a response. `per_page <= nodes.len()`",
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        },
        "start_next_after": {
          "description": "Field indicating paging information for the following queries if the caller wishes to get further entries.",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Gateway": {
          "description": "Information provided by the node operator during bonding that are used to allow other entities to use the services of this node.",
          "type": "object",
          "required": [
            "clients_port",
            "host",
            "identity_key",
            "location",
            "mix_port",
            "sphinx_key",
            "version"
          ],
          "properties": {
            "clients_port": {
              "description": "Port used by this gateway for listening for client requests.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "host": {
              "description": "Network address of this gateway, for example 1.1.1.1 or foo.gateway.com",
              "type": "string"
            },
            "identity_key": {
              "description": "Base58 encoded ed25519 EdDSA public key of the gateway used to derive shared keys with clients",
              "type": "string"
            },
            "location": {
              "description": "The physical, self-reported, location of this gateway.",
              "type": "string"
            },
            "mix_port": {
              "description": "Port used by this gateway for listening for mix packets.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "sphinx_key": {
              "description": "Base58-encoded x25519 public key used for sphinx key derivation.",
              "type": "string"
            },
            "version": {
              "description": "The self-reported semver version of this gateway.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "GatewayBond": {
          "description": "Basic gateway information provided by the node operator.",
          "type": "object",
          "required": [
            "block_height",
            "gateway",
            "owner",
            "pledge_amount"
          ],
          "properties": {
            "block_height": {
              "description": "Block height at which this gateway has been bonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "gateway": {
              "description": "Information provided by the operator for the purposes of bonding.",
              "allOf": [
                {
                  "$ref": "#/definitions/Gateway"
                }
              ]
            },
            "owner": {
              "description": "Address of the owner of this gateway.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "pledge_amount": {
              "description": "Original amount pledged by the operator of this node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "proxy": {
              "description": "Entity who bonded this gateway on behalf of the owner. If exists, it's most likely the address of the vesting contract.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_mix_node_bonds": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedMixnodeBondsResponse",
      "description": "Response containing paged list of all mixnode bonds in the contract.",
      "type": "object",
      "required": [
        "nodes",
        "per_page"
      ],
      "properties": {
        "nodes": {
          "description": "The mixnode bond information present in the contract.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/MixNodeBond"
          }
        },
        "per_page": {
          "description": "Maximum number of entries that could be included in a response. `per_page <= nodes.len()`",
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        },
        "start_next_after": {
          "description": "Field indicating paging information for the following queries if the caller wishes to get further entries.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "MixNode": {
          "description": "Information provided by the node operator during bonding that are used to allow other entities to use the services of this node.",
          "type": "object",
          "required": [
            "host",
            "http_api_port",
            "identity_key",
            "mix_port",
            "sphinx_key",
            "verloc_port",
            "version"
          ],
          "properties": {
            "host": {
              "description": "Network address of this mixnode, for example 1.1.1.1 or foo.mixnode.com",
              "type": "string"
            },
            "http_api_port": {
              "description": "Port used by this mixnode for its http(s) API",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            },
            "mix_port": {
              "description": "Port used by this mixnode for listening for mix packets.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "sphinx_key": {
              "description": "Base58-encoded x25519 public key used for sphinx key derivation.",
              "type": "string"
            },
            "verloc_port": {
              "description": "Port used by this mixnode for listening for verloc requests.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "version": {
              "description": "The self-reported semver version of this mixnode.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "MixNodeBond": {
          "description": "Basic mixnode information provided by the node operator.",
          "type": "object",
          "required": [
            "bonding_height",
            "is_unbonding",
            "mix_id",
            "mix_node",
            "original_pledge",
            "owner"
          ],
          "properties": {
            "bonding_height": {
              "description": "Block height at which this mixnode has been bonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "is_unbonding": {
              "description": "Flag to indicate whether this node is in the process of unbonding, that will conclude upon the epoch finishing.",
              "type": "boolean"
            },
            "mix_id": {
              "description": "Unique id assigned to the bonded mixnode.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "mix_node": {
              "description": "Information provided by the operator for the purposes of bonding.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNode"
                }
              ]
            },
            "original_pledge": {
              "description": "Original amount pledged by the operator of this node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "owner": {
              "description": "Address of the owner of this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Entity who bonded this mixnode on behalf of the owner. If exists, it's most likely the address of the vesting contract.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          }
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_mix_nodes_detailed": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedMixnodesDetailsResponse",
      "description": "Response containing paged list of all mixnode details in the contract.",
      "type": "object",
      "required": [
        "nodes",
        "per_page"
      ],
      "properties": {
        "nodes": {
          "description": "All mixnode details stored in the contract. Apart from the basic bond information it also contains details required for all future reward calculation as well as any pending changes requested by the operator.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/MixNodeDetails"
          }
        },
        "per_page": {
          "description": "Maximum number of entries that could be included in a response. `per_page <= nodes.len()`",
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        },
        "start_next_after": {
          "description": "Field indicating paging information for the following queries if the caller wishes to get further entries.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "MixNode": {
          "description": "Information provided by the node operator during bonding that are used to allow other entities to use the services of this node.",
          "type": "object",
          "required": [
            "host",
            "http_api_port",
            "identity_key",
            "mix_port",
            "sphinx_key",
            "verloc_port",
            "version"
          ],
          "properties": {
            "host": {
              "description": "Network address of this mixnode, for example 1.1.1.1 or foo.mixnode.com",
              "type": "string"
            },
            "http_api_port": {
              "description": "Port used by this mixnode for its http(s) API",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            },
            "mix_port": {
              "description": "Port used by this mixnode for listening for mix packets.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "sphinx_key": {
              "description": "Base58-encoded x25519 public key used for sphinx key derivation.",
              "type": "string"
            },
            "verloc_port": {
              "description": "Port used by this mixnode for listening for verloc requests.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "version": {
              "description": "The self-reported semver version of this mixnode.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "MixNodeBond": {
          "description": "Basic mixnode information provided by the node operator.",
          "type": "object",
          "required": [
            "bonding_height",
            "is_unbonding",
            "mix_id",
            "mix_node",
            "original_pledge",
            "owner"
          ],
          "properties": {
            "bonding_height": {
              "description": "Block height at which this mixnode has been bonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "is_unbonding": {
              "description": "Flag to indicate whether this node is in the process of unbonding, that will conclude upon the epoch finishing.",
              "type": "boolean"
            },
            "mix_id": {
              "description": "Unique id assigned to the bonded mixnode.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "mix_node": {
              "description": "Information provided by the operator for the purposes of bonding.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNode"
                }
              ]
            },
            "original_pledge": {
              "description": "Original amount pledged by the operator of this node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "owner": {
              "description": "Address of the owner of this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Entity who bonded this mixnode on behalf of the owner. If exists, it's most likely the address of the vesting contract.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          }
        },
        "MixNodeDetails": {
          "description": "Full details associated with given mixnode.",
          "type": "object",
          "required": [
            "bond_information",
            "rewarding_details"
          ],
          "properties": {
            "bond_information": {
              "description": "Basic bond information of this mixnode, such as owner address, original pledge, etc.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNodeBond"
                }
              ]
            },
            "pending_changes": {
              "description": "Adjustments to the mixnode that are ought to happen during future epoch transitions.",
              "default": {
                "cost_params_change": null,
                "pledge_change": null
              },
              "allOf": [
                {
                  "$ref": "#/definitions/PendingMixNodeChanges"
                }
              ]
            },
            "rewarding_details": {
              "description": "Details used for computation of rewarding related data.",
              "allOf": [
                {
                  "$ref": "#/definitions/NodeRewarding"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "NodeCostParams": {
          "description": "The cost parameters, or the cost function, defined for the particular mixnode that influences how the rewards should be split between the node operator and its delegators.",
          "type": "object",
          "required": [
            "interval_operating_cost",
            "profit_margin_percent"
          ],
          "properties": {
            "interval_operating_cost": {
              "description": "Operating cost of the associated node per the entire interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "profit_margin_percent": {
              "description": "The profit margin of the associated node, i.e. the desired percent of the reward to be distributed to the operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Percent"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "NodeRewarding": {
          "type": "object",
          "required": [
            "cost_params",
            "delegates",
            "last_rewarded_epoch",
            "operator",
            "total_unit_reward",
            "unique_delegations",
            "unit_delegation"
          ],
          "properties": {
            "cost_params": {
              "description": "Information provided by the operator that influence the cost function.",
              "allOf": [
                {
                  "$ref": "#/definitions/NodeCostParams"
                }
              ]
            },
            "delegates": {
              "description": "Total delegation and compounded reward earned by all node delegators.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "last_rewarded_epoch": {
              "description": "Marks the epoch when this node was last rewarded so that we wouldn't accidentally attempt to reward it multiple times in the same epoch.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "operator": {
              "description": "Total pledge and compounded reward earned by the node operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "total_unit_reward": {
              "description": "Cumulative reward earned by the \"unit delegation\" since the block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "unique_delegations": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "unit_delegation": {
              "description": "Value of the theoretical \"unit delegation\" that has delegated to this node at block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PendingMixNodeChanges": {
          "type": "object",
          "properties": {
            "cost_params_change": {
              "default": null,
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            },
            "pledge_change": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Percent": {
          "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_mixnode_details": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "MixnodeDetailsResponse",
      "description": "Response containing details of a mixnode with the provided id.",
      "type": "object",
      "required": [
        "mix_id"
      ],
      "properties": {
        "mix_id": {
          "description": "Id of the requested mixnode.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "mixnode_details": {
          "description": "If there exists a mixnode with the provided id, this field contains its detailed information.",
          "anyOf": [
            {
              "$ref": "#/definitions/MixNodeDetails"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "MixNode": {
          "description": "Information provided by the node operator during bonding that are used to allow other entities to use the services of this node.",
          "type": "object",
          "required": [
            "host",
            "http_api_port",
            "identity_key",
            "mix_port",
            "sphinx_key",
            "verloc_port",
            "version"
          ],
          "properties": {
            "host": {
              "description": "Network address of this mixnode, for example 1.1.1.1 or foo.mixnode.com",
              "type": "string"
            },
            "http_api_port": {
              "description": "Port used by this mixnode for its http(s) API",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            },
            "mix_port": {
              "description": "Port used by this mixnode for listening for mix packets.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "sphinx_key": {
              "description": "Base58-encoded x25519 public key used for sphinx key derivation.",
              "type": "string"
            },
            "verloc_port": {
              "description": "Port used by this mixnode for listening for verloc requests.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "version": {
              "description": "The self-reported semver version of this mixnode.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "MixNodeBond": {
          "description": "Basic mixnode information provided by the node operator.",
          "type": "object",
          "required": [
            "bonding_height",
            "is_unbonding",
            "mix_id",
            "mix_node",
            "original_pledge",
            "owner"
          ],
          "properties": {
            "bonding_height": {
              "description": "Block height at which this mixnode has been bonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "is_unbonding": {
              "description": "Flag to indicate whether this node is in the process of unbonding, that will conclude upon the epoch finishing.",
              "type": "boolean"
            },
            "mix_id": {
              "description": "Unique id assigned to the bonded mixnode.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "mix_node": {
              "description": "Information provided by the operator for the purposes of bonding.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNode"
                }
              ]
            },
            "original_pledge": {
              "description": "Original amount pledged by the operator of this node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "owner": {
              "description": "Address of the owner of this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Entity who bonded this mixnode on behalf of the owner. If exists, it's most likely the address of the vesting contract.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          }
        },
        "MixNodeDetails": {
          "description": "Full details associated with given mixnode.",
          "type": "object",
          "required": [
            "bond_information",
            "rewarding_details"
          ],
          "properties": {
            "bond_information": {
              "description": "Basic bond information of this mixnode, such as owner address, original pledge, etc.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNodeBond"
                }
              ]
            },
            "pending_changes": {
              "description": "Adjustments to the mixnode that are ought to happen during future epoch transitions.",
              "default": {
                "cost_params_change": null,
                "pledge_change": null
              },
              "allOf": [
                {
                  "$ref": "#/definitions/PendingMixNodeChanges"
                }
              ]
            },
            "rewarding_details": {
              "description": "Details used for computation of rewarding related data.",
              "allOf": [
                {
                  "$ref": "#/definitions/NodeRewarding"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "NodeCostParams": {
          "description": "The cost parameters, or the cost function, defined for the particular mixnode that influences how the rewards should be split between the node operator and its delegators.",
          "type": "object",
          "required": [
            "interval_operating_cost",
            "profit_margin_percent"
          ],
          "properties": {
            "interval_operating_cost": {
              "description": "Operating cost of the associated node per the entire interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "profit_margin_percent": {
              "description": "The profit margin of the associated node, i.e. the desired percent of the reward to be distributed to the operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Percent"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "NodeRewarding": {
          "type": "object",
          "required": [
            "cost_params",
            "delegates",
            "last_rewarded_epoch",
            "operator",
            "total_unit_reward",
            "unique_delegations",
            "unit_delegation"
          ],
          "properties": {
            "cost_params": {
              "description": "Information provided by the operator that influence the cost function.",
              "allOf": [
                {
                  "$ref": "#/definitions/NodeCostParams"
                }
              ]
            },
            "delegates": {
              "description": "Total delegation and compounded reward earned by all node delegators.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "last_rewarded_epoch": {
              "description": "Marks the epoch when this node was last rewarded so that we wouldn't accidentally attempt to reward it multiple times in the same epoch.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "operator": {
              "description": "Total pledge and compounded reward earned by the node operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "total_unit_reward": {
              "description": "Cumulative reward earned by the \"unit delegation\" since the block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "unique_delegations": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "unit_delegation": {
              "description": "Value of the theoretical \"unit delegation\" that has delegated to this node at block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PendingMixNodeChanges": {
          "type": "object",
          "properties": {
            "cost_params_change": {
              "default": null,
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            },
            "pledge_change": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Percent": {
          "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_mixnode_rewarding_details": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "MixnodeRewardingDetailsResponse",
      "description": "Response containing rewarding information of a mixnode with the provided id.",
      "type": "object",
      "required": [
        "mix_id"
      ],
      "properties": {
        "mix_id": {
          "description": "Id of the requested mixnode.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "rewarding_details": {
          "description": "If there exists a mixnode with the provided id, this field contains its rewarding information.",
          "anyOf": [
            {
              "$ref": "#/definitions/NodeRewarding"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "NodeCostParams": {
          "description": "The cost parameters, or the cost function, defined for the particular mixnode that influences how the rewards should be split between the node operator and its delegators.",
          "type": "object",
          "required": [
            "interval_operating_cost",
            "profit_margin_percent"
          ],
          "properties": {
            "interval_operating_cost": {
              "description": "Operating cost of the associated node per the entire interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "profit_margin_percent": {
              "description": "The profit margin of the associated node, i.e. the desired percent of the reward to be distributed to the operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Percent"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "NodeRewarding": {
          "type": "object",
          "required": [
            "cost_params",
            "delegates",
            "last_rewarded_epoch",
            "operator",
            "total_unit_reward",
            "unique_delegations",
            "unit_delegation"
          ],
          "properties": {
            "cost_params": {
              "description": "Information provided by the operator that influence the cost function.",
              "allOf": [
                {
                  "$ref": "#/definitions/NodeCostParams"
                }
              ]
            },
            "delegates": {
              "description": "Total delegation and compounded reward earned by all node delegators.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "last_rewarded_epoch": {
              "description": "Marks the epoch when this node was last rewarded so that we wouldn't accidentally attempt to reward it multiple times in the same epoch.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "operator": {
              "description": "Total pledge and compounded reward earned by the node operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "total_unit_reward": {
              "description": "Cumulative reward earned by the \"unit delegation\" since the block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "unique_delegations": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "unit_delegation": {
              "description": "Value of the theoretical \"unit delegation\" that has delegated to this node at block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Percent": {
          "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_node_delegations": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedNodeDelegationsResponse",
      "description": "Response containing paged list of all delegations made towards particular node.",
      "type": "object",
      "required": [
        "delegations"
      ],
      "properties": {
        "delegations": {
          "description": "Each individual delegation made.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Delegation"
          }
        },
        "start_next_after": {
          "description": "Field indicating paging information for the following queries if the caller wishes to get further entries.",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Delegation": {
          "description": "Information about tokens being delegated towards given mixnode in order to accrue rewards with their work.",
          "type": "object",
          "required": [
            "amount",
            "cumulative_reward_ratio",
            "height",
            "node_id",
            "owner"
          ],
          "properties": {
            "amount": {
              "description": "Original delegation amount. Note that it is never mutated as delegation accumulates rewards.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "cumulative_reward_ratio": {
              "description": "Value of the \"unit delegation\" associated with the mixnode at the time of delegation.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "height": {
              "description": "Block height where this delegation occurred.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "node_id": {
              "description": "Id of the Node that this delegation was performed against.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "owner": {
              "description": "Address of the owner of this delegation.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Proxy address used to delegate the funds on behalf of another address",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_node_rewarding_details": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "NodeRewardingDetailsResponse",
      "description": "Response containing rewarding information of a node with the provided id.",
      "type": "object",
      "required": [
        "node_id"
      ],
      "properties": {
        "node_id": {
          "description": "Id of the requested node.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "rewarding_details": {
          "description": "If there exists a node with the provided id, this field contains its rewarding information.",
          "anyOf": [
            {
              "$ref": "#/definitions/NodeRewarding"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "NodeCostParams": {
          "description": "The cost parameters, or the cost function, defined for the particular mixnode that influences how the rewards should be split between the node operator and its delegators.",
          "type": "object",
          "required": [
            "interval_operating_cost",
            "profit_margin_percent"
          ],
          "properties": {
            "interval_operating_cost": {
              "description": "Operating cost of the associated node per the entire interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "profit_margin_percent": {
              "description": "The profit margin of the associated node, i.e. the desired percent of the reward to be distributed to the operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Percent"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "NodeRewarding": {
          "type": "object",
          "required": [
            "cost_params",
            "delegates",
            "last_rewarded_epoch",
            "operator",
            "total_unit_reward",
            "unique_delegations",
            "unit_delegation"
          ],
          "properties": {
            "cost_params": {
              "description": "Information provided by the operator that influence the cost function.",
              "allOf": [
                {
                  "$ref": "#/definitions/NodeCostParams"
                }
              ]
            },
            "delegates": {
              "description": "Total delegation and compounded reward earned by all node delegators.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "last_rewarded_epoch": {
              "description": "Marks the epoch when this node was last rewarded so that we wouldn't accidentally attempt to reward it multiple times in the same epoch.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "operator": {
              "description": "Total pledge and compounded reward earned by the node operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "total_unit_reward": {
              "description": "Cumulative reward earned by the \"unit delegation\" since the block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "unique_delegations": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "unit_delegation": {
              "description": "Value of the theoretical \"unit delegation\" that has delegated to this node at block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Percent": {
          "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_node_stake_saturation": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "StakeSaturationResponse",
      "description": "Response containing the current state of the stake saturation of a node with the provided id.",
      "type": "object",
      "required": [
        "node_id"
      ],
      "properties": {
        "current_saturation": {
          "description": "The current stake saturation of this node that is indirectly used in reward calculation formulas. Note that it can't be larger than 1.",
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "node_id": {
          "description": "Id of the requested node.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "uncapped_saturation": {
          "description": "The current, absolute, stake saturation of this node. Note that as the name suggests it can be larger than 1. However, anything beyond that value has no effect on the total node reward.",
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        }
      }
    },
    "get_number_of_pending_events": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "NumberOfPendingEventsResponse",
      "description": "Response containing number of currently pending epoch and interval events.",
      "type": "object",
      "required": [
        "epoch_events",
        "interval_events"
      ],
      "properties": {
        "epoch_events": {
          "description": "The number of the currently pending epoch events.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "interval_events": {
          "description": "The number of the currently pending epoch events.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false
    },
    "get_nym_node_bonds_paged": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedNymNodeBondsResponse",
      "type": "object",
      "required": [
        "nodes"
      ],
      "properties": {
        "nodes": {
          "description": "The nym node bond information present in the contract.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/NymNodeBond"
          }
        },
        "start_next_after": {
          "description": "Field indicating paging information for the following queries if the caller wishes to get further entries.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "NymNode": {
          "description": "Information provided by the node operator during bonding that are used to allow other entities to use the services of this node.",
          "type": "object",
          "required": [
            "host",
            "identity_key"
          ],
          "properties": {
            "custom_http_port": {
              "description": "Allow specifying custom port for accessing the http, and thus self-described, api of this node for the capabilities discovery.",
              "type": [
                "integer",
                "null"
              ],
              "format": "uint16",
              "minimum": 0.0
            },
            "host": {
              "description": "Network address of this nym-node, for example 1.1.1.1 or foo.mixnode.com that is used to discover other capabilities of this node.",
              "type": "string"
            },
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "NymNodeBond": {
          "type": "object",
          "required": [
            "bonding_height",
            "is_unbonding",
            "node",
            "node_id",
            "original_pledge",
            "owner"
          ],
          "properties": {
            "bonding_height": {
              "description": "Block height at which this nym-node has been bonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "is_unbonding": {
              "description": "Flag to indicate whether this node is in the process of unbonding, that will conclude upon the epoch finishing.",
              "type": "boolean"
            },
            "node": {
              "description": "Information provided by the operator for the purposes of bonding.",
              "allOf": [
                {
                  "$ref": "#/definitions/NymNode"
                }
              ]
            },
            "node_id": {
              "description": "Unique id assigned to the bonded node.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "original_pledge": {
              "description": "Original amount pledged by the operator of this node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "owner": {
              "description": "Address of the owner of this nym-node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_nym_node_details": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "NodeDetailsResponse",
      "description": "Response containing details of a node with the provided id.",
      "type": "object",
      "required": [
        "node_id"
      ],
      "properties": {
        "details": {
          "description": "If there exists a node with the provided id, this field contains its detailed information.",
          "anyOf": [
            {
              "$ref": "#/definitions/NymNodeDetails"
            },
            {
              "type": "null"
            }
          ]
        },
        "node_id": {
          "description": "Id of the requested node.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "NodeCostParams": {
          "description": "The cost parameters, or the cost function, defined for the particular mixnode that influences how the rewards should be split between the node operator and its delegators.",
          "type": "object",
          "required": [
            "interval_operating_cost",
            "profit_margin_percent"
          ],
          "properties": {
            "interval_operating_cost": {
              "description": "Operating cost of the associated node per the entire interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "profit_margin_percent": {
              "description": "The profit margin of the associated node, i.e. the desired percent of the reward to be distributed to the operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Percent"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "NodeRewarding": {
          "type": "object",
          "required": [
            "cost_params",
            "delegates",
            "last_rewarded_epoch",
            "operator",
            "total_unit_reward",
            "unique_delegations",
            "unit_delegation"
          ],
          "properties": {
            "cost_params": {
              "description": "Information provided by the operator that influence the cost function.",
              "allOf": [
                {
                  "$ref": "#/definitions/NodeCostParams"
                }
              ]
            },
            "delegates": {
              "description": "Total delegation and compounded reward earned by all node delegators.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "last_rewarded_epoch": {
              "description": "Marks the epoch when this node was last rewarded so that we wouldn't accidentally attempt to reward it multiple times in the same epoch.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "operator": {
              "description": "Total pledge and compounded reward earned by the node operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "total_unit_reward": {
              "description": "Cumulative reward earned by the \"unit delegation\" since the block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "unique_delegations": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "unit_delegation": {
              "description": "Value of the theoretical \"unit delegation\" that has delegated to this node at block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "NymNode": {
          "description": "Information provided by the node operator during bonding that are used to allow other entities to use the services of this node.",
          "type": "object",
          "required": [
            "host",
            "identity_key"
          ],
          "properties": {
            "custom_http_port": {
              "description": "Allow specifying custom port for accessing the http, and thus self-described, api of this node for the capabilities discovery.",
              "type": [
                "integer",
                "null"
              ],
              "format": "uint16",
              "minimum": 0.0
            },
            "host": {
              "description": "Network address of this nym-node, for example 1.1.1.1 or foo.mixnode.com that is used to discover other capabilities of this node.",
              "type": "string"
            },
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "NymNodeBond": {
          "type": "object",
          "required": [
            "bonding_height",
            "is_unbonding",
            "node",
            "node_id",
            "original_pledge",
            "owner"
          ],
          "properties": {
            "bonding_height": {
              "description": "Block height at which this nym-node has been bonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "is_unbonding": {
              "description": "Flag to indicate whether this node is in the process of unbonding, that will conclude upon the epoch finishing.",
              "type": "boolean"
            },
            "node": {
              "description": "Information provided by the operator for the purposes of bonding.",
              "allOf": [
                {
                  "$ref": "#/definitions/NymNode"
                }
              ]
            },
            "node_id": {
              "description": "Unique id assigned to the bonded node.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "original_pledge": {
              "description": "Original amount pledged by the operator of this node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "owner": {
              "description": "Address of the owner of this nym-node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "NymNodeDetails": {
          "description": "Full details associated with given node.",
          "type": "object",
          "required": [
            "bond_information",
            "pending_changes",
            "rewarding_details"
          ],
          "properties": {
            "bond_information": {
              "description": "Basic bond information of this node, such as owner address, original pledge, etc.",
              "allOf": [
                {
                  "$ref": "#/definitions/NymNodeBond"
                }
              ]
            },
            "pending_changes": {
              "description": "Adjustments to the node that are scheduled to happen during future epoch/interval transitions.",
              "allOf": [
                {
                  "$ref": "#/definitions/PendingNodeChanges"
                }
              ]
            },
            "rewarding_details": {
              "description": "Details used for computation of rewarding related data.",
              "allOf": [
                {
                  "$ref": "#/definitions/NodeRewarding"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PendingNodeChanges": {
          "type": "object",
          "properties": {
            "cost_params_change": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            },
            "pledge_change": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Percent": {
          "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_nym_node_details_by_identity_key": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "NodeDetailsByIdentityResponse",
      "description": "Response containing details of a bonded node with the provided identity key.",
      "type": "object",
      "required": [
        "identity_key"
      ],
      "properties": {
        "details": {
          "description": "If there exists a bonded node with the provided identity key, this field contains its detailed information.",
          "anyOf": [
            {
              "$ref": "#/definitions/NymNodeDetails"
            },
            {
              "type": "null"
            }
          ]
        },
        "identity_key": {
          "description": "The identity key (base58-encoded ed25519 public key) of the node.",
          "type": "string"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "NodeCostParams": {
          "description": "The cost parameters, or the cost function, defined for the particular mixnode that influences how the rewards should be split between the node operator and its delegators.",
          "type": "object",
          "required": [
            "interval_operating_cost",
            "profit_margin_percent"
          ],
          "properties": {
            "interval_operating_cost": {
              "description": "Operating cost of the associated node per the entire interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "profit_margin_percent": {
              "description": "The profit margin of the associated node, i.e. the desired percent of the reward to be distributed to the operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Percent"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "NodeRewarding": {
          "type": "object",
          "required": [
            "cost_params",
            "delegates",
            "last_rewarded_epoch",
            "operator",
            "total_unit_reward",
            "unique_delegations",
            "unit_delegation"
          ],
          "properties": {
            "cost_params": {
              "description": "Information provided by the operator that influence the cost function.",
              "allOf": [
                {
                  "$ref": "#/definitions/NodeCostParams"
                }
              ]
            },
            "delegates": {
              "description": "Total delegation and compounded reward earned by all node delegators.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "last_rewarded_epoch": {
              "description": "Marks the epoch when this node was last rewarded so that we wouldn't accidentally attempt to reward it multiple times in the same epoch.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "operator": {
              "description": "Total pledge and compounded reward earned by the node operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "total_unit_reward": {
              "description": "Cumulative reward earned by the \"unit delegation\" since the block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "unique_delegations": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "unit_delegation": {
              "description": "Value of the theoretical \"unit delegation\" that has delegated to this node at block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "NymNode": {
          "description": "Information provided by the node operator during bonding that are used to allow other entities to use the services of this node.",
          "type": "object",
          "required": [
            "host",
            "identity_key"
          ],
          "properties": {
            "custom_http_port": {
              "description": "Allow specifying custom port for accessing the http, and thus self-described, api of this node for the capabilities discovery.",
              "type": [
                "integer",
                "null"
              ],
              "format": "uint16",
              "minimum": 0.0
            },
            "host": {
              "description": "Network address of this nym-node, for example 1.1.1.1 or foo.mixnode.com that is used to discover other capabilities of this node.",
              "type": "string"
            },
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "NymNodeBond": {
          "type": "object",
          "required": [
            "bonding_height",
            "is_unbonding",
            "node",
            "node_id",
            "original_pledge",
            "owner"
          ],
          "properties": {
            "bonding_height": {
              "description": "Block height at which this nym-node has been bonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "is_unbonding": {
              "description": "Flag to indicate whether this node is in the process of unbonding, that will conclude upon the epoch finishing.",
              "type": "boolean"
            },
            "node": {
              "description": "Information provided by the operator for the purposes of bonding.",
              "allOf": [
                {
                  "$ref": "#/definitions/NymNode"
                }
              ]
            },
            "node_id": {
              "description": "Unique id assigned to the bonded node.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "original_pledge": {
              "description": "Original amount pledged by the operator of this node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "owner": {
              "description": "Address of the owner of this nym-node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "NymNodeDetails": {
          "description": "Full details associated with given node.",
          "type": "object",
          "required": [
            "bond_information",
            "pending_changes",
            "rewarding_details"
          ],
          "properties": {
            "bond_information": {
              "description": "Basic bond information of this node, such as owner address, original pledge, etc.",
              "allOf": [
                {
                  "$ref": "#/definitions/NymNodeBond"
                }
              ]
            },
            "pending_changes": {
              "description": "Adjustments to the node that are scheduled to happen during future epoch/interval transitions.",
              "allOf": [
                {
                  "$ref": "#/definitions/PendingNodeChanges"
                }
              ]
            },
            "rewarding_details": {
              "description": "Details used for computation of rewarding related data.",
              "allOf": [
                {
                  "$ref": "#/definitions/NodeRewarding"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PendingNodeChanges": {
          "type": "object",
          "properties": {
            "cost_params_change": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            },
            "pledge_change": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Percent": {
          "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_nym_nodes_detailed_paged": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedNymNodeDetailsResponse",
      "type": "object",
      "required": [
        "nodes"
      ],
      "properties": {
        "nodes": {
          "description": "All nym-node details stored in the contract. Apart from the basic bond information it also contains details required for all future reward calculation as well as any pending changes requested by the operator.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/NymNodeDetails"
          }
        },
        "start_next_after": {
          "description": "Field indicating paging information for the following queries if the caller wishes to get further entries.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "NodeCostParams": {
          "description": "The cost parameters, or the cost function, defined for the particular mixnode that influences how the rewards should be split between the node operator and its delegators.",
          "type": "object",
          "required": [
            "interval_operating_cost",
            "profit_margin_percent"
          ],
          "properties": {
            "interval_operating_cost": {
              "description": "Operating cost of the associated node per the entire interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "profit_margin_percent": {
              "description": "The profit margin of the associated node, i.e. the desired percent of the reward to be distributed to the operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Percent"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "NodeRewarding": {
          "type": "object",
          "required": [
            "cost_params",
            "delegates",
            "last_rewarded_epoch",
            "operator",
            "total_unit_reward",
            "unique_delegations",
            "unit_delegation"
          ],
          "properties": {
            "cost_params": {
              "description": "Information provided by the operator that influence the cost function.",
              "allOf": [
                {
                  "$ref": "#/definitions/NodeCostParams"
                }
              ]
            },
            "delegates": {
              "description": "Total delegation and compounded reward earned by all node delegators.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "last_rewarded_epoch": {
              "description": "Marks the epoch when this node was last rewarded so that we wouldn't accidentally attempt to reward it multiple times in the same epoch.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "operator": {
              "description": "Total pledge and compounded reward earned by the node operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "total_unit_reward": {
              "description": "Cumulative reward earned by the \"unit delegation\" since the block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "unique_delegations": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "unit_delegation": {
              "description": "Value of the theoretical \"unit delegation\" that has delegated to this node at block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "NymNode": {
          "description": "Information provided by the node operator during bonding that are used to allow other entities to use the services of this node.",
          "type": "object",
          "required": [
            "host",
            "identity_key"
          ],
          "properties": {
            "custom_http_port": {
              "description": "Allow specifying custom port for accessing the http, and thus self-described, api of this node for the capabilities discovery.",
              "type": [
                "integer",
                "null"
              ],
              "format": "uint16",
              "minimum": 0.0
            },
            "host": {
              "description": "Network address of this nym-node, for example 1.1.1.1 or foo.mixnode.com that is used to discover other capabilities of this node.",
              "type": "string"
            },
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "NymNodeBond": {
          "type": "object",
          "required": [
            "bonding_height",
            "is_unbonding",
            "node",
            "node_id",
            "original_pledge",
            "owner"
          ],
          "properties": {
            "bonding_height": {
              "description": "Block height at which this nym-node has been bonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "is_unbonding": {
              "description": "Flag to indicate whether this node is in the process of unbonding, that will conclude upon the epoch finishing.",
              "type": "boolean"
            },
            "node": {
              "description": "Information provided by the operator for the purposes of bonding.",
              "allOf": [
                {
                  "$ref": "#/definitions/NymNode"
                }
              ]
            },
            "node_id": {
              "description": "Unique id assigned to the bonded node.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "original_pledge": {
              "description": "Original amount pledged by the operator of this node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "owner": {
              "description": "Address of the owner of this nym-node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "NymNodeDetails": {
          "description": "Full details associated with given node.",
          "type": "object",
          "required": [
            "bond_information",
            "pending_changes",
            "rewarding_details"
          ],
          "properties": {
            "bond_information": {
              "description": "Basic bond information of this node, such as owner address, original pledge, etc.",
              "allOf": [
                {
                  "$ref": "#/definitions/NymNodeBond"
                }
              ]
            },
            "pending_changes": {
              "description": "Adjustments to the node that are scheduled to happen during future epoch/interval transitions.",
              "allOf": [
                {
                  "$ref": "#/definitions/PendingNodeChanges"
                }
              ]
            },
            "rewarding_details": {
              "description": "Details used for computation of rewarding related data.",
              "allOf": [
                {
                  "$ref": "#/definitions/NodeRewarding"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PendingNodeChanges": {
          "type": "object",
          "properties": {
            "cost_params_change": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            },
            "pledge_change": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Percent": {
          "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_owned_gateway": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "GatewayOwnershipResponse",
      "description": "Response containing details of a gateway belonging to the particular owner.",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "address": {
          "description": "Validated address of the gateway owner.",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "gateway": {
          "description": "If the provided address owns a gateway, this field contains its details.",
          "anyOf": [
            {
              "$ref": "#/definitions/GatewayBond"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Gateway": {
          "description": "Information provided by the node operator during bonding that are used to allow other entities to use the services of this node.",
          "type": "object",
          "required": [
            "clients_port",
            "host",
            "identity_key",
            "location",
            "mix_port",
            "sphinx_key",
            "version"
          ],
          "properties": {
            "clients_port": {
              "description": "Port used by this gateway for listening for client requests.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "host": {
              "description": "Network address of this gateway, for example 1.1.1.1 or foo.gateway.com",
              "type": "string"
            },
            "identity_key": {
              "description": "Base58 encoded ed25519 EdDSA public key of the gateway used to derive shared keys with clients",
              "type": "string"
            },
            "location": {
              "description": "The physical, self-reported, location of this gateway.",
              "type": "string"
            },
            "mix_port": {
              "description": "Port used by this gateway for listening for mix packets.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "sphinx_key": {
              "description": "Base58-encoded x25519 public key used for sphinx key derivation.",
              "type": "string"
            },
            "version": {
              "description": "The self-reported semver version of this gateway.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "GatewayBond": {
          "description": "Basic gateway information provided by the node operator.",
          "type": "object",
          "required": [
            "block_height",
            "gateway",
            "owner",
            "pledge_amount"
          ],
          "properties": {
            "block_height": {
              "description": "Block height at which this gateway has been bonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "gateway": {
              "description": "Information provided by the operator for the purposes of bonding.",
              "allOf": [
                {
                  "$ref": "#/definitions/Gateway"
                }
              ]
            },
            "owner": {
              "description": "Address of the owner of this gateway.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "pledge_amount": {
              "description": "Original amount pledged by the operator of this node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "proxy": {
              "description": "Entity who bonded this gateway on behalf of the owner. If exists, it's most likely the address of the vesting contract.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_owned_mixnode": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "MixOwnershipResponse",
      "description": "Response containing details of a mixnode belonging to the particular owner.",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "address": {
          "description": "Validated address of the mixnode owner.",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "mixnode_details": {
          "description": "If the provided address owns a mixnode, this field contains its detailed information.",
          "anyOf": [
            {
              "$ref": "#/definitions/MixNodeDetails"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "MixNode": {
          "description": "Information provided by the node operator during bonding that are used to allow other entities to use the services of this node.",
          "type": "object",
          "required": [
            "host",
            "http_api_port",
            "identity_key",
            "mix_port",
            "sphinx_key",
            "verloc_port",
            "version"
          ],
          "properties": {
            "host": {
              "description": "Network address of this mixnode, for example 1.1.1.1 or foo.mixnode.com",
              "type": "string"
            },
            "http_api_port": {
              "description": "Port used by this mixnode for its http(s) API",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            },
            "mix_port": {
              "description": "Port used by this mixnode for listening for mix packets.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "sphinx_key": {
              "description": "Base58-encoded x25519 public key used for sphinx key derivation.",
              "type": "string"
            },
            "verloc_port": {
              "description": "Port used by this mixnode for listening for verloc requests.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "version": {
              "description": "The self-reported semver version of this mixnode.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "MixNodeBond": {
          "description": "Basic mixnode information provided by the node operator.",
          "type": "object",
          "required": [
            "bonding_height",
            "is_unbonding",
            "mix_id",
            "mix_node",
            "original_pledge",
            "owner"
          ],
          "properties": {
            "bonding_height": {
              "description": "Block height at which this mixnode has been bonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "is_unbonding": {
              "description": "Flag to indicate whether this node is in the process of unbonding, that will conclude upon the epoch finishing.",
              "type": "boolean"
            },
            "mix_id": {
              "description": "Unique id assigned to the bonded mixnode.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "mix_node": {
              "description": "Information provided by the operator for the purposes of bonding.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNode"
                }
              ]
            },
            "original_pledge": {
              "description": "Original amount pledged by the operator of this node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "owner": {
              "description": "Address of the owner of this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Entity who bonded this mixnode on behalf of the owner. If exists, it's most likely the address of the vesting contract.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          }
        },
        "MixNodeDetails": {
          "description": "Full details associated with given mixnode.",
          "type": "object",
          "required": [
            "bond_information",
            "rewarding_details"
          ],
          "properties": {
            "bond_information": {
              "description": "Basic bond information of this mixnode, such as owner address, original pledge, etc.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNodeBond"
                }
              ]
            },
            "pending_changes": {
              "description": "Adjustments to the mixnode that are ought to happen during future epoch transitions.",
              "default": {
                "cost_params_change": null,
                "pledge_change": null
              },
              "allOf": [
                {
                  "$ref": "#/definitions/PendingMixNodeChanges"
                }
              ]
            },
            "rewarding_details": {
              "description": "Details used for computation of rewarding related data.",
              "allOf": [
                {
                  "$ref": "#/definitions/NodeRewarding"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "NodeCostParams": {
          "description": "The cost parameters, or the cost function, defined for the particular mixnode that influences how the rewards should be split between the node operator and its delegators.",
          "type": "object",
          "required": [
            "interval_operating_cost",
            "profit_margin_percent"
          ],
          "properties": {
            "interval_operating_cost": {
              "description": "Operating cost of the associated node per the entire interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "profit_margin_percent": {
              "description": "The profit margin of the associated node, i.e. the desired percent of the reward to be distributed to the operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Percent"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "NodeRewarding": {
          "type": "object",
          "required": [
            "cost_params",
            "delegates",
            "last_rewarded_epoch",
            "operator",
            "total_unit_reward",
            "unique_delegations",
            "unit_delegation"
          ],
          "properties": {
            "cost_params": {
              "description": "Information provided by the operator that influence the cost function.",
              "allOf": [
                {
                  "$ref": "#/definitions/NodeCostParams"
                }
              ]
            },
            "delegates": {
              "description": "Total delegation and compounded reward earned by all node delegators.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "last_rewarded_epoch": {
              "description": "Marks the epoch when this node was last rewarded so that we wouldn't accidentally attempt to reward it multiple times in the same epoch.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "operator": {
              "description": "Total pledge and compounded reward earned by the node operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "total_unit_reward": {
              "description": "Cumulative reward earned by the \"unit delegation\" since the block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "unique_delegations": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "unit_delegation": {
              "description": "Value of the theoretical \"unit delegation\" that has delegated to this node at block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PendingMixNodeChanges": {
          "type": "object",
          "properties": {
            "cost_params_change": {
              "default": null,
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            },
            "pledge_change": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Percent": {
          "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_owned_nym_node": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "NodeOwnershipResponse",
      "description": "Response containing details of a node belonging to the particular owner.",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "address": {
          "description": "Validated address of the node owner.",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "details": {
          "description": "If the provided address owns a nym-node, this field contains its detailed information.",
          "anyOf": [
            {
              "$ref": "#/definitions/NymNodeDetails"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "NodeCostParams": {
          "description": "The cost parameters, or the cost function, defined for the particular mixnode that influences how the rewards should be split between the node operator and its delegators.",
          "type": "object",
          "required": [
            "interval_operating_cost",
            "profit_margin_percent"
          ],
          "properties": {
            "interval_operating_cost": {
              "description": "Operating cost of the associated node per the entire interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "profit_margin_percent": {
              "description": "The profit margin of the associated node, i.e. the desired percent of the reward to be distributed to the operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Percent"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "NodeRewarding": {
          "type": "object",
          "required": [
            "cost_params",
            "delegates",
            "last_rewarded_epoch",
            "operator",
            "total_unit_reward",
            "unique_delegations",
            "unit_delegation"
          ],
          "properties": {
            "cost_params": {
              "description": "Information provided by the operator that influence the cost function.",
              "allOf": [
                {
                  "$ref": "#/definitions/NodeCostParams"
                }
              ]
            },
            "delegates": {
              "description": "Total delegation and compounded reward earned by all node delegators.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "last_rewarded_epoch": {
              "description": "Marks the epoch when this node was last rewarded so that we wouldn't accidentally attempt to reward it multiple times in the same epoch.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "operator": {
              "description": "Total pledge and compounded reward earned by the node operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "total_unit_reward": {
              "description": "Cumulative reward earned by the \"unit delegation\" since the block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "unique_delegations": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "unit_delegation": {
              "description": "Value of the theoretical \"unit delegation\" that has delegated to this node at block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "NymNode": {
          "description": "Information provided by the node operator during bonding that are used to allow other entities to use the services of this node.",
          "type": "object",
          "required": [
            "host",
            "identity_key"
          ],
          "properties": {
            "custom_http_port": {
              "description": "Allow specifying custom port for accessing the http, and thus self-described, api of this node for the capabilities discovery.",
              "type": [
                "integer",
                "null"
              ],
              "format": "uint16",
              "minimum": 0.0
            },
            "host": {
              "description": "Network address of this nym-node, for example 1.1.1.1 or foo.mixnode.com that is used to discover other capabilities of this node.",
              "type": "string"
            },
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "NymNodeBond": {
          "type": "object",
          "required": [
            "bonding_height",
            "is_unbonding",
            "node",
            "node_id",
            "original_pledge",
            "owner"
          ],
          "properties": {
            "bonding_height": {
              "description": "Block height at which this nym-node has been bonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "is_unbonding": {
              "description": "Flag to indicate whether this node is in the process of unbonding, that will conclude upon the epoch finishing.",
              "type": "boolean"
            },
            "node": {
              "description": "Information provided by the operator for the purposes of bonding.",
              "allOf": [
                {
                  "$ref": "#/definitions/NymNode"
                }
              ]
            },
            "node_id": {
              "description": "Unique id assigned to the bonded node.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "original_pledge": {
              "description": "Original amount pledged by the operator of this node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "owner": {
              "description": "Address of the owner of this nym-node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "NymNodeDetails": {
          "description": "Full details associated with given node.",
          "type": "object",
          "required": [
            "bond_information",
            "pending_changes",
            "rewarding_details"
          ],
          "properties": {
            "bond_information": {
              "description": "Basic bond information of this node, such as owner address, original pledge, etc.",
              "allOf": [
                {
                  "$ref": "#/definitions/NymNodeBond"
                }
              ]
            },
            "pending_changes": {
              "description": "Adjustments to the node that are scheduled to happen during future epoch/interval transitions.",
              "allOf": [
                {
                  "$ref": "#/definitions/PendingNodeChanges"
                }
              ]
            },
            "rewarding_details": {
              "description": "Details used for computation of rewarding related data.",
              "allOf": [
                {
                  "$ref": "#/definitions/NodeRewarding"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PendingNodeChanges": {
          "type": "object",
          "properties": {
            "cost_params_change": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            },
            "pledge_change": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Percent": {
          "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_pending_delegator_reward": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PendingRewardResponse",
      "description": "Response containing information about accrued rewards.",
      "type": "object",
      "required": [
        "mixnode_still_fully_bonded",
        "node_still_fully_bonded"
      ],
      "properties": {
        "amount_earned": {
          "description": "The amount of tokens that could be claimed.",
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "amount_earned_detailed": {
          "description": "The full pending rewards. Note that it's nearly identical to `amount_earned`, however, it contains few additional decimal points for more accurate reward calculation.",
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "amount_staked": {
          "description": "The amount of tokens initially staked.",
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "mixnode_still_fully_bonded": {
          "description": "The associated mixnode is still fully bonded, meaning it is neither unbonded nor in the process of unbonding that would have finished at the epoch transition.",
          "deprecated": true,
          "type": "boolean"
        },
        "node_still_fully_bonded": {
          "type": "boolean"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_pending_epoch_event": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PendingEpochEventResponse",
      "type": "object",
      "required": [
        "event_id"
      ],
      "properties": {
        "event": {
          "anyOf": [
            {
              "$ref": "#/definitions/PendingEpochEventData"
            },
            {
              "type": "null"
            }
          ]
        },
        "event_id": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "ActiveSetUpdate": {
          "description": "Specification on how the active set should be updated.",
          "type": "object",
          "required": [
            "entry_gateways",
            "exit_gateways",
            "mixnodes"
          ],
          "properties": {
            "entry_gateways": {
              "description": "The expected number of nodes assigned entry gateway role (i.e. [`Role::EntryGateway`])",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "exit_gateways": {
              "description": "The expected number of nodes assigned exit gateway role (i.e. [`Role::ExitGateway`])",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "mixnodes": {
              "description": "The expected number of nodes assigned the 'mixnode' role, i.e. total of [`Role::Layer1`], [`Role::Layer2`] and [`Role::Layer3`].",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "PendingEpochEventData": {
          "description": "Details of a particular pending epoch event.",
          "type": "object",
          "required": [
            "created_at",
            "kind"
          ],
          "properties": {
            "created_at": {
              "description": "The block height at which the request has been made.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "kind": {
              "description": "The underlying event data, containing its concrete type and information on how it should get resolved.",
              "allOf": [
                {
                  "$ref": "#/definitions/PendingEpochEventKind"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PendingEpochEventKind": {
          "description": "Enum encompassing all possible epoch events.",
          "oneOf": [
            {
              "description": "Request to create a delegation towards particular node. Note that if such delegation already exists, it will get updated with the provided token amount.",
              "type": "object",
              "required": [
                "delegate"
              ],
              "properties": {
                "delegate": {
                  "type": "object",
                  "required": [
                    "amount",
                    "node_id",
                    "owner"
                  ],
                  "properties": {
                    "amount": {
                      "description": "The amount of tokens to use for the delegation.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Coin"
                        }
                      ]
                    },
                    "node_id": {
                      "description": "The id of the node used for the delegation.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    },
                    "owner": {
                      "description": "The address of the owner of the delegation.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Addr"
                        }
                      ]
                    },
                    "proxy": {
                      "description": "Entity who made the delegation on behalf of the owner. If present, it's most likely the address of the vesting contract.",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/Addr"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to remove delegation from particular node.",
              "type": "object",
              "required": [
                "undelegate"
              ],
              "properties": {
                "undelegate": {
                  "type": "object",
                  "required": [
                    "node_id",
                    "owner"
                  ],
                  "properties": {
                    "node_id": {
                      "description": "The id of the node used for the delegation.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    },
                    "owner": {
                      "description": "The address of the owner of the delegation.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Addr"
                        }
                      ]
                    },
                    "proxy": {
                      "description": "Entity who made the delegation on behalf of the owner. If present, it's most likely the address of the vesting contract.",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/Addr"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to pledge more tokens (by the node operator) towards its node.",
              "type": "object",
              "required": [
                "nym_node_pledge_more"
              ],
              "properties": {
                "nym_node_pledge_more": {
                  "type": "object",
                  "required": [
                    "amount",
                    "node_id"
                  ],
                  "properties": {
                    "amount": {
                      "description": "The amount of additional tokens to use in the pledge.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Coin"
                        }
                      ]
                    },
                    "node_id": {
                      "description": "The id of the nym node that will have its pledge updated.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to pledge more tokens (by the node operator) towards its node.",
              "type": "object",
              "required": [
                "mixnode_pledge_more"
              ],
              "properties": {
                "mixnode_pledge_more": {
                  "type": "object",
                  "required": [
                    "amount",
                    "mix_id"
                  ],
                  "properties": {
                    "amount": {
                      "description": "The amount of additional tokens to use in the pledge.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Coin"
                        }
                      ]
                    },
                    "mix_id": {
                      "description": "The id of the mixnode that will have its pledge updated.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to decrease amount of pledged tokens (by the node operator) from its node.",
              "type": "object",
              "required": [
                "nym_node_decrease_pledge"
              ],
              "properties": {
                "nym_node_decrease_pledge": {
                  "type": "object",
                  "required": [
                    "decrease_by",
                    "node_id"
                  ],
                  "properties": {
                    "decrease_by": {
                      "description": "The amount of tokens that should be removed from the pledge.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Coin"
                        }
                      ]
                    },
                    "node_id": {
                      "description": "The id of the nym node that will have its pledge updated.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to decrease amount of pledged tokens (by the node operator) from its node.",
              "type": "object",
              "required": [
                "mixnode_decrease_pledge"
              ],
              "properties": {
                "mixnode_decrease_pledge": {
                  "type": "object",
                  "required": [
                    "decrease_by",
                    "mix_id"
                  ],
                  "properties": {
                    "decrease_by": {
                      "description": "The amount of tokens that should be removed from the pledge.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Coin"
                        }
                      ]
                    },
                    "mix_id": {
                      "description": "The id of the mixnode that will have its pledge updated.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to unbond a mixnode and completely remove it from the network.",
              "type": "object",
              "required": [
                "unbond_mixnode"
              ],
              "properties": {
                "unbond_mixnode": {
                  "type": "object",
                  "required": [
                    "mix_id"
                  ],
                  "properties": {
                    "mix_id": {
                      "description": "The id of the mixnode that will get unbonded.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to unbond a nym node and completely remove it from the network.",
              "type": "object",
              "required": [
                "unbond_nym_node"
              ],
              "properties": {
                "unbond_nym_node": {
                  "type": "object",
                  "required": [
                    "node_id"
                  ],
                  "properties": {
                    "node_id": {
                      "description": "The id of the node that will get unbonded.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to update the current active set.",
              "type": "object",
              "required": [
                "update_active_set"
              ],
              "properties": {
                "update_active_set": {
                  "type": "object",
                  "required": [
                    "update"
                  ],
                  "properties": {
                    "update": {
                      "$ref": "#/definitions/ActiveSetUpdate"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_pending_epoch_events": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PendingEpochEventsResponse",
      "description": "Response containing all currently pending epoch events that will be resolved once the current epoch finishes.",
      "type": "object",
      "required": [
        "events",
        "seconds_until_executable"
      ],
      "properties": {
        "events": {
          "description": "The currently pending events.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/PendingEpochEvent"
          }
        },
        "seconds_until_executable": {
          "description": "Amount of seconds until the events would be eligible to be resolved. It's equivalent to the time until the current epoch finishes.",
          "type": "integer",
          "format": "int64"
        },
        "start_next_after": {
          "description": "Field indicating paging information for the following queries if the caller wishes to get further entries.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "ActiveSetUpdate": {
          "description": "Specification on how the active set should be updated.",
          "type": "object",
          "required": [
            "entry_gateways",
            "exit_gateways",
            "mixnodes"
          ],
          "properties": {
            "entry_gateways": {
              "description": "The expected number of nodes assigned entry gateway role (i.e. [`Role::EntryGateway`])",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "exit_gateways": {
              "description": "The expected number of nodes assigned exit gateway role (i.e. [`Role::ExitGateway`])",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "mixnodes": {
              "description": "The expected number of nodes assigned the 'mixnode' role, i.e. total of [`Role::Layer1`], [`Role::Layer2`] and [`Role::Layer3`].",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "PendingEpochEvent": {
          "description": "A request made at some point in the current epoch that's going to get resolved once the epoch rolls over.",
          "type": "object",
          "required": [
            "event",
            "id"
          ],
          "properties": {
            "event": {
              "description": "The underlying event details, containing its type and information on how it should get resolved.",
              "allOf": [
                {
                  "$ref": "#/definitions/PendingEpochEventData"
                }
              ]
            },
            "id": {
              "description": "The unique id associated with the event.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "PendingEpochEventData": {
          "description": "Details of a particular pending epoch event.",
          "type": "object",
          "required": [
            "created_at",
            "kind"
          ],
          "properties": {
            "created_at": {
              "description": "The block height at which the request has been made.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "kind": {
              "description": "The underlying event data, containing its concrete type and information on how it should get resolved.",
              "allOf": [
                {
                  "$ref": "#/definitions/PendingEpochEventKind"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PendingEpochEventKind": {
          "description": "Enum encompassing all possible epoch events.",
          "oneOf": [
            {
              "description": "Request to create a delegation towards particular node. Note that if such delegation already exists, it will get updated with the provided token amount.",
              "type": "object",
              "required": [
                "delegate"
              ],
              "properties": {
                "delegate": {
                  "type": "object",
                  "required": [
                    "amount",
                    "node_id",
                    "owner"
                  ],
                  "properties": {
                    "amount": {
                      "description": "The amount of tokens to use for the delegation.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Coin"
                        }
                      ]
                    },
                    "node_id": {
                      "description": "The id of the node used for the delegation.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    },
                    "owner": {
                      "description": "The address of the owner of the delegation.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Addr"
                        }
                      ]
                    },
                    "proxy": {
                      "description": "Entity who made the delegation on behalf of the owner. If present, it's most likely the address of the vesting contract.",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/Addr"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to remove delegation from particular node.",
              "type": "object",
              "required": [
                "undelegate"
              ],
              "properties": {
                "undelegate": {
                  "type": "object",
                  "required": [
                    "node_id",
                    "owner"
                  ],
                  "properties": {
                    "node_id": {
                      "description": "The id of the node used for the delegation.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    },
                    "owner": {
                      "description": "The address of the owner of the delegation.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Addr"
                        }
                      ]
                    },
                    "proxy": {
                      "description": "Entity who made the delegation on behalf of the owner. If present, it's most likely the address of the vesting contract.",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/Addr"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to pledge more tokens (by the node operator) towards its node.",
              "type": "object",
              "required": [
                "nym_node_pledge_more"
              ],
              "properties": {
                "nym_node_pledge_more": {
                  "type": "object",
                  "required": [
                    "amount",
                    "node_id"
                  ],
                  "properties": {
                    "amount": {
                      "description": "The amount of additional tokens to use in the pledge.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Coin"
                        }
                      ]
                    },
                    "node_id": {
                      "description": "The id of the nym node that will have its pledge updated.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to pledge more tokens (by the node operator) towards its node.",
              "type": "object",
              "required": [
                "mixnode_pledge_more"
              ],
              "properties": {
                "mixnode_pledge_more": {
                  "type": "object",
                  "required": [
                    "amount",
                    "mix_id"
                  ],
                  "properties": {
                    "amount": {
                      "description": "The amount of additional tokens to use in the pledge.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Coin"
                        }
                      ]
                    },
                    "mix_id": {
                      "description": "The id of the mixnode that will have its pledge updated.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to decrease amount of pledged tokens (by the node operator) from its node.",
              "type": "object",
              "required": [
                "nym_node_decrease_pledge"
              ],
              "properties": {
                "nym_node_decrease_pledge": {
                  "type": "object",
                  "required": [
                    "decrease_by",
                    "node_id"
                  ],
                  "properties": {
                    "decrease_by": {
                      "description": "The amount of tokens that should be removed from the pledge.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Coin"
                        }
                      ]
                    },
                    "node_id": {
                      "description": "The id of the nym node that will have its pledge updated.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to decrease amount of pledged tokens (by the node operator) from its node.",
              "type": "object",
              "required": [
                "mixnode_decrease_pledge"
              ],
              "properties": {
                "mixnode_decrease_pledge": {
                  "type": "object",
                  "required": [
                    "decrease_by",
                    "mix_id"
                  ],
                  "properties": {
                    "decrease_by": {
                      "description": "The amount of tokens that should be removed from the pledge.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Coin"
                        }
                      ]
                    },
                    "mix_id": {
                      "description": "The id of the mixnode that will have its pledge updated.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to unbond a mixnode and completely remove it from the network.",
              "type": "object",
              "required": [
                "unbond_mixnode"
              ],
              "properties": {
                "unbond_mixnode": {
                  "type": "object",
                  "required": [
                    "mix_id"
                  ],
                  "properties": {
                    "mix_id": {
                      "description": "The id of the mixnode that will get unbonded.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to unbond a nym node and completely remove it from the network.",
              "type": "object",
              "required": [
                "unbond_nym_node"
              ],
              "properties": {
                "unbond_nym_node": {
                  "type": "object",
                  "required": [
                    "node_id"
                  ],
                  "properties": {
                    "node_id": {
                      "description": "The id of the node that will get unbonded.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to update the current active set.",
              "type": "object",
              "required": [
                "update_active_set"
              ],
              "properties": {
                "update_active_set": {
                  "type": "object",
                  "required": [
                    "update"
                  ],
                  "properties": {
                    "update": {
                      "$ref": "#/definitions/ActiveSetUpdate"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_pending_interval_event": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PendingIntervalEventResponse",
      "type": "object",
      "required": [
        "event_id"
      ],
      "properties": {
        "event": {
          "anyOf": [
            {
              "$ref": "#/definitions/PendingIntervalEventData"
            },
            {
              "type": "null"
            }
          ]
        },
        "event_id": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "IntervalRewardingParamsUpdate": {
          "description": "Specification on how the rewarding params should be updated.",
          "type": "object",
          "properties": {
            "active_set_work_factor": {
              "description": "Defines the new value of the active set work factor.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Decimal"
                },
                {
                  "type": "null"
                }
              ]
            },
            "interval_pool_emission": {
              "description": "Defines the new value of the interval pool emission rate.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Percent"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reward_pool": {
              "description": "Defines the new value of the reward pool.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Decimal"
                },
                {
                  "type": "null"
                }
              ]
            },
            "rewarded_set_params": {
              "description": "Defines the parameters of the rewarded set.",
              "anyOf": [
                {
                  "$ref": "#/definitions/RewardedSetParams"
                },
                {
                  "type": "null"
                }
              ]
            },
            "staking_supply": {
              "description": "Defines the new value of the staking supply.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Decimal"
                },
                {
                  "type": "null"
                }
              ]
            },
            "staking_supply_scale_factor": {
              "description": "Defines the new value of the staking supply scale factor.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Percent"
                },
                {
                  "type": "null"
                }
              ]
            },
            "sybil_resistance_percent": {
              "description": "Defines the new value of the sybil resistance percent.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Percent"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "NodeCostParams": {
          "description": "The cost parameters, or the cost function, defined for the particular mixnode that influences how the rewards should be split between the node operator and its delegators.",
          "type": "object",
          "required": [
            "interval_operating_cost",
            "profit_margin_percent"
          ],
          "properties": {
            "interval_operating_cost": {
              "description": "Operating cost of the associated node per the entire interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "profit_margin_percent": {
              "description": "The profit margin of the associated node, i.e. the desired percent of the reward to be distributed to the operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Percent"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PendingIntervalEventData": {
          "description": "Details of a particular pending interval event.",
          "type": "object",
          "required": [
            "created_at",
            "kind"
          ],
          "properties": {
            "created_at": {
              "description": "The block height at which the request has been made.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "kind": {
              "description": "The underlying event data, containing its concrete type and information on how it should get resolved.",
              "allOf": [
                {
                  "$ref": "#/definitions/PendingIntervalEventKind"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PendingIntervalEventKind": {
          "description": "Enum encompassing all possible interval events.",
          "oneOf": [
            {
              "description": "Request to update cost parameters of given mixnode.",
              "type": "object",
              "required": [
                "change_mix_cost_params"
              ],
              "properties": {
                "change_mix_cost_params": {
                  "type": "object",
                  "required": [
                    "mix_id",
                    "new_costs"
                  ],
                  "properties": {
                    "mix_id": {
                      "description": "The id of the mixnode that will have its cost parameters updated.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    },
                    "new_costs": {
                      "description": "The new updated cost function of this mixnode.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/NodeCostParams"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to update cost parameters of given nym node.",
              "type": "object",
              "required": [
                "change_nym_node_cost_params"
              ],
              "properties": {
                "change_nym_node_cost_params": {
                  "type": "object",
                  "required": [
                    "new_costs",
                    "node_id"
                  ],
                  "properties": {
                    "new_costs": {
                      "description": "The new updated cost function of this nym node.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/NodeCostParams"
                        }
                      ]
                    },
                    "node_id": {
                      "description": "The id of the nym node that will have its cost parameters updated.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to update the underlying rewarding parameters used by the system",
              "type": "object",
              "required": [
                "update_rewarding_params"
              ],
              "properties": {
                "update_rewarding_params": {
                  "type": "object",
                  "required": [
                    "update"
                  ],
                  "properties": {
                    "update": {
                      "description": "The detailed specification of the update.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/IntervalRewardingParamsUpdate"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to change the next interval configuration.",
              "type": "object",
              "required": [
                "update_interval_config"
              ],
              "properties": {
                "update_interval_config": {
                  "type": "object",
                  "required": [
                    "epoch_duration_secs",
                    "epochs_in_interval"
                  ],
                  "properties": {
                    "epoch_duration_secs": {
                      "description": "The new epoch duration.",
                      "type": "integer",
                      "format": "uint64",
                      "minimum": 0.0
                    },
                    "epochs_in_interval": {
                      "description": "The new number of epochs in intervals.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Percent": {
          "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "RewardedSetParams": {
          "type": "object",
          "required": [
            "entry_gateways",
            "exit_gateways",
            "mixnodes",
            "standby"
          ],
          "properties": {
            "entry_gateways": {
              "description": "The expected number of nodes assigned entry gateway role (i.e. [`Role::EntryGateway`])",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "exit_gateways": {
              "description": "The expected number of nodes assigned exit gateway role (i.e. [`Role::ExitGateway`])",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "mixnodes": {
              "description": "The expected number of nodes assigned the 'mixnode' role, i.e. total of [`Role::Layer1`], [`Role::Layer2`] and [`Role::Layer3`].",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "standby": {
              "description": "Number of nodes in the 'standby' set. (i.e. [`Role::Standby`])",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_pending_interval_events": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PendingIntervalEventsResponse",
      "description": "Response containing all currently pending interval events that will be resolved once the current interval finishes.",
      "type": "object",
      "required": [
        "events",
        "seconds_until_executable"
      ],
      "properties": {
        "events": {
          "description": "The currently pending events.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/PendingIntervalEvent"
          }
        },
        "seconds_until_executable": {
          "description": "Amount of seconds until the events would be eligible to be resolved. It's equivalent to the time until the current interval finishes.",
          "type": "integer",
          "format": "int64"
        },
        "start_next_after": {
          "description": "Field indicating paging information for the following queries if the caller wishes to get further entries.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "IntervalRewardingParamsUpdate": {
          "description": "Specification on how the rewarding params should be updated.",
          "type": "object",
          "properties": {
            "active_set_work_factor": {
              "description": "Defines the new value of the active set work factor.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Decimal"
                },
                {
                  "type": "null"
                }
              ]
            },
            "interval_pool_emission": {
              "description": "Defines the new value of the interval pool emission rate.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Percent"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reward_pool": {
              "description": "Defines the new value of the reward pool.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Decimal"
                },
                {
                  "type": "null"
                }
              ]
            },
            "rewarded_set_params": {
              "description": "Defines the parameters of the rewarded set.",
              "anyOf": [
                {
                  "$ref": "#/definitions/RewardedSetParams"
                },
                {
                  "type": "null"
                }
              ]
            },
            "staking_supply": {
              "description": "Defines the new value of the staking supply.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Decimal"
                },
                {
                  "type": "null"
                }
              ]
            },
            "staking_supply_scale_factor": {
              "description": "Defines the new value of the staking supply scale factor.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Percent"
                },
                {
                  "type": "null"
                }
              ]
            },
            "sybil_resistance_percent": {
              "description": "Defines the new value of the sybil resistance percent.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Percent"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "NodeCostParams": {
          "description": "The cost parameters, or the cost function, defined for the particular mixnode that influences how the rewards should be split between the node operator and its delegators.",
          "type": "object",
          "required": [
            "interval_operating_cost",
            "profit_margin_percent"
          ],
          "properties": {
            "interval_operating_cost": {
              "description": "Operating cost of the associated node per the entire interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "profit_margin_percent": {
              "description": "The profit margin of the associated node, i.e. the desired percent of the reward to be distributed to the operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Percent"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PendingIntervalEvent": {
          "description": "A request made at some point in the current interval that's going to get resolved once the interval rolls over.",
          "type": "object",
          "required": [
            "event",
            "id"
          ],
          "properties": {
            "event": {
              "description": "The underlying event details, containing its type and information on how it should get resolved.",
              "allOf": [
                {
                  "$ref": "#/definitions/PendingIntervalEventData"
                }
              ]
            },
            "id": {
              "description": "The unique id associated with the event.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "PendingIntervalEventData": {
          "description": "Details of a particular pending interval event.",
          "type": "object",
          "required": [
            "created_at",
            "kind"
          ],
          "properties": {
            "created_at": {
              "description": "The block height at which the request has been made.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "kind": {
              "description": "The underlying event data, containing its concrete type and information on how it should get resolved.",
              "allOf": [
                {
                  "$ref": "#/definitions/PendingIntervalEventKind"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PendingIntervalEventKind": {
          "description": "Enum encompassing all possible interval events.",
          "oneOf": [
            {
              "description": "Request to update cost parameters of given mixnode.",
              "type": "object",
              "required": [
                "change_mix_cost_params"
              ],
              "properties": {
                "change_mix_cost_params": {
                  "type": "object",
                  "required": [
                    "mix_id",
                    "new_costs"
                  ],
                  "properties": {
                    "mix_id": {
                      "description": "The id of the mixnode that will have its cost parameters updated.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    },
                    "new_costs": {
                      "description": "The new updated cost function of this mixnode.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/NodeCostParams"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to update cost parameters of given nym node.",
              "type": "object",
              "required": [
                "change_nym_node_cost_params"
              ],
              "properties": {
                "change_nym_node_cost_params": {
                  "type": "object",
                  "required": [
                    "new_costs",
                    "node_id"
                  ],
                  "properties": {
                    "new_costs": {
                      "description": "The new updated cost function of this nym node.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/NodeCostParams"
                        }
                      ]
                    },
                    "node_id": {
                      "description": "The id of the nym node that will have its cost parameters updated.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to update the underlying rewarding parameters used by the system",
              "type": "object",
              "required": [
                "update_rewarding_params"
              ],
              "properties": {
                "update_rewarding_params": {
                  "type": "object",
                  "required": [
                    "update"
                  ],
                  "properties": {
                    "update": {
                      "description": "The detailed specification of the update.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/IntervalRewardingParamsUpdate"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to change the next interval configuration.",
              "type": "object",
              "required": [
                "update_interval_config"
              ],
              "properties": {
                "update_interval_config": {
                  "type": "object",
                  "required": [
                    "epoch_duration_secs",
                    "epochs_in_interval"
                  ],
                  "properties": {
                    "epoch_duration_secs": {
                      "description": "The new epoch duration.",
                      "type": "integer",
                      "format": "uint64",
                      "minimum": 0.0
                    },
                    "epochs_in_interval": {
                      "description": "The new number of epochs in intervals.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Percent": {
          "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "RewardedSetParams": {
          "type": "object",
          "required": [
            "entry_gateways",
            "exit_gateways",
            "mixnodes",
            "standby"
          ],
          "properties": {
            "entry_gateways": {
              "description": "The expected number of nodes assigned entry gateway role (i.e. [`Role::EntryGateway`])",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "exit_gateways": {
              "description": "The expected number of nodes assigned exit gateway role (i.e. [`Role::ExitGateway`])",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "mixnodes": {
              "description": "The expected number of nodes assigned the 'mixnode' role, i.e. total of [`Role::Layer1`], [`Role::Layer2`] and [`Role::Layer3`].",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "standby": {
              "description": "Number of nodes in the 'standby' set. (i.e. [`Role::Standby`])",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_pending_node_operator_reward": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PendingRewardResponse",
      "description": "Response containing information about accrued rewards.",
      "type": "object",
      "required": [
        "mixnode_still_fully_bonded",
        "node_still_fully_bonded"
      ],
      "properties": {
        "amount_earned": {
          "description": "The amount of tokens that could be claimed.",
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "amount_earned_detailed": {
          "description": "The full pending rewards. Note that it's nearly identical to `amount_earned`, however, it contains few additional decimal points for more accurate reward calculation.",
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "amount_staked": {
          "description": "The amount of tokens initially staked.",
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "mixnode_still_fully_bonded": {
          "description": "The associated mixnode is still fully bonded, meaning it is neither unbonded nor in the process of unbonding that would have finished at the epoch transition.",
          "deprecated": true,
          "type": "boolean"
        },
        "node_still_fully_bonded": {
          "type": "boolean"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_pending_operator_reward": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PendingRewardResponse",
      "description": "Response containing information about accrued rewards.",
      "type": "object",
      "required": [
        "mixnode_still_fully_bonded",
        "node_still_fully_bonded"
      ],
      "properties": {
        "amount_earned": {
          "description": "The amount of tokens that could be claimed.",
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "amount_earned_detailed": {
          "description": "The full pending rewards. Note that it's nearly identical to `amount_earned`, however, it contains few additional decimal points for more accurate reward calculation.",
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "amount_staked": {
          "description": "The amount of tokens initially staked.",
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "mixnode_still_fully_bonded": {
          "description": "The associated mixnode is still fully bonded, meaning it is neither unbonded nor in the process of unbonding that would have finished at the epoch transition.",
          "deprecated": true,
          "type": "boolean"
        },
        "node_still_fully_bonded": {
          "type": "boolean"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_preassigned_gateway_ids": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PreassignedGatewayIdsResponse",
      "type": "object",
      "required": [
        "ids"
      ],
      "properties": {
        "ids": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PreassignedId"
          }
        },
        "start_next_after": {
          "description": "Field indicating paging information for the following queries if the caller wishes to get further entries.",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "PreassignedId": {
          "type": "object",
          "required": [
            "identity",
            "node_id"
          ],
          "properties": {
            "identity": {
              "description": "The identity key (base58-encoded ed25519 public key) of the gateway.",
              "type": "string"
            },
            "node_id": {
              "description": "The id pre-assigned to this gateway",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      }
    },
    "get_rewarded_set_metadata": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "RolesMetadataResponse",
      "type": "object",
      "required": [
        "metadata"
      ],
      "properties": {
        "metadata": {
          "$ref": "#/definitions/RewardedSetMetadata"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "RewardedSetMetadata": {
          "description": "Metadata associated with the rewarded set.",
          "type": "object",
          "required": [
            "entry_gateway_metadata",
            "epoch_id",
            "exit_gateway_metadata",
            "fully_assigned",
            "layer1_metadata",
            "layer2_metadata",
            "layer3_metadata",
            "standby_metadata"
          ],
          "properties": {
            "entry_gateway_metadata": {
              "description": "Metadata for the 'EntryGateway' role",
              "allOf": [
                {
                  "$ref": "#/definitions/RoleMetadata"
                }
              ]
            },
            "epoch_id": {
              "description": "Epoch that this data corresponds to.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "exit_gateway_metadata": {
              "description": "Metadata for the 'ExitGateway' role",
              "allOf": [
                {
                  "$ref": "#/definitions/RoleMetadata"
                }
              ]
            },
            "fully_assigned": {
              "description": "Indicates whether all roles got assigned to the set for this epoch.",
              "type": "boolean"
            },
            "layer1_metadata": {
              "description": "Metadata for the 'Layer1' role",
              "allOf": [
                {
                  "$ref": "#/definitions/RoleMetadata"
                }
              ]
            },
            "layer2_metadata": {
              "description": "Metadata for the 'Layer2' role",
              "allOf": [
                {
                  "$ref": "#/definitions/RoleMetadata"
                }
              ]
            },
            "layer3_metadata": {
              "description": "Metadata for the 'Layer3' role",
              "allOf": [
                {
                  "$ref": "#/definitions/RoleMetadata"
                }
              ]
            },
            "standby_metadata": {
              "description": "Metadata for the 'Standby' role",
              "allOf": [
                {
                  "$ref": "#/definitions/RoleMetadata"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "RoleMetadata": {
          "description": "Metadata associated with particular node role.",
          "type": "object",
          "required": [
            "highest_id",
            "num_nodes"
          ],
          "properties": {
            "highest_id": {
              "description": "Highest, also latest, node-id of a node assigned this role.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "num_nodes": {
              "description": "Number of nodes assigned this particular role.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      }
    },
    "get_rewarding_params": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "RewardingParams",
      "description": "Parameters used for reward calculation.",
      "type": "object",
      "required": [
        "interval",
        "rewarded_set"
      ],
      "properties": {
        "interval": {
          "description": "Parameters that should remain unchanged throughout an interval.",
          "allOf": [
            {
              "$ref": "#/definitions/IntervalRewardParams"
            }
          ]
        },
        "rewarded_set": {
          "$ref": "#/definitions/RewardedSetParams"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "IntervalRewardParams": {
          "description": "Parameters required by the mix-mining reward distribution that do not change during an interval.",
          "type": "object",
          "required": [
            "active_set_work_factor",
            "epoch_reward_budget",
            "interval_pool_emission",
            "reward_pool",
            "stake_saturation_point",
            "staking_supply",
            "staking_supply_scale_factor",
            "sybil_resistance"
          ],
          "properties": {
            "active_set_work_factor": {
              "description": "Current active set work factor. It is not really expected to be changing very often. As a matter of fact, unless there's a very specific reason, it should remain constant.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "epoch_reward_budget": {
              "description": "Current value of the computed reward budget per epoch, per node. It is expected to be constant throughout the interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "interval_pool_emission": {
              "description": "Current maximum interval pool emission. Assuming all nodes in the rewarded set are fully saturated and have 100% performance, this % of the reward pool would get distributed in rewards to all operators and its delegators. It is not really expected to be changing very often. As a matter of fact, unless there's a very specific reason, it should remain constant.",
              "allOf": [
                {
                  "$ref": "#/definitions/Percent"
                }
              ]
            },
            "reward_pool": {
              "description": "Current value of the rewarding pool. It is expected to be constant throughout the interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "stake_saturation_point": {
              "description": "Current value of the stake saturation point. It is expected to be constant throughout the interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "staking_supply": {
              "description": "Current value of the staking supply. It is expected to be constant throughout the interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "staking_supply_scale_factor": {
              "description": "Defines the percentage of stake needed to reach saturation for all of the nodes in the rewarded set. Also known as `beta`.",
              "allOf": [
                {
                  "$ref": "#/definitions/Percent"
                }
              ]
            },
            "sybil_resistance": {
              "description": "Current value of the sybil resistance percent (`alpha`). It is not really expected to be changing very often. As a matter of fact, unless there's a very specific reason, it should remain constant.",
              "allOf": [
                {
                  "$ref": "#/definitions/Percent"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Percent": {
          "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "RewardedSetParams": {
          "type": "object",
          "required": [
            "entry_gateways",
            "exit_gateways",
            "mixnodes",
            "standby"
          ],
          "properties": {
            "entry_gateways": {
              "description": "The expected number of nodes assigned entry gateway role (i.e. [`Role::EntryGateway`])",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "exit_gateways": {
              "description": "The expected number of nodes assigned exit gateway role (i.e. [`Role::ExitGateway`])",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "mixnodes": {
              "description": "The expected number of nodes assigned the 'mixnode' role, i.e. total of [`Role::Layer1`], [`Role::Layer2`] and [`Role::Layer3`].",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "standby": {
              "description": "Number of nodes in the 'standby' set. (i.e. [`Role::Standby`])",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      }
    },
    "get_rewarding_validator_address": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "String",
      "type": "string"
    },
    "get_role_assignment": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "EpochAssignmentResponse",
      "type": "object",
      "required": [
        "epoch_id",
        "nodes"
      ],
      "properties": {
        "epoch_id": {
          "description": "Epoch that this data corresponds to.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "nodes": {
          "type": "array",
          "items": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0.0
          }
        }
      },
      "additionalProperties": false
    },
    "get_signing_nonce": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "uint32",
      "type": "integer",
      "format": "uint32",
      "minimum": 0.0
    },
    "get_stake_saturation": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "MixStakeSaturationResponse",
      "description": "Response containing the current state of the stake saturation of a mixnode with the provided id.",
      "type": "object",
      "required": [
        "mix_id"
      ],
      "properties": {
        "current_saturation": {
          "description": "The current stake saturation of this node that is indirectly used in reward calculation formulas. Note that it can't be larger than 1.",
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "mix_id": {
          "description": "Id of the requested mixnode.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "uncapped_saturation": {
          "description": "The current, absolute, stake saturation of this node. Note that as the name suggests it can be larger than 1. However, anything beyond that value has no effect on the total node reward.",
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        }
      }
    },
    "get_state": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ContractState",
      "description": "The current state of the mixnet contract.",
      "type": "object",
      "required": [
        "params",
        "rewarding_denom",
        "rewarding_validator_address",
        "vesting_contract_address"
      ],
      "properties": {
        "owner": {
          "description": "Address of the contract owner.",
          "default": null,
          "deprecated": true,
          "anyOf": [
            {
              "$ref": "#/definitions/Addr"
            },
            {
              "type": "null"
            }
          ]
        },
        "params": {
          "description": "Contract parameters that could be adjusted in a transaction the contract admin.",
          "allOf": [
            {
              "$ref": "#/definitions/ContractStateParams"
            }
          ]
        },
        "rewarding_denom": {
          "description": "The expected denom used for rewarding (and realistically any other operation). Default: `unym`",
          "type": "string"
        },
        "rewarding_validator_address": {
          "description": "Address of \"rewarding validator\" (nym-api) that's allowed to send any rewarding-related transactions.",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "vesting_contract_address": {
          "description": "Address of the vesting contract to which the mixnet contract would be sending all track-related messages.",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "ContractStateParams": {
          "description": "Contract parameters that could be adjusted in a transaction by the contract admin.",
          "type": "object",
          "required": [
            "minimum_pledge"
          ],
          "properties": {
            "interval_operating_cost": {
              "description": "Defines the allowed interval operating cost range of operators. default: 0 - 1'000'000'000'000'000 (1 Billion native tokens - the total supply)",
              "default": {
                "maximum": "1000000000000000",
                "minimum": "0"
              },
              "allOf": [
                {
                  "$ref": "#/definitions/RangedValue_for_Uint128"
                }
              ]
            },
            "minimum_delegation": {
              "description": "Minimum amount a delegator must stake in orders for his delegation to get accepted.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Coin"
                },
                {
                  "type": "null"
                }
              ]
            },
            "minimum_pledge": {
              "description": "Minimum amount a node must pledge to get into the system.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "profit_margin": {
              "description": "Defines the allowed profit margin range of operators. default: 0% - 100%",
              "default": {
                "maximum": "1",
                "minimum": "0"
              },
              "allOf": [
                {
                  "$ref": "#/definitions/RangedValue_for_Percent"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Percent": {
          "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "RangedValue_for_Percent": {
          "type": "object",
          "required": [
            "maximum",
            "minimum"
          ],
          "properties": {
            "maximum": {
              "$ref": "#/definitions/Percent"
            },
            "minimum": {
              "$ref": "#/definitions/Percent"
            }
          },
          "additionalProperties": false
        },
        "RangedValue_for_Uint128": {
          "type": "object",
          "required": [
            "maximum",
            "minimum"
          ],
          "properties": {
            "maximum": {
              "$ref": "#/definitions/Uint128"
            },
            "minimum": {
              "$ref": "#/definitions/Uint128"
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_state_params": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ContractStateParams",
      "description": "Contract parameters that could be adjusted in a transaction by the contract admin.",
      "type": "object",
      "required": [
        "minimum_pledge"
      ],
      "properties": {
        "interval_operating_cost": {
          "description": "Defines the allowed interval operating cost range of operators. default: 0 - 1'000'000'000'000'000 (1 Billion native tokens - the total supply)",
          "default": {
            "maximum": "1000000000000000",
            "minimum": "0"
          },
          "allOf": [
            {
              "$ref": "#/definitions/RangedValue_for_Uint128"
            }
          ]
        },
        "minimum_delegation": {
          "description": "Minimum amount a delegator must stake in orders for his delegation to get accepted.",
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "minimum_pledge": {
          "description": "Minimum amount a node must pledge to get into the system.",
          "allOf": [
            {
              "$ref": "#/definitions/Coin"
            }
          ]
        },
        "profit_margin": {
          "description": "Defines the allowed profit margin range of operators. default: 0% - 100%",
          "default": {
            "maximum": "1",
            "minimum": "0"
          },
          "allOf": [
            {
              "$ref": "#/definitions/RangedValue_for_Percent"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Percent": {
          "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "RangedValue_for_Percent": {
          "type": "object",
          "required": [
            "maximum",
            "minimum"
          ],
          "properties": {
            "maximum": {
              "$ref": "#/definitions/Percent"
            },
            "minimum": {
              "$ref": "#/definitions/Percent"
            }
          },
          "additionalProperties": false
        },
        "RangedValue_for_Uint128": {
          "type": "object",
          "required": [
            "maximum",
            "minimum"
          ],
          "properties": {
            "maximum": {
              "$ref": "#/definitions/Uint128"
            },
            "minimum": {
              "$ref": "#/definitions/Uint128"
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_unbonded_mix_node_information": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "UnbondedMixnodeResponse",
      "description": "Response containing basic information of an unbonded mixnode with the provided id.",
      "type": "object",
      "required": [
        "mix_id"
      ],
      "properties": {
        "mix_id": {
          "description": "Id of the requested mixnode.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "unbonded_info": {
          "description": "If there existed a mixnode with the provided id, this field contains its basic information.",
          "anyOf": [
            {
              "$ref": "#/definitions/UnbondedMixnode"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "UnbondedMixnode": {
          "description": "Basic information of a node that used to be part of the mix network but has already unbonded.",
          "type": "object",
          "required": [
            "identity_key",
            "owner",
            "unbonding_height"
          ],
          "properties": {
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            },
            "owner": {
              "description": "Address of the owner of this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Entity who bonded this mixnode on behalf of the owner. If exists, it's most likely the address of the vesting contract.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "unbonding_height": {
              "description": "Block height at which this mixnode has unbonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      }
    },
    "get_unbonded_mix_nodes": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedUnbondedMixnodesResponse",
      "description": "Response containing paged list of all mixnodes that have ever unbonded.",
      "type": "object",
      "required": [
        "nodes",
        "per_page"
      ],
      "properties": {
        "nodes": {
          "description": "The past ids of unbonded mixnodes alongside their basic information such as the owner or the identity key.",
          "type": "array",
          "items": {
            "type": "array",
            "items": [
              {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              {
                "$ref": "#/definitions/UnbondedMixnode"
              }
            ],
            "maxItems": 2,
            "minItems": 2
          }
        },
        "per_page": {
          "description": "Maximum number of entries that could be included in a response. `per_page <= nodes.len()`",
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        },
        "start_next_after": {
          "description": "Field indicating paging information for the following queries if the caller wishes to get further entries.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "UnbondedMixnode": {
          "description": "Basic information of a node that used to be part of the mix network but has already unbonded.",
          "type": "object",
          "required": [
            "identity_key",
            "owner",
            "unbonding_height"
          ],
          "properties": {
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            },
            "owner": {
              "description": "Address of the owner of this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Entity who bonded this mixnode on behalf of the owner. If exists, it's most likely the address of the vesting contract.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "unbonding_height": {
              "description": "Block height at which this mixnode has unbonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      }
    },
    "get_unbonded_mix_nodes_by_identity_key": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedUnbondedMixnodesResponse",
      "description": "Response containing paged list of all mixnodes that have ever unbonded.",
      "type": "object",
      "required": [
        "nodes",
        "per_page"
      ],
      "properties": {
        "nodes": {
          "description": "The past ids of unbonded mixnodes alongside their basic information such as the owner or the identity key.",
          "type": "array",
          "items": {
            "type": "array",
            "items": [
              {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              {
                "$ref": "#/definitions/UnbondedMixnode"
              }
            ],
            "maxItems": 2,
            "minItems": 2
          }
        },
        "per_page": {
          "description": "Maximum number of entries that could be included in a response. `per_page <= nodes.len()`",
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        },
        "start_next_after": {
          "description": "Field indicating paging information for the following queries if the caller wishes to get further entries.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "UnbondedMixnode": {
          "description": "Basic information of a node that used to be part of the mix network but has already unbonded.",
          "type": "object",
          "required": [
            "identity_key",
            "owner",
            "unbonding_height"
          ],
          "properties": {
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            },
            "owner": {
              "description": "Address of the owner of this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Entity who bonded this mixnode on behalf of the owner. If exists, it's most likely the address of the vesting contract.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "unbonding_height": {
              "description": "Block height at which this mixnode has unbonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      }
    },
    "get_unbonded_mix_nodes_by_owner": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedUnbondedMixnodesResponse",
      "description": "Response containing paged list of all mixnodes that have ever unbonded.",
      "type": "object",
      "required": [
        "nodes",
        "per_page"
      ],
      "properties": {
        "nodes": {
          "description": "The past ids of unbonded mixnodes alongside their basic information such as the owner or the identity key.",
          "type": "array",
          "items": {
            "type": "array",
            "items": [
              {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              {
                "$ref": "#/definitions/UnbondedMixnode"
              }
            ],
            "maxItems": 2,
            "minItems": 2
          }
        },
        "per_page": {
          "description": "Maximum number of entries that could be included in a response. `per_page <= nodes.len()`",
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        },
        "start_next_after": {
          "description": "Field indicating paging information for the following queries if the caller wishes to get further entries.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "UnbondedMixnode": {
          "description": "Basic information of a node that used to be part of the mix network but has already unbonded.",
          "type": "object",
          "required": [
            "identity_key",
            "owner",
            "unbonding_height"
          ],
          "properties": {
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            },
            "owner": {
              "description": "Address of the owner of this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Entity who bonded this mixnode on behalf of the owner. If exists, it's most likely the address of the vesting contract.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "unbonding_height": {
              "description": "Block height at which this mixnode has unbonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      }
    },
    "get_unbonded_nym_node": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "UnbondedNodeResponse",
      "description": "Response containing basic information of an unbonded nym-node with the provided id.",
      "type": "object",
      "required": [
        "node_id"
      ],
      "properties": {
        "details": {
          "description": "If there existed a nym-node with the provided id, this field contains its basic information.",
          "anyOf": [
            {
              "$ref": "#/definitions/UnbondedNymNode"
            },
            {
              "type": "null"
            }
          ]
        },
        "node_id": {
          "description": "Id of the requested nym-node.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "UnbondedNymNode": {
          "description": "Basic information of a node that used to be part of the nym network but has already unbonded.",
          "type": "object",
          "required": [
            "identity_key",
            "node_id",
            "owner",
            "unbonding_height"
          ],
          "properties": {
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            },
            "node_id": {
              "description": "NodeId assigned to this node.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "owner": {
              "description": "Address of the owner of this nym node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "unbonding_height": {
              "description": "Block height at which this nym node has unbonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      }
    },
    "get_unbonded_nym_nodes_by_identity_key_paged": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedUnbondedNymNodesResponse",
      "description": "Response containing paged list of all nym-nodes that have ever unbonded.",
      "type": "object",
      "required": [
        "nodes"
      ],
      "properties": {
        "nodes": {
          "description": "Basic information of the node such as the owner or the identity key.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UnbondedNymNode"
          }
        },
        "start_next_after": {
          "description": "Field indicating paging information for the following queries if the caller wishes to get further entries.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "UnbondedNymNode": {
          "description": "Basic information of a node that used to be part of the nym network but has already unbonded.",
          "type": "object",
          "required": [
            "identity_key",
            "node_id",
            "owner",
            "unbonding_height"
          ],
          "properties": {
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            },
            "node_id": {
              "description": "NodeId assigned to this node.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "owner": {
              "description": "Address of the owner of this nym node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "unbonding_height": {
              "description": "Block height at which this nym node has unbonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      }
    },
    "get_unbonded_nym_nodes_by_owner_paged": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedUnbondedNymNodesResponse",
      "description": "Response containing paged list of all nym-nodes that have ever unbonded.",
      "type": "object",
      "required": [
        "nodes"
      ],
      "properties": {
        "nodes": {
          "description": "Basic information of the node such as the owner or the identity key.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UnbondedNymNode"
          }
        },
        "start_next_after": {
          "description": "Field indicating paging information for the following queries if the caller wishes to get further entries.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "UnbondedNymNode": {
          "description": "Basic information of a node that used to be part of the nym network but has already unbonded.",
          "type": "object",
          "required": [
            "identity_key",
            "node_id",
            "owner",
            "unbonding_height"
          ],
          "properties": {
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            },
            "node_id": {
              "description": "NodeId assigned to this node.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "owner": {
              "description": "Address of the owner of this nym node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "unbonding_height": {
              "description": "Block height at which this nym node has unbonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      }
    },
    "get_unbonded_nym_nodes_paged": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedUnbondedNymNodesResponse",
      "description": "Response containing paged list of all nym-nodes that have ever unbonded.",
      "type": "object",
      "required": [
        "nodes"
      ],
      "properties": {
        "nodes": {
          "description": "Basic information of the node such as the owner or the identity key.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UnbondedNymNode"
          }
        },
        "start_next_after": {
          "description": "Field indicating paging information for the following queries if the caller wishes to get further entries.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "UnbondedNymNode": {
          "description": "Basic information of a node that used to be part of the nym network but has already unbonded.",
          "type": "object",
          "required": [
            "identity_key",
            "node_id",
            "owner",
            "unbonding_height"
          ],
          "properties": {
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            },
            "node_id": {
              "description": "NodeId assigned to this node.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "owner": {
              "description": "Address of the owner of this nym node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "unbonding_height": {
              "description": "Block height at which this nym node has unbonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      }
    }
  }
}
