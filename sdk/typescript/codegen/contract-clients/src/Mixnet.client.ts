/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.13.3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { ICosmWasmClient, ISigningCosmWasmClient } from "./baseClient";
import { StdFee } from "@interchainjs/types";
import { Decimal, Percent, Uint128, InstantiateMsg, Duration, InitialRewardingParams, RewardedSetParams, RangedValueForUint128, RangedValueForPercent, VersionScoreFormulaParams, OutdatedVersionWeights, ExecuteMsg, Role, MessageSignature, ContractStateParamsUpdate, ConfigScoreParamsUpdate, DelegationsParams, Coin, OperatorsParamsUpdate, ActiveSetUpdate, IntervalRewardingParamsUpdate, RoleAssignment, NodeCostParams, MixNode, MixNodeConfigUpdate, Gateway, GatewayConfigUpdate, NymNode, NodeConfigUpdate, NodeRewardingParameters, QueryMsg, MigrateMsg, AdminResponse, Addr, PagedAllDelegationsResponse, Delegation, MixnodeDetailsByIdentityResponse, MixNodeDetails, MixNodeBond, PendingMixNodeChanges, NodeRewarding, ContractVersion, ContractBuildInformation, CurrentIntervalResponse, Interval, CurrentNymNodeVersionResponse, HistoricalNymNodeVersionEntry, HistoricalNymNodeVersion, TotalVersionDifference, NodeDelegationResponse, PagedDelegatorDelegationsResponse, EpochState, EpochStatus, EstimatedCurrentEpochRewardResponse, GatewayBondResponse, GatewayBond, PagedGatewayResponse, KeyRotationIdResponse, KeyRotationState, PagedMixnodeBondsResponse, PagedMixnodesDetailsResponse, MixnodeDetailsResponse, MixnodeRewardingDetailsResponse, PagedNodeDelegationsResponse, NodeRewardingDetailsResponse, StakeSaturationResponse, NumberOfPendingEventsResponse, PagedNymNodeBondsResponse, NymNodeBond, NodeDetailsResponse, NymNodeDetails, PendingNodeChanges, NodeDetailsByIdentityResponse, NymNodeVersionHistoryResponse, PagedNymNodeDetailsResponse, GatewayOwnershipResponse, MixOwnershipResponse, NodeOwnershipResponse, PendingRewardResponse, PendingEpochEventKind, PendingEpochEventResponse, PendingEpochEventData, PendingEpochEventsResponse, PendingEpochEvent, PendingIntervalEventKind, PendingIntervalEventResponse, PendingIntervalEventData, PendingIntervalEventsResponse, PendingIntervalEvent, PreassignedGatewayIdsResponse, PreassignedId, RolesMetadataResponse, RewardedSetMetadata, RoleMetadata, RewardingParams, IntervalRewardParams, String, EpochAssignmentResponse, Uint32, MixStakeSaturationResponse, ContractState, ContractStateParams, ConfigScoreParams, OperatorsParams, UnbondedMixnodeResponse, UnbondedMixnode, PagedUnbondedMixnodesResponse, UnbondedNodeResponse, UnbondedNymNode, PagedUnbondedNymNodesResponse } from "./Mixnet.types";
export interface MixnetReadOnlyInterface {
  contractAddress: string;
  admin: () => Promise<AdminResponse>;
  getContractVersion: () => Promise<ContractBuildInformation>;
  getCw2ContractVersion: () => Promise<GetCw2ContractVersionResponse>;
  getRewardingValidatorAddress: () => Promise<String>;
  getStateParams: () => Promise<ContractStateParams>;
  getState: () => Promise<ContractState>;
  getCurrentNymNodeVersion: () => Promise<CurrentNymNodeVersionResponse>;
  getNymNodeVersionHistory: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<NymNodeVersionHistoryResponse>;
  getRewardingParams: () => Promise<RewardingParams>;
  getEpochStatus: () => Promise<EpochStatus>;
  getCurrentIntervalDetails: () => Promise<CurrentIntervalResponse>;
  getMixNodeBonds: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<PagedMixnodeBondsResponse>;
  getMixNodesDetailed: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<PagedMixnodesDetailsResponse>;
  getUnbondedMixNodes: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<PagedUnbondedMixnodesResponse>;
  getUnbondedMixNodesByOwner: ({
    limit,
    owner,
    startAfter
  }: {
    limit?: number;
    owner: string;
    startAfter?: number;
  }) => Promise<PagedUnbondedMixnodesResponse>;
  getUnbondedMixNodesByIdentityKey: ({
    identityKey,
    limit,
    startAfter
  }: {
    identityKey: string;
    limit?: number;
    startAfter?: number;
  }) => Promise<PagedUnbondedMixnodesResponse>;
  getOwnedMixnode: ({
    address
  }: {
    address: string;
  }) => Promise<MixOwnershipResponse>;
  getMixnodeDetails: ({
    mixId
  }: {
    mixId: number;
  }) => Promise<MixnodeDetailsResponse>;
  getMixnodeRewardingDetails: ({
    mixId
  }: {
    mixId: number;
  }) => Promise<MixnodeRewardingDetailsResponse>;
  getStakeSaturation: ({
    mixId
  }: {
    mixId: number;
  }) => Promise<MixStakeSaturationResponse>;
  getUnbondedMixNodeInformation: ({
    mixId
  }: {
    mixId: number;
  }) => Promise<UnbondedMixnodeResponse>;
  getBondedMixnodeDetailsByIdentity: ({
    mixIdentity
  }: {
    mixIdentity: string;
  }) => Promise<MixnodeDetailsByIdentityResponse>;
  getGateways: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<PagedGatewayResponse>;
  getGatewayBond: ({
    identity
  }: {
    identity: string;
  }) => Promise<GatewayBondResponse>;
  getOwnedGateway: ({
    address
  }: {
    address: string;
  }) => Promise<GatewayOwnershipResponse>;
  getPreassignedGatewayIds: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<PreassignedGatewayIdsResponse>;
  getNymNodeBondsPaged: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<PagedNymNodeBondsResponse>;
  getNymNodesDetailedPaged: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<PagedNymNodeDetailsResponse>;
  getUnbondedNymNode: ({
    nodeId
  }: {
    nodeId: number;
  }) => Promise<UnbondedNodeResponse>;
  getUnbondedNymNodesPaged: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<PagedUnbondedNymNodesResponse>;
  getUnbondedNymNodesByOwnerPaged: ({
    limit,
    owner,
    startAfter
  }: {
    limit?: number;
    owner: string;
    startAfter?: number;
  }) => Promise<PagedUnbondedNymNodesResponse>;
  getUnbondedNymNodesByIdentityKeyPaged: ({
    identityKey,
    limit,
    startAfter
  }: {
    identityKey: string;
    limit?: number;
    startAfter?: number;
  }) => Promise<PagedUnbondedNymNodesResponse>;
  getOwnedNymNode: ({
    address
  }: {
    address: string;
  }) => Promise<NodeOwnershipResponse>;
  getNymNodeDetails: ({
    nodeId
  }: {
    nodeId: number;
  }) => Promise<NodeDetailsResponse>;
  getNymNodeDetailsByIdentityKey: ({
    nodeIdentity
  }: {
    nodeIdentity: string;
  }) => Promise<NodeDetailsByIdentityResponse>;
  getNodeRewardingDetails: ({
    nodeId
  }: {
    nodeId: number;
  }) => Promise<NodeRewardingDetailsResponse>;
  getNodeStakeSaturation: ({
    nodeId
  }: {
    nodeId: number;
  }) => Promise<StakeSaturationResponse>;
  getRoleAssignment: ({
    role
  }: {
    role: Role;
  }) => Promise<EpochAssignmentResponse>;
  getRewardedSetMetadata: () => Promise<RolesMetadataResponse>;
  getNodeDelegations: ({
    limit,
    nodeId,
    startAfter
  }: {
    limit?: number;
    nodeId: number;
    startAfter?: string;
  }) => Promise<PagedNodeDelegationsResponse>;
  getDelegatorDelegations: ({
    delegator,
    limit,
    startAfter
  }: {
    delegator: string;
    limit?: number;
    startAfter?: number[][];
  }) => Promise<PagedDelegatorDelegationsResponse>;
  getDelegationDetails: ({
    delegator,
    nodeId,
    proxy
  }: {
    delegator: string;
    nodeId: number;
    proxy?: string;
  }) => Promise<NodeDelegationResponse>;
  getAllDelegations: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number[][];
  }) => Promise<PagedAllDelegationsResponse>;
  getPendingOperatorReward: ({
    address
  }: {
    address: string;
  }) => Promise<PendingRewardResponse>;
  getPendingNodeOperatorReward: ({
    nodeId
  }: {
    nodeId: number;
  }) => Promise<PendingRewardResponse>;
  getPendingDelegatorReward: ({
    address,
    nodeId,
    proxy
  }: {
    address: string;
    nodeId: number;
    proxy?: string;
  }) => Promise<PendingRewardResponse>;
  getEstimatedCurrentEpochOperatorReward: ({
    estimatedPerformance,
    estimatedWork,
    nodeId
  }: {
    estimatedPerformance: Percent;
    estimatedWork?: Decimal;
    nodeId: number;
  }) => Promise<EstimatedCurrentEpochRewardResponse>;
  getEstimatedCurrentEpochDelegatorReward: ({
    address,
    estimatedPerformance,
    estimatedWork,
    nodeId
  }: {
    address: string;
    estimatedPerformance: Percent;
    estimatedWork?: Decimal;
    nodeId: number;
  }) => Promise<EstimatedCurrentEpochRewardResponse>;
  getPendingEpochEvents: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<PendingEpochEventsResponse>;
  getPendingIntervalEvents: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<PendingIntervalEventsResponse>;
  getPendingEpochEvent: ({
    eventId
  }: {
    eventId: number;
  }) => Promise<PendingEpochEventResponse>;
  getPendingIntervalEvent: ({
    eventId
  }: {
    eventId: number;
  }) => Promise<PendingIntervalEventResponse>;
  getNumberOfPendingEvents: () => Promise<NumberOfPendingEventsResponse>;
  getSigningNonce: ({
    address
  }: {
    address: string;
  }) => Promise<Uint32>;
  getKeyRotationState: () => Promise<KeyRotationState>;
  getKeyRotationId: () => Promise<KeyRotationIdResponse>;
}
export class MixnetQueryClient implements MixnetReadOnlyInterface {
  client: ICosmWasmClient;
  contractAddress: string;
  constructor(client: ICosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.admin = this.admin.bind(this);
    this.getContractVersion = this.getContractVersion.bind(this);
    this.getCw2ContractVersion = this.getCw2ContractVersion.bind(this);
    this.getRewardingValidatorAddress = this.getRewardingValidatorAddress.bind(this);
    this.getStateParams = this.getStateParams.bind(this);
    this.getState = this.getState.bind(this);
    this.getCurrentNymNodeVersion = this.getCurrentNymNodeVersion.bind(this);
    this.getNymNodeVersionHistory = this.getNymNodeVersionHistory.bind(this);
    this.getRewardingParams = this.getRewardingParams.bind(this);
    this.getEpochStatus = this.getEpochStatus.bind(this);
    this.getCurrentIntervalDetails = this.getCurrentIntervalDetails.bind(this);
    this.getMixNodeBonds = this.getMixNodeBonds.bind(this);
    this.getMixNodesDetailed = this.getMixNodesDetailed.bind(this);
    this.getUnbondedMixNodes = this.getUnbondedMixNodes.bind(this);
    this.getUnbondedMixNodesByOwner = this.getUnbondedMixNodesByOwner.bind(this);
    this.getUnbondedMixNodesByIdentityKey = this.getUnbondedMixNodesByIdentityKey.bind(this);
    this.getOwnedMixnode = this.getOwnedMixnode.bind(this);
    this.getMixnodeDetails = this.getMixnodeDetails.bind(this);
    this.getMixnodeRewardingDetails = this.getMixnodeRewardingDetails.bind(this);
    this.getStakeSaturation = this.getStakeSaturation.bind(this);
    this.getUnbondedMixNodeInformation = this.getUnbondedMixNodeInformation.bind(this);
    this.getBondedMixnodeDetailsByIdentity = this.getBondedMixnodeDetailsByIdentity.bind(this);
    this.getGateways = this.getGateways.bind(this);
    this.getGatewayBond = this.getGatewayBond.bind(this);
    this.getOwnedGateway = this.getOwnedGateway.bind(this);
    this.getPreassignedGatewayIds = this.getPreassignedGatewayIds.bind(this);
    this.getNymNodeBondsPaged = this.getNymNodeBondsPaged.bind(this);
    this.getNymNodesDetailedPaged = this.getNymNodesDetailedPaged.bind(this);
    this.getUnbondedNymNode = this.getUnbondedNymNode.bind(this);
    this.getUnbondedNymNodesPaged = this.getUnbondedNymNodesPaged.bind(this);
    this.getUnbondedNymNodesByOwnerPaged = this.getUnbondedNymNodesByOwnerPaged.bind(this);
    this.getUnbondedNymNodesByIdentityKeyPaged = this.getUnbondedNymNodesByIdentityKeyPaged.bind(this);
    this.getOwnedNymNode = this.getOwnedNymNode.bind(this);
    this.getNymNodeDetails = this.getNymNodeDetails.bind(this);
    this.getNymNodeDetailsByIdentityKey = this.getNymNodeDetailsByIdentityKey.bind(this);
    this.getNodeRewardingDetails = this.getNodeRewardingDetails.bind(this);
    this.getNodeStakeSaturation = this.getNodeStakeSaturation.bind(this);
    this.getRoleAssignment = this.getRoleAssignment.bind(this);
    this.getRewardedSetMetadata = this.getRewardedSetMetadata.bind(this);
    this.getNodeDelegations = this.getNodeDelegations.bind(this);
    this.getDelegatorDelegations = this.getDelegatorDelegations.bind(this);
    this.getDelegationDetails = this.getDelegationDetails.bind(this);
    this.getAllDelegations = this.getAllDelegations.bind(this);
    this.getPendingOperatorReward = this.getPendingOperatorReward.bind(this);
    this.getPendingNodeOperatorReward = this.getPendingNodeOperatorReward.bind(this);
    this.getPendingDelegatorReward = this.getPendingDelegatorReward.bind(this);
    this.getEstimatedCurrentEpochOperatorReward = this.getEstimatedCurrentEpochOperatorReward.bind(this);
    this.getEstimatedCurrentEpochDelegatorReward = this.getEstimatedCurrentEpochDelegatorReward.bind(this);
    this.getPendingEpochEvents = this.getPendingEpochEvents.bind(this);
    this.getPendingIntervalEvents = this.getPendingIntervalEvents.bind(this);
    this.getPendingEpochEvent = this.getPendingEpochEvent.bind(this);
    this.getPendingIntervalEvent = this.getPendingIntervalEvent.bind(this);
    this.getNumberOfPendingEvents = this.getNumberOfPendingEvents.bind(this);
    this.getSigningNonce = this.getSigningNonce.bind(this);
    this.getKeyRotationState = this.getKeyRotationState.bind(this);
    this.getKeyRotationId = this.getKeyRotationId.bind(this);
  }
  admin = async (): Promise<AdminResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      admin: {}
    });
  };
  getContractVersion = async (): Promise<ContractBuildInformation> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_contract_version: {}
    });
  };
  getCw2ContractVersion = async (): Promise<GetCw2ContractVersionResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_cw2_contract_version: {}
    });
  };
  getRewardingValidatorAddress = async (): Promise<String> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_rewarding_validator_address: {}
    });
  };
  getStateParams = async (): Promise<ContractStateParams> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_state_params: {}
    });
  };
  getState = async (): Promise<ContractState> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_state: {}
    });
  };
  getCurrentNymNodeVersion = async (): Promise<CurrentNymNodeVersionResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_current_nym_node_version: {}
    });
  };
  getNymNodeVersionHistory = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<NymNodeVersionHistoryResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_nym_node_version_history: {
        limit,
        start_after: startAfter
      }
    });
  };
  getRewardingParams = async (): Promise<RewardingParams> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_rewarding_params: {}
    });
  };
  getEpochStatus = async (): Promise<EpochStatus> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_epoch_status: {}
    });
  };
  getCurrentIntervalDetails = async (): Promise<CurrentIntervalResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_current_interval_details: {}
    });
  };
  getMixNodeBonds = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<PagedMixnodeBondsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_mix_node_bonds: {
        limit,
        start_after: startAfter
      }
    });
  };
  getMixNodesDetailed = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<PagedMixnodesDetailsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_mix_nodes_detailed: {
        limit,
        start_after: startAfter
      }
    });
  };
  getUnbondedMixNodes = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<PagedUnbondedMixnodesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_unbonded_mix_nodes: {
        limit,
        start_after: startAfter
      }
    });
  };
  getUnbondedMixNodesByOwner = async ({
    limit,
    owner,
    startAfter
  }: {
    limit?: number;
    owner: string;
    startAfter?: number;
  }): Promise<PagedUnbondedMixnodesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_unbonded_mix_nodes_by_owner: {
        limit,
        owner,
        start_after: startAfter
      }
    });
  };
  getUnbondedMixNodesByIdentityKey = async ({
    identityKey,
    limit,
    startAfter
  }: {
    identityKey: string;
    limit?: number;
    startAfter?: number;
  }): Promise<PagedUnbondedMixnodesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_unbonded_mix_nodes_by_identity_key: {
        identity_key: identityKey,
        limit,
        start_after: startAfter
      }
    });
  };
  getOwnedMixnode = async ({
    address
  }: {
    address: string;
  }): Promise<MixOwnershipResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_owned_mixnode: {
        address
      }
    });
  };
  getMixnodeDetails = async ({
    mixId
  }: {
    mixId: number;
  }): Promise<MixnodeDetailsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_mixnode_details: {
        mix_id: mixId
      }
    });
  };
  getMixnodeRewardingDetails = async ({
    mixId
  }: {
    mixId: number;
  }): Promise<MixnodeRewardingDetailsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_mixnode_rewarding_details: {
        mix_id: mixId
      }
    });
  };
  getStakeSaturation = async ({
    mixId
  }: {
    mixId: number;
  }): Promise<MixStakeSaturationResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_stake_saturation: {
        mix_id: mixId
      }
    });
  };
  getUnbondedMixNodeInformation = async ({
    mixId
  }: {
    mixId: number;
  }): Promise<UnbondedMixnodeResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_unbonded_mix_node_information: {
        mix_id: mixId
      }
    });
  };
  getBondedMixnodeDetailsByIdentity = async ({
    mixIdentity
  }: {
    mixIdentity: string;
  }): Promise<MixnodeDetailsByIdentityResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_bonded_mixnode_details_by_identity: {
        mix_identity: mixIdentity
      }
    });
  };
  getGateways = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<PagedGatewayResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_gateways: {
        limit,
        start_after: startAfter
      }
    });
  };
  getGatewayBond = async ({
    identity
  }: {
    identity: string;
  }): Promise<GatewayBondResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_gateway_bond: {
        identity
      }
    });
  };
  getOwnedGateway = async ({
    address
  }: {
    address: string;
  }): Promise<GatewayOwnershipResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_owned_gateway: {
        address
      }
    });
  };
  getPreassignedGatewayIds = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<PreassignedGatewayIdsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_preassigned_gateway_ids: {
        limit,
        start_after: startAfter
      }
    });
  };
  getNymNodeBondsPaged = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<PagedNymNodeBondsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_nym_node_bonds_paged: {
        limit,
        start_after: startAfter
      }
    });
  };
  getNymNodesDetailedPaged = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<PagedNymNodeDetailsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_nym_nodes_detailed_paged: {
        limit,
        start_after: startAfter
      }
    });
  };
  getUnbondedNymNode = async ({
    nodeId
  }: {
    nodeId: number;
  }): Promise<UnbondedNodeResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_unbonded_nym_node: {
        node_id: nodeId
      }
    });
  };
  getUnbondedNymNodesPaged = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<PagedUnbondedNymNodesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_unbonded_nym_nodes_paged: {
        limit,
        start_after: startAfter
      }
    });
  };
  getUnbondedNymNodesByOwnerPaged = async ({
    limit,
    owner,
    startAfter
  }: {
    limit?: number;
    owner: string;
    startAfter?: number;
  }): Promise<PagedUnbondedNymNodesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_unbonded_nym_nodes_by_owner_paged: {
        limit,
        owner,
        start_after: startAfter
      }
    });
  };
  getUnbondedNymNodesByIdentityKeyPaged = async ({
    identityKey,
    limit,
    startAfter
  }: {
    identityKey: string;
    limit?: number;
    startAfter?: number;
  }): Promise<PagedUnbondedNymNodesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_unbonded_nym_nodes_by_identity_key_paged: {
        identity_key: identityKey,
        limit,
        start_after: startAfter
      }
    });
  };
  getOwnedNymNode = async ({
    address
  }: {
    address: string;
  }): Promise<NodeOwnershipResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_owned_nym_node: {
        address
      }
    });
  };
  getNymNodeDetails = async ({
    nodeId
  }: {
    nodeId: number;
  }): Promise<NodeDetailsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_nym_node_details: {
        node_id: nodeId
      }
    });
  };
  getNymNodeDetailsByIdentityKey = async ({
    nodeIdentity
  }: {
    nodeIdentity: string;
  }): Promise<NodeDetailsByIdentityResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_nym_node_details_by_identity_key: {
        node_identity: nodeIdentity
      }
    });
  };
  getNodeRewardingDetails = async ({
    nodeId
  }: {
    nodeId: number;
  }): Promise<NodeRewardingDetailsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_node_rewarding_details: {
        node_id: nodeId
      }
    });
  };
  getNodeStakeSaturation = async ({
    nodeId
  }: {
    nodeId: number;
  }): Promise<StakeSaturationResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_node_stake_saturation: {
        node_id: nodeId
      }
    });
  };
  getRoleAssignment = async ({
    role
  }: {
    role: Role;
  }): Promise<EpochAssignmentResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_role_assignment: {
        role
      }
    });
  };
  getRewardedSetMetadata = async (): Promise<RolesMetadataResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_rewarded_set_metadata: {}
    });
  };
  getNodeDelegations = async ({
    limit,
    nodeId,
    startAfter
  }: {
    limit?: number;
    nodeId: number;
    startAfter?: string;
  }): Promise<PagedNodeDelegationsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_node_delegations: {
        limit,
        node_id: nodeId,
        start_after: startAfter
      }
    });
  };
  getDelegatorDelegations = async ({
    delegator,
    limit,
    startAfter
  }: {
    delegator: string;
    limit?: number;
    startAfter?: number[][];
  }): Promise<PagedDelegatorDelegationsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_delegator_delegations: {
        delegator,
        limit,
        start_after: startAfter
      }
    });
  };
  getDelegationDetails = async ({
    delegator,
    nodeId,
    proxy
  }: {
    delegator: string;
    nodeId: number;
    proxy?: string;
  }): Promise<NodeDelegationResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_delegation_details: {
        delegator,
        node_id: nodeId,
        proxy
      }
    });
  };
  getAllDelegations = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number[][];
  }): Promise<PagedAllDelegationsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_all_delegations: {
        limit,
        start_after: startAfter
      }
    });
  };
  getPendingOperatorReward = async ({
    address
  }: {
    address: string;
  }): Promise<PendingRewardResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_pending_operator_reward: {
        address
      }
    });
  };
  getPendingNodeOperatorReward = async ({
    nodeId
  }: {
    nodeId: number;
  }): Promise<PendingRewardResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_pending_node_operator_reward: {
        node_id: nodeId
      }
    });
  };
  getPendingDelegatorReward = async ({
    address,
    nodeId,
    proxy
  }: {
    address: string;
    nodeId: number;
    proxy?: string;
  }): Promise<PendingRewardResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_pending_delegator_reward: {
        address,
        node_id: nodeId,
        proxy
      }
    });
  };
  getEstimatedCurrentEpochOperatorReward = async ({
    estimatedPerformance,
    estimatedWork,
    nodeId
  }: {
    estimatedPerformance: Percent;
    estimatedWork?: Decimal;
    nodeId: number;
  }): Promise<EstimatedCurrentEpochRewardResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_estimated_current_epoch_operator_reward: {
        estimated_performance: estimatedPerformance,
        estimated_work: estimatedWork,
        node_id: nodeId
      }
    });
  };
  getEstimatedCurrentEpochDelegatorReward = async ({
    address,
    estimatedPerformance,
    estimatedWork,
    nodeId
  }: {
    address: string;
    estimatedPerformance: Percent;
    estimatedWork?: Decimal;
    nodeId: number;
  }): Promise<EstimatedCurrentEpochRewardResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_estimated_current_epoch_delegator_reward: {
        address,
        estimated_performance: estimatedPerformance,
        estimated_work: estimatedWork,
        node_id: nodeId
      }
    });
  };
  getPendingEpochEvents = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<PendingEpochEventsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_pending_epoch_events: {
        limit,
        start_after: startAfter
      }
    });
  };
  getPendingIntervalEvents = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<PendingIntervalEventsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_pending_interval_events: {
        limit,
        start_after: startAfter
      }
    });
  };
  getPendingEpochEvent = async ({
    eventId
  }: {
    eventId: number;
  }): Promise<PendingEpochEventResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_pending_epoch_event: {
        event_id: eventId
      }
    });
  };
  getPendingIntervalEvent = async ({
    eventId
  }: {
    eventId: number;
  }): Promise<PendingIntervalEventResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_pending_interval_event: {
        event_id: eventId
      }
    });
  };
  getNumberOfPendingEvents = async (): Promise<NumberOfPendingEventsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_number_of_pending_events: {}
    });
  };
  getSigningNonce = async ({
    address
  }: {
    address: string;
  }): Promise<Uint32> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_signing_nonce: {
        address
      }
    });
  };
  getKeyRotationState = async (): Promise<KeyRotationState> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_key_rotation_state: {}
    });
  };
  getKeyRotationId = async (): Promise<KeyRotationIdResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_key_rotation_id: {}
    });
  };
}
export interface MixnetInterface extends MixnetReadOnlyInterface {
  contractAddress: string;
  sender: string;
  updateAdmin: ({
    admin
  }: {
    admin: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  updateRewardingValidatorAddress: ({
    address
  }: {
    address: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  updateContractStateParams: ({
    update
  }: {
    update: ContractStateParamsUpdate;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  updateCurrentNymNodeSemver: ({
    currentVersion
  }: {
    currentVersion: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  updateActiveSetDistribution: ({
    forceImmediately,
    update
  }: {
    forceImmediately: boolean;
    update: ActiveSetUpdate;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  updateRewardingParams: ({
    forceImmediately,
    updatedParams
  }: {
    forceImmediately: boolean;
    updatedParams: IntervalRewardingParamsUpdate;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  updateIntervalConfig: ({
    epochDurationSecs,
    epochsInInterval,
    forceImmediately
  }: {
    epochDurationSecs: number;
    epochsInInterval: number;
    forceImmediately: boolean;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  beginEpochTransition: (fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  reconcileEpochEvents: ({
    limit
  }: {
    limit?: number;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  assignRoles: ({
    assignment
  }: {
    assignment: RoleAssignment;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  bondMixnode: ({
    costParams,
    mixNode,
    ownerSignature
  }: {
    costParams: NodeCostParams;
    mixNode: MixNode;
    ownerSignature: MessageSignature;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  bondMixnodeOnBehalf: ({
    costParams,
    mixNode,
    owner,
    ownerSignature
  }: {
    costParams: NodeCostParams;
    mixNode: MixNode;
    owner: string;
    ownerSignature: MessageSignature;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  pledgeMore: (fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  pledgeMoreOnBehalf: ({
    owner
  }: {
    owner: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  decreasePledge: ({
    decreaseBy
  }: {
    decreaseBy: Coin;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  decreasePledgeOnBehalf: ({
    decreaseBy,
    owner
  }: {
    decreaseBy: Coin;
    owner: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  unbondMixnode: (fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  unbondMixnodeOnBehalf: ({
    owner
  }: {
    owner: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  updateCostParams: ({
    newCosts
  }: {
    newCosts: NodeCostParams;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  updateMixnodeCostParamsOnBehalf: ({
    newCosts,
    owner
  }: {
    newCosts: NodeCostParams;
    owner: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  updateMixnodeConfig: ({
    newConfig
  }: {
    newConfig: MixNodeConfigUpdate;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  updateMixnodeConfigOnBehalf: ({
    newConfig,
    owner
  }: {
    newConfig: MixNodeConfigUpdate;
    owner: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  migrateMixnode: (fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  bondGateway: ({
    gateway,
    ownerSignature
  }: {
    gateway: Gateway;
    ownerSignature: MessageSignature;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  bondGatewayOnBehalf: ({
    gateway,
    owner,
    ownerSignature
  }: {
    gateway: Gateway;
    owner: string;
    ownerSignature: MessageSignature;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  unbondGateway: (fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  unbondGatewayOnBehalf: ({
    owner
  }: {
    owner: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  updateGatewayConfig: ({
    newConfig
  }: {
    newConfig: GatewayConfigUpdate;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  updateGatewayConfigOnBehalf: ({
    newConfig,
    owner
  }: {
    newConfig: GatewayConfigUpdate;
    owner: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  migrateGateway: ({
    costParams
  }: {
    costParams?: NodeCostParams;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  bondNymNode: ({
    costParams,
    node,
    ownerSignature
  }: {
    costParams: NodeCostParams;
    node: NymNode;
    ownerSignature: MessageSignature;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  unbondNymNode: (fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  updateNodeConfig: ({
    update
  }: {
    update: NodeConfigUpdate;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  delegate: ({
    nodeId
  }: {
    nodeId: number;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  delegateToMixnodeOnBehalf: ({
    delegate,
    mixId
  }: {
    delegate: string;
    mixId: number;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  undelegate: ({
    nodeId
  }: {
    nodeId: number;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  undelegateFromMixnodeOnBehalf: ({
    delegate,
    mixId
  }: {
    delegate: string;
    mixId: number;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  rewardNode: ({
    nodeId,
    params
  }: {
    nodeId: number;
    params: NodeRewardingParameters;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  withdrawOperatorReward: (fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  withdrawOperatorRewardOnBehalf: ({
    owner
  }: {
    owner: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  withdrawDelegatorReward: ({
    nodeId
  }: {
    nodeId: number;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  withdrawDelegatorRewardOnBehalf: ({
    mixId,
    owner
  }: {
    mixId: number;
    owner: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  migrateVestedMixNode: (fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  migrateVestedDelegation: ({
    mixId
  }: {
    mixId: number;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
}
export class MixnetClient extends MixnetQueryClient implements MixnetInterface {
  client: ISigningCosmWasmClient;
  sender: string;
  contractAddress: string;
  constructor(client: ISigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.updateAdmin = this.updateAdmin.bind(this);
    this.updateRewardingValidatorAddress = this.updateRewardingValidatorAddress.bind(this);
    this.updateContractStateParams = this.updateContractStateParams.bind(this);
    this.updateCurrentNymNodeSemver = this.updateCurrentNymNodeSemver.bind(this);
    this.updateActiveSetDistribution = this.updateActiveSetDistribution.bind(this);
    this.updateRewardingParams = this.updateRewardingParams.bind(this);
    this.updateIntervalConfig = this.updateIntervalConfig.bind(this);
    this.beginEpochTransition = this.beginEpochTransition.bind(this);
    this.reconcileEpochEvents = this.reconcileEpochEvents.bind(this);
    this.assignRoles = this.assignRoles.bind(this);
    this.bondMixnode = this.bondMixnode.bind(this);
    this.bondMixnodeOnBehalf = this.bondMixnodeOnBehalf.bind(this);
    this.pledgeMore = this.pledgeMore.bind(this);
    this.pledgeMoreOnBehalf = this.pledgeMoreOnBehalf.bind(this);
    this.decreasePledge = this.decreasePledge.bind(this);
    this.decreasePledgeOnBehalf = this.decreasePledgeOnBehalf.bind(this);
    this.unbondMixnode = this.unbondMixnode.bind(this);
    this.unbondMixnodeOnBehalf = this.unbondMixnodeOnBehalf.bind(this);
    this.updateCostParams = this.updateCostParams.bind(this);
    this.updateMixnodeCostParamsOnBehalf = this.updateMixnodeCostParamsOnBehalf.bind(this);
    this.updateMixnodeConfig = this.updateMixnodeConfig.bind(this);
    this.updateMixnodeConfigOnBehalf = this.updateMixnodeConfigOnBehalf.bind(this);
    this.migrateMixnode = this.migrateMixnode.bind(this);
    this.bondGateway = this.bondGateway.bind(this);
    this.bondGatewayOnBehalf = this.bondGatewayOnBehalf.bind(this);
    this.unbondGateway = this.unbondGateway.bind(this);
    this.unbondGatewayOnBehalf = this.unbondGatewayOnBehalf.bind(this);
    this.updateGatewayConfig = this.updateGatewayConfig.bind(this);
    this.updateGatewayConfigOnBehalf = this.updateGatewayConfigOnBehalf.bind(this);
    this.migrateGateway = this.migrateGateway.bind(this);
    this.bondNymNode = this.bondNymNode.bind(this);
    this.unbondNymNode = this.unbondNymNode.bind(this);
    this.updateNodeConfig = this.updateNodeConfig.bind(this);
    this.delegate = this.delegate.bind(this);
    this.delegateToMixnodeOnBehalf = this.delegateToMixnodeOnBehalf.bind(this);
    this.undelegate = this.undelegate.bind(this);
    this.undelegateFromMixnodeOnBehalf = this.undelegateFromMixnodeOnBehalf.bind(this);
    this.rewardNode = this.rewardNode.bind(this);
    this.withdrawOperatorReward = this.withdrawOperatorReward.bind(this);
    this.withdrawOperatorRewardOnBehalf = this.withdrawOperatorRewardOnBehalf.bind(this);
    this.withdrawDelegatorReward = this.withdrawDelegatorReward.bind(this);
    this.withdrawDelegatorRewardOnBehalf = this.withdrawDelegatorRewardOnBehalf.bind(this);
    this.migrateVestedMixNode = this.migrateVestedMixNode.bind(this);
    this.migrateVestedDelegation = this.migrateVestedDelegation.bind(this);
  }
  updateAdmin = async ({
    admin
  }: {
    admin: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_admin: {
        admin
      }
    }, fee_, memo_, funds_);
  };
  updateRewardingValidatorAddress = async ({
    address
  }: {
    address: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_rewarding_validator_address: {
        address
      }
    }, fee_, memo_, funds_);
  };
  updateContractStateParams = async ({
    update
  }: {
    update: ContractStateParamsUpdate;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_contract_state_params: {
        update
      }
    }, fee_, memo_, funds_);
  };
  updateCurrentNymNodeSemver = async ({
    currentVersion
  }: {
    currentVersion: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_current_nym_node_semver: {
        current_version: currentVersion
      }
    }, fee_, memo_, funds_);
  };
  updateActiveSetDistribution = async ({
    forceImmediately,
    update
  }: {
    forceImmediately: boolean;
    update: ActiveSetUpdate;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_active_set_distribution: {
        force_immediately: forceImmediately,
        update
      }
    }, fee_, memo_, funds_);
  };
  updateRewardingParams = async ({
    forceImmediately,
    updatedParams
  }: {
    forceImmediately: boolean;
    updatedParams: IntervalRewardingParamsUpdate;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_rewarding_params: {
        force_immediately: forceImmediately,
        updated_params: updatedParams
      }
    }, fee_, memo_, funds_);
  };
  updateIntervalConfig = async ({
    epochDurationSecs,
    epochsInInterval,
    forceImmediately
  }: {
    epochDurationSecs: number;
    epochsInInterval: number;
    forceImmediately: boolean;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_interval_config: {
        epoch_duration_secs: epochDurationSecs,
        epochs_in_interval: epochsInInterval,
        force_immediately: forceImmediately
      }
    }, fee_, memo_, funds_);
  };
  beginEpochTransition = async (fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      begin_epoch_transition: {}
    }, fee_, memo_, funds_);
  };
  reconcileEpochEvents = async ({
    limit
  }: {
    limit?: number;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      reconcile_epoch_events: {
        limit
      }
    }, fee_, memo_, funds_);
  };
  assignRoles = async ({
    assignment
  }: {
    assignment: RoleAssignment;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      assign_roles: {
        assignment
      }
    }, fee_, memo_, funds_);
  };
  bondMixnode = async ({
    costParams,
    mixNode,
    ownerSignature
  }: {
    costParams: NodeCostParams;
    mixNode: MixNode;
    ownerSignature: MessageSignature;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      bond_mixnode: {
        cost_params: costParams,
        mix_node: mixNode,
        owner_signature: ownerSignature
      }
    }, fee_, memo_, funds_);
  };
  bondMixnodeOnBehalf = async ({
    costParams,
    mixNode,
    owner,
    ownerSignature
  }: {
    costParams: NodeCostParams;
    mixNode: MixNode;
    owner: string;
    ownerSignature: MessageSignature;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      bond_mixnode_on_behalf: {
        cost_params: costParams,
        mix_node: mixNode,
        owner,
        owner_signature: ownerSignature
      }
    }, fee_, memo_, funds_);
  };
  pledgeMore = async (fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      pledge_more: {}
    }, fee_, memo_, funds_);
  };
  pledgeMoreOnBehalf = async ({
    owner
  }: {
    owner: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      pledge_more_on_behalf: {
        owner
      }
    }, fee_, memo_, funds_);
  };
  decreasePledge = async ({
    decreaseBy
  }: {
    decreaseBy: Coin;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      decrease_pledge: {
        decrease_by: decreaseBy
      }
    }, fee_, memo_, funds_);
  };
  decreasePledgeOnBehalf = async ({
    decreaseBy,
    owner
  }: {
    decreaseBy: Coin;
    owner: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      decrease_pledge_on_behalf: {
        decrease_by: decreaseBy,
        owner
      }
    }, fee_, memo_, funds_);
  };
  unbondMixnode = async (fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unbond_mixnode: {}
    }, fee_, memo_, funds_);
  };
  unbondMixnodeOnBehalf = async ({
    owner
  }: {
    owner: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unbond_mixnode_on_behalf: {
        owner
      }
    }, fee_, memo_, funds_);
  };
  updateCostParams = async ({
    newCosts
  }: {
    newCosts: NodeCostParams;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_cost_params: {
        new_costs: newCosts
      }
    }, fee_, memo_, funds_);
  };
  updateMixnodeCostParamsOnBehalf = async ({
    newCosts,
    owner
  }: {
    newCosts: NodeCostParams;
    owner: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_mixnode_cost_params_on_behalf: {
        new_costs: newCosts,
        owner
      }
    }, fee_, memo_, funds_);
  };
  updateMixnodeConfig = async ({
    newConfig
  }: {
    newConfig: MixNodeConfigUpdate;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_mixnode_config: {
        new_config: newConfig
      }
    }, fee_, memo_, funds_);
  };
  updateMixnodeConfigOnBehalf = async ({
    newConfig,
    owner
  }: {
    newConfig: MixNodeConfigUpdate;
    owner: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_mixnode_config_on_behalf: {
        new_config: newConfig,
        owner
      }
    }, fee_, memo_, funds_);
  };
  migrateMixnode = async (fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      migrate_mixnode: {}
    }, fee_, memo_, funds_);
  };
  bondGateway = async ({
    gateway,
    ownerSignature
  }: {
    gateway: Gateway;
    ownerSignature: MessageSignature;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      bond_gateway: {
        gateway,
        owner_signature: ownerSignature
      }
    }, fee_, memo_, funds_);
  };
  bondGatewayOnBehalf = async ({
    gateway,
    owner,
    ownerSignature
  }: {
    gateway: Gateway;
    owner: string;
    ownerSignature: MessageSignature;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      bond_gateway_on_behalf: {
        gateway,
        owner,
        owner_signature: ownerSignature
      }
    }, fee_, memo_, funds_);
  };
  unbondGateway = async (fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unbond_gateway: {}
    }, fee_, memo_, funds_);
  };
  unbondGatewayOnBehalf = async ({
    owner
  }: {
    owner: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unbond_gateway_on_behalf: {
        owner
      }
    }, fee_, memo_, funds_);
  };
  updateGatewayConfig = async ({
    newConfig
  }: {
    newConfig: GatewayConfigUpdate;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_gateway_config: {
        new_config: newConfig
      }
    }, fee_, memo_, funds_);
  };
  updateGatewayConfigOnBehalf = async ({
    newConfig,
    owner
  }: {
    newConfig: GatewayConfigUpdate;
    owner: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_gateway_config_on_behalf: {
        new_config: newConfig,
        owner
      }
    }, fee_, memo_, funds_);
  };
  migrateGateway = async ({
    costParams
  }: {
    costParams?: NodeCostParams;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      migrate_gateway: {
        cost_params: costParams
      }
    }, fee_, memo_, funds_);
  };
  bondNymNode = async ({
    costParams,
    node,
    ownerSignature
  }: {
    costParams: NodeCostParams;
    node: NymNode;
    ownerSignature: MessageSignature;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      bond_nym_node: {
        cost_params: costParams,
        node,
        owner_signature: ownerSignature
      }
    }, fee_, memo_, funds_);
  };
  unbondNymNode = async (fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unbond_nym_node: {}
    }, fee_, memo_, funds_);
  };
  updateNodeConfig = async ({
    update
  }: {
    update: NodeConfigUpdate;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_node_config: {
        update
      }
    }, fee_, memo_, funds_);
  };
  delegate = async ({
    nodeId
  }: {
    nodeId: number;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      delegate: {
        node_id: nodeId
      }
    }, fee_, memo_, funds_);
  };
  delegateToMixnodeOnBehalf = async ({
    delegate,
    mixId
  }: {
    delegate: string;
    mixId: number;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      delegate_to_mixnode_on_behalf: {
        delegate,
        mix_id: mixId
      }
    }, fee_, memo_, funds_);
  };
  undelegate = async ({
    nodeId
  }: {
    nodeId: number;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      undelegate: {
        node_id: nodeId
      }
    }, fee_, memo_, funds_);
  };
  undelegateFromMixnodeOnBehalf = async ({
    delegate,
    mixId
  }: {
    delegate: string;
    mixId: number;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      undelegate_from_mixnode_on_behalf: {
        delegate,
        mix_id: mixId
      }
    }, fee_, memo_, funds_);
  };
  rewardNode = async ({
    nodeId,
    params
  }: {
    nodeId: number;
    params: NodeRewardingParameters;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      reward_node: {
        node_id: nodeId,
        params
      }
    }, fee_, memo_, funds_);
  };
  withdrawOperatorReward = async (fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_operator_reward: {}
    }, fee_, memo_, funds_);
  };
  withdrawOperatorRewardOnBehalf = async ({
    owner
  }: {
    owner: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_operator_reward_on_behalf: {
        owner
      }
    }, fee_, memo_, funds_);
  };
  withdrawDelegatorReward = async ({
    nodeId
  }: {
    nodeId: number;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_delegator_reward: {
        node_id: nodeId
      }
    }, fee_, memo_, funds_);
  };
  withdrawDelegatorRewardOnBehalf = async ({
    mixId,
    owner
  }: {
    mixId: number;
    owner: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_delegator_reward_on_behalf: {
        mix_id: mixId,
        owner
      }
    }, fee_, memo_, funds_);
  };
  migrateVestedMixNode = async (fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      migrate_vested_mix_node: {}
    }, fee_, memo_, funds_);
  };
  migrateVestedDelegation = async ({
    mixId
  }: {
    mixId: number;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      migrate_vested_delegation: {
        mix_id: mixId
      }
    }, fee_, memo_, funds_);
  };
}