// Copyright 2021 - Nym Technologies SA <contact@nymtech.net>
// SPDX-License-Identifier: Apache-2.0

// due to code generated by JsonSchema
#![allow(clippy::field_reassign_with_default)]

use crate::{Addr, IdentityKey};
use cosmwasm_std::{Coin, Uint128};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use std::fmt::Display;
use std::hash::{Hash, Hasher};

type OwnerAddressBytes = Vec<u8>;
type BlockHeight = u64;

pub fn generate_storage_key(address: &Addr, proxy: Option<&Addr>) -> Vec<u8> {
    if let Some(proxy) = &proxy {
        address
            .as_bytes()
            .iter()
            .zip(proxy.as_bytes())
            .map(|(x, y)| x ^ y)
            .collect()
    } else {
        address.as_bytes().to_vec()
    }
}

#[derive(Clone, Debug, Deserialize, Serialize, PartialEq, JsonSchema)]
pub struct Delegation {
    pub owner: Addr,
    pub node_identity: IdentityKey,
    pub amount: Coin,
    pub block_height: u64,
    pub proxy: Option<Addr>, // proxy address used to delegate the funds on behalf of another address
}

impl Eq for Delegation {}

#[allow(clippy::derive_hash_xor_eq)]
impl Hash for Delegation {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.owner.hash(state);
        self.node_identity.hash(state);
        self.block_height.hash(state);
        self.proxy.hash(state);
    }
}

impl Delegation {
    pub fn new(
        owner: Addr,
        node_identity: IdentityKey,
        amount: Coin,
        block_height: BlockHeight,
        proxy: Option<Addr>,
    ) -> Self {
        Delegation {
            owner,
            node_identity,
            amount,
            block_height,
            proxy,
        }
    }

    pub fn storage_key(&self) -> (IdentityKey, OwnerAddressBytes, BlockHeight) {
        (
            self.node_identity(),
            self.proxy_storage_key(),
            self.block_height(),
        )
    }

    pub fn event_storage_key(&self) -> (OwnerAddressBytes, BlockHeight, IdentityKey) {
        (
            self.proxy_storage_key(),
            self.block_height(),
            self.node_identity(),
        )
    }

    pub fn proxy_storage_key(&self) -> OwnerAddressBytes {
        generate_storage_key(&self.owner, self.proxy.as_ref())
    }

    pub fn proxy(&self) -> Option<&Addr> {
        self.proxy.as_ref()
    }

    pub fn increment_amount(&mut self, amount: Uint128, at_height: Option<u64>) {
        self.amount.amount += amount;
        if let Some(at_height) = at_height {
            self.block_height = at_height;
        }
    }

    pub fn amount(&self) -> &Coin {
        &self.amount
    }

    pub fn node_identity(&self) -> IdentityKey {
        self.node_identity.clone()
    }

    pub fn owner(&self) -> Addr {
        self.owner.clone()
    }

    pub fn block_height(&self) -> u64 {
        self.block_height
    }
}

impl Display for Delegation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{} delegated towards {} by {} at block {}",
            self.amount, self.node_identity, self.owner, self.block_height
        )
    }
}

#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize, JsonSchema)]
pub struct PagedMixDelegationsResponse {
    pub delegations: Vec<Delegation>,
    pub start_next_after: Option<(String, u64)>,
}

impl PagedMixDelegationsResponse {
    pub fn new(delegations: Vec<Delegation>, start_next_after: Option<(String, u64)>) -> Self {
        PagedMixDelegationsResponse {
            delegations,
            start_next_after,
        }
    }
}

#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize, JsonSchema)]
pub struct PagedDelegatorDelegationsResponse {
    pub delegations: Vec<Delegation>,
    pub start_next_after: Option<IdentityKey>,
}

impl PagedDelegatorDelegationsResponse {
    pub fn new(delegations: Vec<Delegation>, start_next_after: Option<IdentityKey>) -> Self {
        PagedDelegatorDelegationsResponse {
            delegations,
            start_next_after,
        }
    }
}

#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize, JsonSchema)]
pub struct PagedAllDelegationsResponse {
    pub delegations: Vec<Delegation>,
    pub start_next_after: Option<(IdentityKey, Vec<u8>, u64)>,
}

impl PagedAllDelegationsResponse {
    pub fn new(
        delegations: Vec<Delegation>,
        start_next_after: Option<(IdentityKey, Vec<u8>, u64)>,
    ) -> Self {
        PagedAllDelegationsResponse {
            delegations,
            start_next_after: start_next_after.map(|(id, addr, height)| (id, addr, height)),
        }
    }
}
