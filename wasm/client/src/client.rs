// Copyright 2021-2023 - Nym Technologies SA <contact@nymtech.net>
// SPDX-License-Identifier: Apache-2.0

#![allow(unknown_lints)]
// clippy::empty_docs is not on stable as of 1.77

// due to the code generated by Tsify
#![allow(clippy::empty_docs)]

use crate::config::{ClientConfig, ClientConfigOpts};
use crate::error::WasmClientError;
use crate::helpers::{InputSender, WasmTopologyExt};
use crate::response_pusher::ResponsePusher;
use js_sys::Promise;
use nym_bin_common::bin_info;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tsify::Tsify;
use wasm_bindgen::prelude::*;
use wasm_bindgen_futures::future_to_promise;
use wasm_client_core::client::base_client::storage::GatewaysDetailsStore;
use wasm_client_core::client::{
    base_client::{BaseClientBuilder, ClientInput, ClientOutput, ClientState},
    inbound_messages::InputMessage,
};
use wasm_client_core::config::r#override::DebugWasmOverride;
use wasm_client_core::helpers::{
    add_gateway, generate_new_client_keys, parse_recipient, parse_sender_tag,
};
use wasm_client_core::nym_task::connections::TransmissionLane;
use wasm_client_core::nym_task::ShutdownTracker;
use wasm_client_core::storage::core_client_traits::FullWasmClientStorage;
use wasm_client_core::storage::wasm_client_traits::WasmClientStorage;
use wasm_client_core::storage::ClientStorage;
use wasm_client_core::topology::{SerializableTopologyExt, WasmFriendlyNymTopology};
use wasm_client_core::{IdentityKey, NymTopology, PacketType, QueryReqwestRpcNyxdClient};
use wasm_utils::error::PromisableResult;
use wasm_utils::{check_promise_result, console_error, console_log};

#[cfg(feature = "node-tester")]
use crate::helpers::{NymClientTestRequest, WasmTopologyTestExt};

#[cfg(feature = "node-tester")]
use rand::{rngs::OsRng, RngCore};

#[cfg(feature = "node-tester")]
#[allow(dead_code)]
pub(crate) const NODE_TESTER_CLIENT_ID: &str = "_nym-node-tester-client";

#[wasm_bindgen]
pub struct NymClient {
    self_address: String,
    #[wasm_bindgen(skip)]
    client_input: Arc<ClientInput>,
    #[wasm_bindgen(skip)]
    client_state: Arc<ClientState>,

    // keep track of the "old" topology for the purposes of node tester
    // so that it could be restored after the check is done
    #[wasm_bindgen(skip)]
    _full_topology: Option<NymTopology>,

    // even though we don't use graceful shutdowns, other components rely on existence of this struct
    // and if it's dropped, everything will start going offline
    _task_manager: ShutdownTracker,

    packet_type: PacketType,
}

// TODO: we don't really need a builder anymore,
// but we might as well leave it for backwards compatibility
#[wasm_bindgen]
#[derive(Debug)]
pub struct NymClientBuilder {
    config: ClientConfig,
    force_tls: bool,
    preferred_gateway: Option<IdentityKey>,
    latency_based_selection: Option<bool>,

    storage_passphrase: Option<String>,
    on_message: js_sys::Function,
}

#[wasm_bindgen]
impl NymClientBuilder {
    fn new(
        config: ClientConfig,
        on_message: js_sys::Function,
        force_tls: bool,
        preferred_gateway: Option<IdentityKey>,
        storage_passphrase: Option<String>,
    ) -> Self {
        NymClientBuilder {
            config,
            force_tls,
            storage_passphrase,
            on_message,
            // on_mix_fetch_message: Some(on_mix_fetch_message),
            preferred_gateway,
            latency_based_selection: None,
        }
    }

    // no cover traffic
    // no poisson delay
    // hardcoded topology
    // NOTE: you most likely want to use `[NymNodeTester]` instead.
    #[cfg(feature = "node-tester")]
    pub fn new_tester(
        topology: WasmFriendlyNymTopology,
        on_message: js_sys::Function,
        gateway: Option<IdentityKey>,
    ) -> Result<NymClientBuilder, WasmClientError> {
        if let Some(gateway_id) = &gateway {
            if !topology.ensure_contains_gateway_id(gateway_id) {
                panic!("the specified topology does not contain the gateway used by the client")
            }
        }

        let _ = on_message;
        // let full_config = ClientConfig::new_tester_config(NODE_TESTER_CLIENT_ID);
        // Ok(NymClientBuilder {
        //     config: full_config,
        //     force_tls: false,
        //     custom_topology: Some(topology.try_into()?),
        //     on_message,
        //     storage_passphrase: None,
        //     preferred_gateway: gateway,
        //     latency_based_selection: None,
        // })

        Err(WasmClientError::DisabledTester)
    }

    fn start_reconstructed_pusher(client_output: ClientOutput, on_message: js_sys::Function) {
        ResponsePusher::new(client_output, on_message).start()
    }

    // fn topology_provider(&mut self) -> Option<Box<dyn TopologyProvider + Send + Sync>> {
    //     if let Some(hardcoded_topology) = self.custom_topology.take() {
    //         Some(Box::new(HardcodedTopologyProvider::new(hardcoded_topology)))
    //     } else {
    //         None
    //     }
    // }

    fn initialise_storage(
        config: &ClientConfig,
        base_storage: ClientStorage,
    ) -> FullWasmClientStorage {
        FullWasmClientStorage::new(&config.base, base_storage)
    }

    async fn initialise_client_storage(&mut self) -> Result<ClientStorage, WasmClientError> {
        let client_store =
            ClientStorage::new_async(&self.config.base.client.id, self.storage_passphrase.take())
                .await?;
        if !client_store.has_identity_key().await? {
            console_log!(
                "no prior keys found - a new set will be generated for client {}",
                self.config.base.client.id
            );
            generate_new_client_keys(&client_store).await?;
        }

        Ok(client_store)
    }

    async fn try_set_preferred_gateway(
        &self,
        client_store: &ClientStorage,
    ) -> Result<bool, WasmClientError> {
        let Some(preferred) = self.preferred_gateway.as_ref() else {
            return Ok(false);
        };

        if client_store
            .has_gateway_details(&preferred.to_string())
            .await?
        {
            GatewaysDetailsStore::set_active_gateway(client_store, &preferred.to_string()).await?;
            return Ok(true);
        }

        Ok(false)
    }

    // async fn start_client(mut self) -> Result<NymClient, WasmClientError> {
    //     todo!()
    // }

    async fn has_active_gateway(
        &self,
        client_store: &ClientStorage,
    ) -> Result<bool, WasmClientError> {
        Ok(client_store
            .get_active_gateway_id()
            .await?
            .active_gateway_id_bs58
            .is_some())
    }

    async fn start_client_async(mut self) -> Result<NymClient, WasmClientError> {
        // TODO: resolve this properly
        self.config.base.debug.topology.ignore_egress_epoch_role = true;

        // TODO: this will have to be re-used for surbs. but this is a problem for another PR.
        let client_store = self.initialise_client_storage().await?;

        // if we don't have an active gateway (i.e. no gateways), add one
        // otherwise, see if we set a preferred gateway and attempt to set its details as active
        if !self.has_active_gateway(&client_store).await?
            || !self.try_set_preferred_gateway(&client_store).await?
        {
            add_gateway(
                self.preferred_gateway.clone(),
                self.latency_based_selection,
                self.force_tls,
                &self.config.base.client.nym_api_urls,
                bin_info!().into(),
                self.config.base.debug.topology.minimum_gateway_performance,
                self.config.base.debug.topology.ignore_ingress_epoch_role,
                &client_store,
            )
            .await?;
        }
        // debug log a bunch of config
        // console_log!(
        //     "start client async: debug log self: \n{:?}",
        //     self
        // );

        let packet_type = self.config.base.debug.traffic.packet_type;
        let storage = Self::initialise_storage(&self.config, client_store);

        let base_builder =
            BaseClientBuilder::<QueryReqwestRpcNyxdClient, _>::new(self.config.base, storage, None);
        // if let Some(topology_provider) = maybe_topology_provider {
        //     base_builder = base_builder.with_topology_provider(topology_provider);
        // }

        // if let Ok(reuse_setup) = GatewaySetup::try_reuse_connection(init_res) {
        //     base_builder = base_builder.with_gateway_setup(reuse_setup);
        // }

        let mut started_client = base_builder.start_base().await?;
        let self_address = started_client.address.to_string();

        let client_input = started_client.client_input.register_producer();
        let client_output = started_client.client_output.register_consumer();

        // MAX TODO NOTE: THIS RETURNS () MAYBE WE'RE NOT RESOLVING HERE?
        Self::start_reconstructed_pusher(client_output, self.on_message);

        Ok(NymClient {
            self_address,
            client_input: Arc::new(client_input),
            client_state: Arc::new(started_client.client_state),
            _full_topology: None,
            _task_manager: started_client.shutdown_handle,
            packet_type,
        })
    }

    pub fn start_client(self) -> Promise {
        future_to_promise(async move {
            self.start_client_async()
                .await
                .inspect_err(|err| console_error!("failed to start the client: {err}"))
                .into_promise_result()
        })
    }
}

#[derive(Tsify, Debug, Clone, Serialize, Deserialize)]
#[tsify(into_wasm_abi, from_wasm_abi)]
#[serde(rename_all = "camelCase")]
pub struct ClientOptsSimple {
    // ideally we'd have used the `IdentityKey` type alias, but that'd be extremely annoying to get working in TS
    #[tsify(optional)]
    pub(crate) preferred_gateway: Option<String>,

    #[tsify(optional)]
    pub(crate) storage_passphrase: Option<String>,

    #[tsify(optional)]
    pub(crate) force_tls: Option<bool>,

    #[tsify(optional)]
    pub(crate) latency_based_selection: Option<bool>,
}

#[derive(Tsify, Debug, Default, Clone, Serialize, Deserialize)]
#[tsify(into_wasm_abi, from_wasm_abi)]
#[serde(rename_all = "camelCase")]
pub struct ClientOpts {
    #[serde(flatten)]
    pub(crate) base: Option<ClientOptsSimple>,

    #[tsify(optional)]
    pub(crate) client_id: Option<String>,

    #[tsify(optional)]
    pub(crate) nym_api_url: Option<String>,

    // currently not used, but will be required once we have coconut
    #[tsify(optional)]
    pub(crate) nyxd_url: Option<String>,

    #[tsify(optional)]
    pub(crate) client_override: Option<DebugWasmOverride>,
}

impl<'a> From<&'a ClientOpts> for ClientConfigOpts {
    fn from(value: &'a ClientOpts) -> Self {
        ClientConfigOpts {
            id: value.client_id.as_ref().map(|v| v.to_owned()),
            nym_api: value.nym_api_url.as_ref().map(|v| v.to_owned()),
            nyxd: value.nyxd_url.as_ref().map(|v| v.to_owned()),
            debug: value.client_override.as_ref().map(|v| v.clone().into()),
        }
    }
}

#[wasm_bindgen]
impl NymClient {
    async fn _new(
        config: ClientConfig,
        on_message: js_sys::Function,
        opts: Option<ClientOptsSimple>,
    ) -> Result<NymClient, WasmClientError> {
        console_log!("_new: Starting client creation");

        if let Some(opts) = opts {
            console_log!("_new: Using provided options");
            let preferred_gateway = opts.preferred_gateway;
            let storage_passphrase = opts.storage_passphrase;
            let force_tls = opts.force_tls.unwrap_or_default();
            let builder = NymClientBuilder::new(
                config,
                on_message,
                force_tls,
                preferred_gateway,
                storage_passphrase,
            );
            console_log!("_new: About to call start_client_async");
            let result = builder.start_client_async().await;
            console_log!("_new: start_client_async completed: {:?}", result.is_ok());
            result.inspect_err(|err| console_error!("failed to start the client: {err}"))
        } else {
            console_log!("_new: Using default options");
            let builder = NymClientBuilder::new(config, on_message, false, None, None);
            console_log!("_new: About to call start_client_async (default)");
            let result = builder.start_client_async().await;
            console_log!(
                "_new: start_client_async (default) completed: {:?}",
                result.is_ok()
            );
            result.inspect_err(|err| console_error!("failed to start the client: {err}"))
        }
    }

    // async fn _new(
    //     config: ClientConfig,
    //     on_message: js_sys::Function,
    //     opts: Option<ClientOptsSimple>,
    // ) -> Result<NymClient, WasmClientError> {
    //     if let Some(opts) = opts {
    //         let preferred_gateway = opts.preferred_gateway;
    //         let storage_passphrase = opts.storage_passphrase;
    //         let force_tls = opts.force_tls.unwrap_or_default();
    //         NymClientBuilder::new(
    //             config,
    //             on_message,
    //             force_tls,
    //             preferred_gateway,
    //             storage_passphrase,
    //         )
    //     } else {
    //         NymClientBuilder::new(config, on_message, false, None, None)
    //     }
    //     .start_client_async()
    //     .await
    //     .inspect_err(|err| console_error!("failed to start the client: {err}"))
    // }

    // #[wasm_bindgen(constructor)]
    // #[allow(clippy::new_ret_no_self)]
    // pub fn new(on_message: js_sys::Function, opts: Option<ClientOpts>) -> Promise {
    //     console_log!("start of new()");
    //     let opts = opts.unwrap_or_default();
    //     let mut config = check_promise_result!(ClientConfig::new((&opts).into()));

    //     if let Some(dbg) = opts.client_override {
    //         config.override_debug(dbg);
    //     }

    //     future_to_promise(async move {
    //         Self::_new(config, on_message, opts.base)
    //             .await
    //             .into_promise_result()
    //     })
    // }
    #[wasm_bindgen(constructor)]
    pub fn new(on_message: js_sys::Function, opts: Option<ClientOpts>) -> Promise {
        console_log!("start of new()");
        let opts = opts.unwrap_or_default();
        let mut config = check_promise_result!(ClientConfig::new((&opts).into()));

        if let Some(dbg) = opts.client_override {
            config.override_debug(dbg);
        }

        future_to_promise(async move {
            console_log!("future_to_promise: Starting async block");
            let result = Self::_new(config, on_message, opts.base).await;
            console_log!("future_to_promise: _new completed: {:?}", result.is_ok());

            match result {
                Ok(client) => {
                    console_log!("future_to_promise: Converting successful result to JsValue");
                    let js_result = JsValue::from(client);
                    console_log!("future_to_promise: Conversion successful, returning Ok");
                    Ok(js_result)
                }
                Err(err) => {
                    console_error!("future_to_promise: Error occurred: {:?}", err);
                    Err(JsValue::from(err))
                }
            }
        })
    }

    #[wasm_bindgen(js_name = "newWithConfig")]
    pub fn new_with_config(
        config: ClientConfig,
        on_message: js_sys::Function,
        opts: ClientOptsSimple,
    ) -> Promise {
        future_to_promise(async move {
            console_log!("new_with_config: future_to_promise: Starting async block");
            let result = Self::_new(config, on_message, Some(opts)).await;
            console_log!(
                "new_with_config: future_to_promise: _new completed: {:?}",
                result.is_ok()
            );
            // .into_promise_result()
            match result {
                Ok(client) => {
                    console_log!("new_with_config: future_to_promise: Converting successful result to JsValue");
                    let js_result = JsValue::from(client);
                    console_log!(
                        "new_with_config: future_to_promise: Conversion successful, returning Ok"
                    );
                    Ok(js_result)
                    // Ok(JsValue::from_str(&client.self_address)) // test to return simpler type across the boundary - THIS WORKS
                }
                Err(err) => {
                    console_error!(
                        "new_with_config: future_to_promise: Error occurred: {:?}",
                        err
                    );
                    Err(JsValue::from(err))
                }
            }
        })
    }

    // #[wasm_bindgen(js_name = "newWithConfig")]
    // pub fn new_with_config(
    //     config: ClientConfig,
    //     on_message: js_sys::Function,
    //     opts: ClientOptsSimple,
    // ) -> Promise {
    //     future_to_promise(async move {
    //         console_log!("new_with_config: future_to_promise: Starting async block");
    //         Self::_new(config, on_message, Some(opts))
    //             .await
    //             .into_promise_result()
    //     })
    // }

    // no cover traffic
    // no poisson delay
    // hardcoded topology
    // NOTE: you most likely want to use `[NymNodeTester]` instead.
    #[cfg(feature = "node-tester")]
    #[wasm_bindgen(js_name = "newTester")]
    pub fn new_tester() -> Promise {
        todo!()
    }

    #[wasm_bindgen(js_name = "selfAddress")]
    pub fn self_address(&self) -> String {
        self.self_address.clone()
    }

    #[cfg(feature = "node-tester")]
    pub fn try_construct_test_packet_request(
        &self,
        mixnode_identity: String,
        num_test_packets: Option<u32>,
    ) -> Promise {
        // TODO: improve the source of rng (i.e. don't make it ephemeral...)
        let mut ephemeral_rng = OsRng;
        let test_id = ephemeral_rng.next_u32();
        self.client_state
            .mix_test_request(test_id, mixnode_identity, num_test_packets)
    }

    pub fn change_hardcoded_topology(&self, topology: WasmFriendlyNymTopology) -> Promise {
        self.client_state.change_hardcoded_topology(topology)
    }

    pub fn current_network_topology(&self) -> Promise {
        self.client_state.current_topology()
    }

    /// Sends a test packet through the current network topology.
    /// It's the responsibility of the caller to ensure the correct topology has been injected and
    /// correct onmessage handlers have been setup.
    #[cfg(feature = "node-tester")]
    pub fn try_send_test_packets(&mut self, request: NymClientTestRequest) -> Promise {
        // TOOD: use the premade packets instead
        console_log!(
            "Attempting to send {} test packets",
            request.test_msgs.len()
        );

        // our address MUST BE valid
        let recipient = parse_recipient(&self.self_address()).unwrap();

        let lane = TransmissionLane::General;
        let input_msgs = request
            .test_msgs
            .into_iter()
            .map(|p| InputMessage::new_regular(recipient, p, lane, None))
            .collect();

        self.client_input.send_messages(input_msgs)
    }

    /// The simplest message variant where no additional information is attached.
    /// You're simply sending your `data` to specified `recipient` without any tagging.
    ///
    /// Ends up with `NymMessage::Plain` variant
    pub fn send_regular_message(&self, message: Vec<u8>, recipient: String) -> Promise {
        console_log!(
            "Attempting to send {:.2} kiB message to {recipient}",
            message.len() as f64 / 1024.0
        );

        let recipient = check_promise_result!(parse_recipient(&recipient));

        let lane = TransmissionLane::General;

        let input_msg = InputMessage::new_regular(recipient, message, lane, Some(self.packet_type));
        self.client_input.send_message(input_msg)
    }

    /// Creates a message used for a duplex anonymous communication where the recipient
    /// will never learn of our true identity. This is achieved by carefully sending `reply_surbs`.
    ///
    /// Note that if reply_surbs is set to zero then
    /// this variant requires the client having sent some reply_surbs in the past
    /// (and thus the recipient also knowing our sender tag).
    ///
    /// Ends up with `NymMessage::Repliable` variant
    pub fn send_anonymous_message(
        &self,
        message: Vec<u8>,
        recipient: String,
        reply_surbs: u32,
    ) -> Promise {
        console_log!(
            "Attempting to anonymously send {:.2} kiB message to {recipient} while attaching {reply_surbs} replySURBs.",
            message.len() as f64 / 1024.0
        );

        let recipient = check_promise_result!(parse_recipient(&recipient));

        let lane = TransmissionLane::General;

        let input_msg = InputMessage::new_anonymous(
            recipient,
            message,
            reply_surbs,
            lane,
            Some(self.packet_type),
        );
        self.client_input.send_message(input_msg)
    }

    /// Attempt to use our internally received and stored `ReplySurb` to send the message back
    /// to specified recipient whilst not knowing its full identity (or even gateway).
    ///
    /// Ends up with `NymMessage::Reply` variant
    pub fn send_reply(&self, message: Vec<u8>, recipient_tag: String) -> Promise {
        console_log!(
            "Attempting to send {:.2} kiB reply message to {recipient_tag}",
            message.len() as f64 / 1024.0
        );

        let sender_tag = check_promise_result!(parse_sender_tag(&recipient_tag));

        let lane = TransmissionLane::General;

        let input_msg = InputMessage::new_reply(sender_tag, message, lane, Some(self.packet_type));
        self.client_input.send_message(input_msg)
    }
}
