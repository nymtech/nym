// This file is auto-generated by @hey-api/openapi-ts

export type AnnouncePorts = {
  mix_port?: number | null;
  verloc_port?: number | null;
};

export type AuthenticatorDetails = {
  /**
   * address of the embedded authenticator
   */
  address: string;
};

/**
 * Auxiliary details of the associated Nym Node.
 */
export type AuxiliaryDetails = {
  /**
   * Specifies whether this node operator has agreed to the terms and conditions
   * as defined at <https://nymtech.net/terms-and-conditions/operators/v1.0.0>
   */
  accepted_operator_terms_and_conditions?: boolean;
  announce_ports?: AnnouncePorts;
  /**
   * Optional ISO 3166 alpha-2 two-letter country code of the node's **physical** location
   */
  location?: string | null;
};

export type BasicEntryInformation = {
  hostname?: string | null;
  ws_port: number;
  wss_port?: number | null;
};

export type BinaryBuildInformationOwned = {
  /**
   * Provides the name of the binary, i.e. the content of `CARGO_PKG_NAME` environmental variable.
   */
  binary_name: string;
  /**
   * Provides the build timestamp, for example `2021-02-23T20:14:46.558472672+00:00`.
   */
  build_timestamp: string;
  /**
   * Provides the build version, for example `0.1.0-9-g46f83e1`.
   */
  build_version: string;
  /**
   * Provides the cargo debug mode that was used for the build.
   */
  cargo_profile: string;
  /**
   * Provides the cargo target triple that was used for the build.
   */
  cargo_triple?: string;
  /**
   * Provides the name of the git branch that was used for the build, for example `master`.
   */
  commit_branch: string;
  /**
   * Provides the hash of the commit that was used for the build, for example `46f83e112520533338245862d366f6a02cef07d4`.
   */
  commit_sha: string;
  /**
   * Provides the timestamp of the commit that was used for the build, for example `2021-02-23T08:08:02-05:00`.
   */
  commit_timestamp: string;
  /**
   * Provides the rustc channel that was used for the build, for example `nightly`.
   */
  rustc_channel: string;
  /**
   * Provides the rustc version that was used for the build, for example `1.52.0-nightly`.
   */
  rustc_version: string;
};

export type BuildInformation = {
  build_version: string;
  commit_branch: string;
  commit_sha: string;
};

/**
 * Coin
 */
export type CoinSchema = {
  amount: string;
  denom: string;
};

export type DVpnGateway = {
  authenticator?: null | AuthenticatorDetails;
  build_information: BinaryBuildInformationOwned;
  entry?: null | BasicEntryInformation;
  identity_key: string;
  ip_addresses: Array<string>;
  ip_packet_router?: null | IpPacketRouterDetails;
  last_probe?: null | DirectoryGwProbe;
  location: Location;
  mix_port: number;
  name: string;
  performance: string;
  role: NodeRole;
};

export type DailyStats = {
  date_utc: string;
  total_packets_dropped: number;
  total_packets_received: number;
  total_packets_sent: number;
  total_stake: number;
};

export type DeclaredRoles = {
  entry: boolean;
  exit_ipr: boolean;
  exit_nr: boolean;
  mixnode: boolean;
};

export type DescribedNodeType =
  | "legacy_mixnode"
  | "legacy_gateway"
  | "nym_node";

export type DirectoryGwProbe = {
  last_updated_utc: string;
  outcome: ProbeOutcome;
};

export type Entry = EntryTestResult | null;

export type EntryTestResult = {
  can_connect: boolean;
  can_route: boolean;
};

export type Exit = {
  can_connect: boolean;
  can_route_ip_external_v4: boolean;
  can_route_ip_external_v6: boolean;
  can_route_ip_v4: boolean;
  can_route_ip_v6: boolean;
};

export type ExtendedNymNode = {
  accepted_tnc: boolean;
  bonded: boolean;
  bonding_address?: string | null;
  description: NodeDescription;
  geoip?: null | NodeGeoData;
  identity_key: string;
  ip_address: string;
  node_id: U32;
  node_type: DescribedNodeType;
  original_pledge: number;
  rewarding_details?: null | NodeRewarding;
  self_description: NymNodeData;
  total_stake: string;
  uptime: number;
};

export type Gateway = {
  bonded: boolean;
  config_score: number;
  description: NodeDescription;
  explorer_pretty_bond?: unknown;
  gateway_identity_key: string;
  last_probe_log?: string | null;
  last_probe_result?: unknown;
  last_testrun_utc?: string | null;
  last_updated_utc: string;
  performance: number;
  routing_score: number;
  self_described?: unknown;
};

export type GatewaySkinny = {
  config_score: number;
  explorer_pretty_bond?: unknown;
  gateway_identity_key: string;
  last_probe_result?: unknown;
  last_testrun_utc?: string | null;
  last_updated_utc: string;
  performance: number;
  routing_score: number;
  self_described?: unknown;
};

export type GatewaySummary = {
  bonded: GatewaySummaryBonded;
  historical: GatewaySummaryHistorical;
};

export type GatewaySummaryBonded = {
  count: number;
  entry: number;
  exit: number;
  last_updated_utc: string;
};

export type GatewaySummaryHistorical = {
  count: number;
  last_updated_utc: string;
};

export type HealthInfo = {
  uptime: number;
};

export type HostInformation = {
  hostname?: string | null;
  ip_address: Array<string>;
  keys: HostKeys;
};

export type HostKeys = {
  ed25519: string;
  x25519: string;
  x25519_noise?: string;
};

export type IpPacketRouterDetails = {
  /**
   * address of the embedded ip packet router
   */
  address: string;
};

/**
 * based on
 * https://github.com/nymtech/nym-vpn-client/blob/nym-vpn-core-v1.10.0/nym-vpn-core/crates/nym-gateway-probe/src/types.rs
 * TODO: long term types should be moved into this repo because nym-vpn-client
 * could pull it as a dependency and we'd have a single source of truth
 */
export type LastProbeResult = {
  node: string;
  outcome: ProbeOutcome;
  used_entry: string;
};

export type Location = {
  latitude: number;
  longitude: number;
  two_letter_iso_country_code: string;
};

export type MixingNodesSummary = {
  count: number;
  last_updated_utc: string;
  legacy: number;
  self_described: number;
};

export type Mixnode = {
  bonded: boolean;
  description: NodeDescription;
  full_details?: unknown;
  is_dp_delegatee: boolean;
  last_updated_utc: string;
  mix_id: number;
  self_described?: unknown;
  total_stake: number;
};

export type MixnodeSummary = {
  bonded: MixingNodesSummary;
  historical: MixnodeSummaryHistorical;
};

export type MixnodeSummaryHistorical = {
  count: number;
  last_updated_utc: string;
};

export type NetworkRequesterDetails = {
  /**
   * address of the embedded network requester
   */
  address: string;
  /**
   * flag indicating whether this network requester uses the exit policy rather than the deprecated allow list
   */
  uses_exit_policy: boolean;
};

export type NetworkSummary = {
  gateways: GatewaySummary;
  mixnodes: MixnodeSummary;
  total_nodes: number;
};

/**
 * The cost parameters, or the cost function, defined for the particular mixnode that influences
 * how the rewards should be split between the node operator and its delegators.
 */
export type NodeCostParams = {
  /**
   * Operating cost of the associated node per the entire interval.
   */
  interval_operating_cost: CoinSchema;
  /**
   * The profit margin of the associated node, i.e. the desired percent of the reward to be distributed to the operator.
   */
  profit_margin_percent: string;
};

export type NodeDelegation = {
  amount: CoinSchema;
  block_height: number;
  cumulative_reward_ratio: string;
  owner: string;
  proxy?: string | null;
};

export type NodeDescription = {
  /**
   * details define other optional details.
   */
  details: string;
  /**
   * moniker defines a human-readable name for the node.
   */
  moniker: string;
  /**
   * security contact defines an optional email for security contact.
   */
  security_contact: string;
  /**
   * website defines an optional website link.
   */
  website: string;
};

export type NodeGeoData = {
  city: string;
  country: string;
  ip_address: string;
  latitude: string;
  longitude: string;
  org: string;
  postal: string;
  region: string;
  timezone: string;
};

export type NodeRewarding = {
  /**
   * Information provided by the operator that influence the cost function.
   */
  cost_params: NodeCostParams;
  /**
   * Total delegation and compounded reward earned by all node delegators.
   */
  delegates: string;
  /**
   * Marks the epoch when this node was last rewarded so that we wouldn't accidentally attempt
   * to reward it multiple times in the same epoch.
   */
  last_rewarded_epoch: U32;
  /**
   * Total pledge and compounded reward earned by the node operator.
   */
  operator: string;
  /**
   * Cumulative reward earned by the "unit delegation" since the block 0.
   */
  total_unit_reward: string;
  unique_delegations: number;
  /**
   * Value of the theoretical "unit delegation" that has delegated to this node at block 0.
   */
  unit_delegation: string;
};

export type NodeRole =
  | {
      Mixnode: {
        layer: number;
      };
    }
  | "EntryGateway"
  | "ExitGateway"
  | "Standby"
  | "Inactive";

export type NymNodeData = {
  authenticator?: null | AuthenticatorDetails;
  auxiliary_details?: AuxiliaryDetails;
  build_information: BinaryBuildInformationOwned;
  declared_role?: DeclaredRoles;
  host_information: HostInformation;
  ip_packet_router?: null | IpPacketRouterDetails;
  last_polled?: OffsetDateTimeJsonSchemaWrapper;
  mixnet_websockets: WebSockets;
  network_requester?: null | NetworkRequesterDetails;
  wireguard?: null | WireguardDetails;
};

export type OffsetDateTimeJsonSchemaWrapper = string;

export type PagedResultExtendedNymNode = {
  items: Array<{
    accepted_tnc: boolean;
    bonded: boolean;
    bonding_address?: string | null;
    description: NodeDescription;
    geoip?: null | NodeGeoData;
    identity_key: string;
    ip_address: string;
    node_id: U32;
    node_type: DescribedNodeType;
    original_pledge: number;
    rewarding_details?: null | NodeRewarding;
    self_description: NymNodeData;
    total_stake: string;
    uptime: number;
  }>;
  page: number;
  size: number;
  total: number;
};

export type PagedResultGateway = {
  items: Array<{
    bonded: boolean;
    config_score: number;
    description: NodeDescription;
    explorer_pretty_bond?: unknown;
    gateway_identity_key: string;
    last_probe_log?: string | null;
    last_probe_result?: unknown;
    last_testrun_utc?: string | null;
    last_updated_utc: string;
    performance: number;
    routing_score: number;
    self_described?: unknown;
  }>;
  page: number;
  size: number;
  total: number;
};

export type PagedResultGatewaySkinny = {
  items: Array<{
    config_score: number;
    explorer_pretty_bond?: unknown;
    gateway_identity_key: string;
    last_probe_result?: unknown;
    last_testrun_utc?: string | null;
    last_updated_utc: string;
    performance: number;
    routing_score: number;
    self_described?: unknown;
  }>;
  page: number;
  size: number;
  total: number;
};

export type PagedResultMixnode = {
  items: Array<{
    bonded: boolean;
    description: NodeDescription;
    full_details?: unknown;
    is_dp_delegatee: boolean;
    last_updated_utc: string;
    mix_id: number;
    self_described?: unknown;
    total_stake: number;
  }>;
  page: number;
  size: number;
  total: number;
};

export type PagedResultService = {
  items: Array<{
    gateway_identity_key: string;
    hostname?: string | null;
    ip_address?: string | null;
    last_successful_ping_utc?: string | null;
    last_updated_utc: string;
    mixnet_websockets?: unknown;
    routing_score: number;
    service_provider_client_id?: string | null;
  }>;
  page: number;
  size: number;
  total: number;
};

export type PagedResultSessionStats = {
  items: Array<{
    day: string;
    gateway_identity_key: string;
    mixnet_sessions?: unknown;
    node_id: number;
    session_started: number;
    unique_active_clients: number;
    unknown_sessions?: unknown;
    users_hashes?: unknown;
    vpn_sessions?: unknown;
  }>;
  page: number;
  size: number;
  total: number;
};

export type ProbeOutcome = {
  as_entry: Entry;
  as_exit?: null | Exit;
  wg?: null | ProbeOutcomeV1;
};

export type ProbeOutcomeV1 = {
  can_handshake_v4: boolean;
  can_handshake_v6: boolean;
  can_register: boolean;
  can_resolve_dns_v4: boolean;
  can_resolve_dns_v6: boolean;
  download_duration_sec_v4: number;
  download_duration_sec_v6: number;
  download_error_v4: string;
  download_error_v6: string;
  downloaded_file_v4: string;
  downloaded_file_v6: string;
  ping_hosts_performance_v4: number;
  ping_hosts_performance_v6: number;
  ping_ips_performance_v4: number;
  ping_ips_performance_v6: number;
};

export type Service = {
  gateway_identity_key: string;
  hostname?: string | null;
  ip_address?: string | null;
  last_successful_ping_utc?: string | null;
  last_updated_utc: string;
  mixnet_websockets?: unknown;
  routing_score: number;
  service_provider_client_id?: string | null;
};

export type SessionStats = {
  day: string;
  gateway_identity_key: string;
  mixnet_sessions?: unknown;
  node_id: number;
  session_started: number;
  unique_active_clients: number;
  unknown_sessions?: unknown;
  users_hashes?: unknown;
  vpn_sessions?: unknown;
};

export type SummaryHistory = {
  date: string;
  timestamp_utc: string;
  value_json: unknown;
};

export type TestRun = {
  id: number;
  identity_key: string;
  log: string;
  status: string;
};

export type WebSockets = {
  ws_port: number;
  wss_port?: number | null;
};

export type WireguardDetails = {
  port: number;
  public_key: string;
};

export type U32 = number;

export type GetGatewaysData = {
  body?: never;
  path?: never;
  query?: {
    min_node_version?: string;
  };
  url: "/dvpn/v1/directory/gateways";
};

export type GetGatewaysResponses = {
  200: Array<DVpnGateway>;
};

export type GetGatewaysResponse =
  GetGatewaysResponses[keyof GetGatewaysResponses];

export type GetGatewayCountriesData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/dvpn/v1/directory/gateways/countries";
};

export type GetGatewayCountriesResponses = {
  200: Array<string>;
};

export type GetGatewayCountriesResponse =
  GetGatewayCountriesResponses[keyof GetGatewayCountriesResponses];

export type GetGatewaysByCountryData = {
  body?: never;
  path: {
    two_letter_country_code: string;
  };
  query?: never;
  url: "/dvpn/v1/directory/gateways/country/{two_letter_country_code}";
};

export type GetGatewaysByCountryResponses = {
  200: Array<DVpnGateway>;
};

export type GetGatewaysByCountryResponse =
  GetGatewaysByCountryResponses[keyof GetGatewaysByCountryResponses];

export type GetEntryGatewaysData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/dvpn/v1/directory/gateways/entry";
};

export type GetEntryGatewaysResponses = {
  200: Array<DVpnGateway>;
};

export type GetEntryGatewaysResponse =
  GetEntryGatewaysResponses[keyof GetEntryGatewaysResponses];

export type GetEntryGatewayCountriesData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/dvpn/v1/directory/gateways/entry/countries";
};

export type GetEntryGatewayCountriesResponses = {
  200: Array<string>;
};

export type GetEntryGatewayCountriesResponse =
  GetEntryGatewayCountriesResponses[keyof GetEntryGatewayCountriesResponses];

export type GetEntryGatewaysByCountryData = {
  body?: never;
  path: {
    two_letter_country_code: string;
  };
  query?: never;
  url: "/dvpn/v1/directory/gateways/entry/country/{two_letter_country_code}";
};

export type GetEntryGatewaysByCountryResponses = {
  200: Array<DVpnGateway>;
};

export type GetEntryGatewaysByCountryResponse =
  GetEntryGatewaysByCountryResponses[keyof GetEntryGatewaysByCountryResponses];

export type GetExitGatewaysData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/dvpn/v1/directory/gateways/exit";
};

export type GetExitGatewaysResponses = {
  200: Array<DVpnGateway>;
};

export type GetExitGatewaysResponse =
  GetExitGatewaysResponses[keyof GetExitGatewaysResponses];

export type GetExitGatewayCountriesData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/dvpn/v1/directory/gateways/exit/countries";
};

export type GetExitGatewayCountriesResponses = {
  200: Array<string>;
};

export type GetExitGatewayCountriesResponse =
  GetExitGatewayCountriesResponses[keyof GetExitGatewayCountriesResponses];

export type GetExitGatewaysByCountryData = {
  body?: never;
  path: {
    two_letter_country_code: string;
  };
  query?: never;
  url: "/dvpn/v1/directory/gateways/exit/country/{two_letter_country_code}";
};

export type GetExitGatewaysByCountryResponses = {
  200: Array<DVpnGateway>;
};

export type GetExitGatewaysByCountryResponse =
  GetExitGatewaysByCountryResponses[keyof GetExitGatewaysByCountryResponses];

export type NymNodesData = {
  body?: never;
  path?: never;
  query?: {
    size?: number;
    page?: number;
  };
  url: "/explorer/v3/nym-nodes";
};

export type NymNodesResponses = {
  200: PagedResultExtendedNymNode;
};

export type NymNodesResponse = NymNodesResponses[keyof NymNodesResponses];

export type NodeDelegationsData = {
  body?: never;
  path: {
    node_id: U32;
  };
  query?: never;
  url: "/explorer/v3/nym-nodes/{node_id}/delegations";
};

export type NodeDelegationsResponses = {
  200: NodeDelegation;
};

export type NodeDelegationsResponse =
  NodeDelegationsResponses[keyof NodeDelegationsResponses];

export type GatewaysData = {
  body?: never;
  path?: never;
  query?: {
    size?: number;
    page?: number;
  };
  url: "/v2/gateways";
};

export type GatewaysResponses = {
  200: PagedResultGateway;
};

export type GatewaysResponse = GatewaysResponses[keyof GatewaysResponses];

export type GatewaysSkinnyData = {
  body?: never;
  path?: never;
  query?: {
    size?: number;
    page?: number;
  };
  url: "/v2/gateways/skinny";
};

export type GatewaysSkinnyResponses = {
  200: PagedResultGatewaySkinny;
};

export type GatewaysSkinnyResponse =
  GatewaysSkinnyResponses[keyof GatewaysSkinnyResponses];

export type GetGatewayData = {
  body?: never;
  path: {
    identity_key: string;
  };
  query?: never;
  url: "/v2/gateways/{identity_key}";
};

export type GetGatewayResponses = {
  200: Gateway;
};

export type GetGatewayResponse = GetGatewayResponses[keyof GetGatewayResponses];

export type GetAllSessionsData = {
  body?: never;
  path?: never;
  query?: {
    size?: number;
    page?: number;
    node_id?: string;
    day?: string;
  };
  url: "/v2/metrics/sessions";
};

export type GetAllSessionsResponses = {
  200: PagedResultSessionStats;
};

export type GetAllSessionsResponse =
  GetAllSessionsResponses[keyof GetAllSessionsResponses];

export type MixnodesData = {
  body?: never;
  path?: never;
  query?: {
    size?: number;
    page?: number;
  };
  url: "/v2/mixnodes";
};

export type MixnodesResponses = {
  200: PagedResultMixnode;
};

export type MixnodesResponse = MixnodesResponses[keyof MixnodesResponses];

export type GetStatsData = {
  body?: never;
  path?: never;
  query?: {
    offset?: number;
  };
  url: "/v2/mixnodes/stats";
};

export type GetStatsResponses = {
  200: Array<DailyStats>;
};

export type GetStatsResponse = GetStatsResponses[keyof GetStatsResponses];

export type GetMixnodesData = {
  body?: never;
  path: {
    mix_id: string;
  };
  query?: never;
  url: "/v2/mixnodes/{mix_id}";
};

export type GetMixnodesResponses = {
  200: Mixnode;
};

export type GetMixnodesResponse =
  GetMixnodesResponses[keyof GetMixnodesResponses];

export type Mixnodes2Data = {
  body?: never;
  path?: never;
  query?: {
    size?: number;
    page?: number;
    wss?: boolean;
    hostname?: boolean;
    entry?: boolean;
  };
  url: "/v2/services";
};

export type Mixnodes2Responses = {
  200: PagedResultService;
};

export type Mixnodes2Response = Mixnodes2Responses[keyof Mixnodes2Responses];

export type BuildInformationData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/v2/status/build_information";
};

export type BuildInformationResponses = {
  200: BinaryBuildInformationOwned;
};

export type BuildInformationResponse =
  BuildInformationResponses[keyof BuildInformationResponses];

export type HealthData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/v2/status/health";
};

export type HealthResponses = {
  200: HealthInfo;
};

export type HealthResponse = HealthResponses[keyof HealthResponses];

export type SummaryData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/v2/summary";
};

export type SummaryResponses = {
  200: NetworkSummary;
};

export type SummaryResponse = SummaryResponses[keyof SummaryResponses];

export type SummaryHistoryData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/v2/summary/history";
};

export type SummaryHistoryResponses = {
  200: Array<SummaryHistory>;
};

export type SummaryHistoryResponse =
  SummaryHistoryResponses[keyof SummaryHistoryResponses];

export type ClientOptions = {
  baseUrl: "https://mainnet-node-status-api.nymtech.cc" | (string & {});
};
