// due to code generated by JsonSchema
#![allow(clippy::field_reassign_with_default)]

use crate::error::MixnetContractError;
use crate::{IdentityKey, SphinxKey};
use config::defaults::{ALPHA, DEFAULT_OPERATOR_EPOCH_COST};
use cosmwasm_std::{coin, Addr, Coin, Decimal, Fraction, Uint128};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use serde_repr::{Deserialize_repr, Serialize_repr};
use std::cmp::Ordering;
use std::fmt::Display;

#[cfg_attr(feature = "ts-rs", derive(ts_rs::TS))]
#[derive(Clone, Debug, Deserialize, PartialEq, PartialOrd, Serialize, JsonSchema)]
pub struct MixNode {
    pub host: String,
    pub mix_port: u16,
    pub verloc_port: u16,
    pub http_api_port: u16,
    pub sphinx_key: SphinxKey,
    /// Base58 encoded ed25519 EdDSA public key.
    pub identity_key: IdentityKey,
    pub version: String,
}

#[derive(
    Copy,
    Clone,
    Debug,
    PartialEq,
    Eq,
    PartialOrd,
    Ord,
    Hash,
    Serialize_repr,
    Deserialize_repr,
    JsonSchema,
)]
#[repr(u8)]
pub enum Layer {
    Gateway = 0,
    One = 1,
    Two = 2,
    Three = 3,
}

#[derive(Debug, Clone, JsonSchema, PartialEq, Serialize, Deserialize, Copy)]
pub struct NodeRewardParams {
    income_global_mix: Uint128,
    k: Uint128,
    one_over_k: Decimal,
    total_epoch_uptime: u128,
    reward_blockstamp: Option<u64>,
    total_mix_stake: Uint128,
    uptime: Decimal,
}

impl NodeRewardParams {
    pub fn new(
        income_global_mix: u128,
        k: u128,
        total_epoch_uptime: u128,
        reward_blockstamp: Option<u64>,
        total_mix_stake: u128,
        uptime: u8,
    ) -> NodeRewardParams {
        let k = Uint128(k);
        NodeRewardParams {
            income_global_mix: Uint128(income_global_mix),
            k,
            one_over_k: Decimal::one() / k,
            total_epoch_uptime,
            reward_blockstamp,
            total_mix_stake: Uint128(total_mix_stake),
            uptime: Decimal::percent(uptime.into()),
        }
    }

    pub fn performance(&self) -> Decimal {
        Decimal::from_ratio(decimal_to_uint128(self.uptime), self.total_epoch_uptime)
    }

    pub fn operator_cost(&self) -> Uint128 {
        self.uptime * Uint128(DEFAULT_OPERATOR_EPOCH_COST.into())
    }

    pub fn operator_cost_decimal(&self) -> Decimal {
        uint128_to_decimal(self.operator_cost())
    }

    pub fn set_reward_blockstamp(&mut self, blockstamp: u64) {
        self.reward_blockstamp = Some(blockstamp);
    }

    pub fn alpha_decimal(&self) -> Decimal {
        Decimal::percent(ALPHA.into())
    }

    pub fn alpha(&self) -> Uint128 {
        decimal_to_uint128(self.alpha_decimal())
    }

    pub fn income_global_mix(&self) -> Uint128 {
        self.income_global_mix
    }

    pub fn income_global_mix_decimal(&self) -> Decimal {
        Decimal::from_ratio(self.income_global_mix, 1u128)
    }

    pub fn k(&self) -> Uint128 {
        self.k
    }

    pub fn k_decimal(&self) -> Decimal {
        uint128_to_decimal(self.k)    
    }

    pub fn total_mix_stake(&self) -> Uint128 {
        self.total_mix_stake
    }

    pub fn reward_blockstamp(&self) -> Result<u64, MixnetContractError> {
        self.reward_blockstamp
            .ok_or(MixnetContractError::BlockstampNotSet)
    }

    pub fn one_over_k(&self) -> Decimal {
        self.one_over_k
    }
}

#[derive(Debug)]
pub struct NodeRewardResult {
    reward: Decimal,
    lambda: Decimal,
    sigma: Decimal,
}

impl NodeRewardResult {
    pub fn reward(&self) -> Decimal {
        self.reward
    }

    pub fn lambda(&self) -> Decimal {
        self.lambda
    }

    pub fn sigma(&self) -> Decimal {
        self.sigma
    }
}

#[derive(Clone, Debug, Deserialize, PartialEq, Serialize, JsonSchema)]
pub struct MixNodeBond {
    pub bond_amount: Coin,
    pub total_delegation: Coin,
    pub owner: Addr,
    pub layer: Layer,
    pub block_height: u64,
    pub mix_node: MixNode,
    pub profit_margin_percent: Option<u8>,
}

impl MixNodeBond {
    pub fn new(
        bond_amount: Coin,
        owner: Addr,
        layer: Layer,
        block_height: u64,
        mix_node: MixNode,
        profit_margin_percent: Option<u8>,
    ) -> Self {
        MixNodeBond {
            total_delegation: coin(0, &bond_amount.denom),
            bond_amount,
            owner,
            layer,
            block_height,
            mix_node,
            profit_margin_percent,
        }
    }

    pub fn profit_margin_decimal(&self) -> Decimal {
        if let Some(margin) = self.profit_margin_percent {
            Decimal::percent(margin.into())
        } else {
            Decimal::percent(DEFAULT_PROFIT_MARGIN.into())
        }
    }

    pub fn profit_margin(&self) -> Uint128 {
        decimal_to_uint128(self.profit_margin_decimal())
    }

    pub fn identity(&self) -> &String {
        &self.mix_node.identity_key
    }

    pub fn bond_amount(&self) -> Coin {
        self.bond_amount.clone()
    }

    pub fn owner(&self) -> &Addr {
        &self.owner
    }

    pub fn mix_node(&self) -> &MixNode {
        &self.mix_node
    }

    pub fn total_delegation(&self) -> Coin {
        self.total_delegation.clone()
    }

    pub fn bond_to_total_stake(&self, total_stake: Uint128) -> Decimal {
        Decimal::from_ratio(self.bond_amount().amount, total_stake)
    }

    pub fn stake_to_total_stake(&self, total_stake: Uint128) -> Decimal {
        Decimal::from_ratio(
            self.bond_amount().amount + self.total_delegation().amount,
            total_stake,
        )
    }

    pub fn lambda(&self, params: &NodeRewardParams) -> Decimal {
        let bond_to_total_stake_ratio = self.bond_to_total_stake(params.total_mix_stake);
        bond_to_total_stake_ratio.min(params.one_over_k)
    }

    pub fn sigma(&self, params: &NodeRewardParams) -> Decimal {
        let stake_to_total_stake_ratio = self.stake_to_total_stake(params.total_mix_stake);
        stake_to_total_stake_ratio.min(params.one_over_k)
    }

    pub fn reward(
        &self,
        params: &NodeRewardParams,
    ) -> Result<NodeRewardResult, MixnetContractError> {
        // Assuming uniform work distribution across the network this is one_over_k * k
        let omega_k = Decimal::one();
        let lambda = self.lambda(params);
        let sigma = self.sigma(params);
        println!("{}", params.performance());
        println!("{}", params.income_global_mix_decimal());
        let income_fraction = mul_fraction(params.performance(), params.income_global_mix_decimal());
        let sigma_x_omega = mul_fraction(sigma, omega_k);
        let sigma_x_k = mul_fraction(sigma, params.k_decimal());
        let params_x_alpha = mul_fraction(params.alpha_decimal(), lambda);
        let after_plus_parens = mul_fraction(sigma_x_k,params_x_alpha);
        let plus_in_parens = sigma_x_omega + after_plus_parens;
        let numer = mul_fraction(income_fraction, plus_in_parens);
        let denom = Decimal::one() + params.alpha_decimal();
        let reward = Decimal::from_ratio(
            numer.numerator() * denom.denominator(),
            numer.denominator() * denom.numerator(),
        );

        Ok(NodeRewardResult {
            reward,
            lambda: lambda,
            sigma: sigma,
        })
    }

    pub fn node_profit(&self, params: &NodeRewardParams) -> Result<Decimal, MixnetContractError> {
        Ok(self.reward(params)?.reward() - params.operator_cost_decimal())
    }

    pub fn operator_profit(
        &self,
        params: &NodeRewardParams,
    ) -> Result<Decimal, MixnetContractError> {
        let reward_result = self.reward(params)?;
        let profit = reward_result.reward() - params.operator_cost_decimal();
        let lambda_over_sigma =
            decimal_to_uint128(reward_result.lambda() / decimal_to_uint128(reward_result.sigma()));
        let one_minus_margin = Decimal::one() - self.profit_margin_decimal();
        let one_minus_times_lambda_over_sigma = one_minus_margin * lambda_over_sigma;
        let left_side = self.profit_margin() + one_minus_times_lambda_over_sigma;
        let operator_reward = uint128_to_decimal(left_side * profit);
        Ok(operator_reward.max(Decimal::zero()))
    }

    pub fn sigma_ratio(&self, params: &NodeRewardParams) -> Decimal {
        if self.stake_to_total_stake(params.total_mix_stake) < params.one_over_k {
            self.stake_to_total_stake(params.total_mix_stake)
        } else {
            params.one_over_k
        }
    }

    pub fn reward_delegation(
        &self,
        delegation_amount: Uint128,
        params: &NodeRewardParams,
    ) -> Result<Decimal, MixnetContractError> {
        let scaled_delegation_amount =
            Decimal::from_ratio(delegation_amount, params.total_mix_stake);

        let delegation_over_sigma =
            scaled_delegation_amount / decimal_to_uint128(self.sigma(params));

        let one_minus_profit = Decimal::one() - self.profit_margin_decimal();
        let times_delegation_over_sigma =
            one_minus_profit * decimal_to_uint128(delegation_over_sigma);
        let delegation_reward =
            uint128_to_decimal(times_delegation_over_sigma * self.node_profit(params)?);

        Ok(delegation_reward.max(Decimal::zero()))
    }
}

impl PartialOrd for MixNodeBond {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        // first remove invalid cases
        if self.bond_amount.denom != self.total_delegation.denom {
            return None;
        }

        if other.bond_amount.denom != other.total_delegation.denom {
            return None;
        }

        if self.bond_amount.denom != other.bond_amount.denom {
            return None;
        }

        // try to order by total bond + delegation
        let total_cmp = (self.bond_amount.amount + self.total_delegation.amount)
            .partial_cmp(&(self.bond_amount.amount + self.total_delegation.amount))?;

        if total_cmp != Ordering::Equal {
            return Some(total_cmp);
        }

        // then if those are equal, prefer higher bond over delegation
        let bond_cmp = self
            .bond_amount
            .amount
            .partial_cmp(&other.bond_amount.amount)?;
        if bond_cmp != Ordering::Equal {
            return Some(bond_cmp);
        }

        // then look at delegation (I'm not sure we can get here, but better safe than sorry)
        let delegation_cmp = self
            .total_delegation
            .amount
            .partial_cmp(&other.total_delegation.amount)?;
        if delegation_cmp != Ordering::Equal {
            return Some(delegation_cmp);
        }

        // then check block height
        let height_cmp = self.block_height.partial_cmp(&other.block_height)?;
        if height_cmp != Ordering::Equal {
            return Some(height_cmp);
        }

        // finally go by the rest of the fields in order. It doesn't really matter at this point
        // but we should be deterministic.
        let owner_cmp = self.owner.partial_cmp(&other.owner)?;
        if owner_cmp != Ordering::Equal {
            return Some(owner_cmp);
        }

        let layer_cmp = self.layer.partial_cmp(&other.layer)?;
        if layer_cmp != Ordering::Equal {
            return Some(layer_cmp);
        }

        self.mix_node.partial_cmp(&other.mix_node)
    }
}

impl Display for MixNodeBond {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(
            f,
            "amount: {} {}, owner: {}, identity: {}",
            self.bond_amount.amount, self.bond_amount.denom, self.owner, self.mix_node.identity_key
        )
    }
}

#[derive(Clone, Debug, Deserialize, PartialEq, Serialize, JsonSchema)]
pub struct PagedMixnodeResponse {
    pub nodes: Vec<MixNodeBond>,
    pub per_page: usize,
    pub start_next_after: Option<IdentityKey>,
}

impl PagedMixnodeResponse {
    pub fn new(
        nodes: Vec<MixNodeBond>,
        per_page: usize,
        start_next_after: Option<IdentityKey>,
    ) -> Self {
        PagedMixnodeResponse {
            nodes,
            per_page,
            start_next_after,
        }
    }
}

#[derive(Clone, Debug, Deserialize, PartialEq, Serialize, JsonSchema)]
pub struct MixOwnershipResponse {
    pub address: Addr,
    pub has_node: bool,
}

#[cfg(test)]
mod tests {
    use super::*;

    fn mixnode_fixture() -> MixNode {
        MixNode {
            host: "1.1.1.1".to_string(),
            mix_port: 123,
            verloc_port: 456,
            http_api_port: 789,
            sphinx_key: "sphinxkey".to_string(),
            identity_key: "identitykey".to_string(),
            version: "0.11.0".to_string(),
        }
    }

    #[test]
    fn mixnode_bond_partial_ord() {
        let _150foos = Coin::new(150, "foo");
        let _50foos = Coin::new(50, "foo");
        let _0foos = Coin::new(0, "foo");

        let mix1 = MixNodeBond {
            bond_amount: _150foos.clone(),
            total_delegation: _50foos.clone(),
            owner: Addr::unchecked("foo1"),
            layer: Layer::One,
            block_height: 100,
            mix_node: mixnode_fixture(),
            profit_margin_percent: None,
        };

        let mix2 = MixNodeBond {
            bond_amount: _150foos.clone(),
            total_delegation: _50foos.clone(),
            owner: Addr::unchecked("foo2"),
            layer: Layer::One,
            block_height: 120,
            mix_node: mixnode_fixture(),
            profit_margin_percent: None,
        };

        let mix3 = MixNodeBond {
            bond_amount: _50foos,
            total_delegation: _150foos.clone(),
            owner: Addr::unchecked("foo3"),
            layer: Layer::One,
            block_height: 120,
            mix_node: mixnode_fixture(),
            profit_margin_percent: None,
        };

        let mix4 = MixNodeBond {
            bond_amount: _150foos.clone(),
            total_delegation: _0foos.clone(),
            owner: Addr::unchecked("foo4"),
            layer: Layer::One,
            block_height: 120,
            mix_node: mixnode_fixture(),
            profit_margin_percent: None,
        };

        let mix5 = MixNodeBond {
            bond_amount: _0foos,
            total_delegation: _150foos,
            owner: Addr::unchecked("foo5"),
            layer: Layer::One,
            block_height: 120,
            mix_node: mixnode_fixture(),
            profit_margin_percent: None,
        };

        // summary:
        // mix1: 150bond + 50delegation, foo1, 100
        // mix2: 150bond + 50delegation, foo2, 120
        // mix3: 50bond + 150delegation, foo3, 120
        // mix4: 150bond + 0delegation, foo4, 120
        // mix5: 0bond + 150delegation, foo5, 120

        // highest total bond+delegation is used
        // then bond followed by delegation
        // finally just the rest of the fields

        // mix1 has higher total than mix4 or mix5
        assert!(mix1 > mix4);
        assert!(mix1 > mix5);

        // mix1 has the same total as mix3, however, mix1 has more tokens in bond
        assert!(mix1 > mix3);
        // same case for mix4 and mix5
        assert!(mix4 > mix5);

        // same bond and delegation, so it's just ordered by height
        assert!(mix1 < mix2);
    }
}
