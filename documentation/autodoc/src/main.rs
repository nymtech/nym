use log::info;
use std::fs::File;
use std::io::{self, Write};
use std::process::{Command, Output};
use std::{fs, vec};

const PATH: &str = "./autodoc-generated-markdown/";

fn main() -> io::Result<()> {
    env_logger::init();

    // TODO try and write to grab the commands from Clap at some point
    let commands_with_subcommands = vec![
        (
            "../../target/release/nym-api",
            vec!["init", "run", "build-info"],
        ),
        (
            "../../target/release/nym-client",
            vec![
                "init",
                "run",
                "import-credential",
                "list-gateways",
                "switch-gateway",
                "build-info",
                "completions",
                "generate-fig-spec",
            ],
        ),
        (
            "../../target/release/nym-socks5-client",
            vec![
                "init",
                "run",
                "import-credential",
                "list-gateways",
                "add-gateway",
                "build-info",
                "completions",
                "generate-fig-spec",
            ],
        ),
        (
            "../../target/release/nym-node",
            vec![
                "build-info",
                "bonding-information",
                "node-details",
                "migrate",
                "run",
                "sign",
            ],
        ),
        (
            "../../target/release/nymvisor",
            vec![
                "init",
                "run",
                "build-info",
                "daemon-build-info",
                "add-upgrade",
                "config",
            ],
        ),
    ];

    let commands_with_subsubcommands = vec![(
        "../../target/release/nym-cli",
        vec![
            (
                "account",
                vec!["create", "balance", "pub-key", "send", "send-multiple"],
            ),
            ("signature", vec!["sign", "verify"]),
            (
                "coconut",
                vec![
                    "generate-freepass",
                    "issue-credentials",
                    "recover-credentials",
                    "import-credential",
                ],
            ),
            ("block", vec!["get", "time", "current-height"]),
            (
                "cosmwasm",
                vec![
                    "upload",
                    "init",
                    "generate-init-message",
                    "migrate",
                    "execute",
                ],
            ),
            ("tx", vec!["get", "query"]),
            (
                "vesting-schedule",
                vec!["create", "query", "vested-balance", "withdraw-vested"],
            ),
            ("mixnet", vec!["query", "delegators", "operators"]),
            ("generate-fig", vec![""]),
        ],
    )];

    for (main_command, subcommands) in commands_with_subcommands {
        let last_word = get_last_word_from_filepath(main_command);
        info!("{last_word:#?}");

        if !fs::metadata(PATH)
            .map(|metadata| metadata.is_dir())
            .unwrap_or(false)
        {
            fs::create_dir_all(PATH)?;
        }

        let mut file = File::create(format!("{}/{}-commands.md", PATH, last_word.unwrap()))?;
        writeln!(
            file,
            "# {} Binary Commands",
            format!("`{}`", last_word.unwrap())
        )?;
        writeln!(
            file,
            "\nThese docs are autogenerated by the `autodocs` script. 
            \n**TODO add link**"
        )?;
        let output = Command::new(main_command).arg("--help").output()?;
        write_output_to_file(&mut file, output)?;

        for subcommand in subcommands {
            execute_command(&mut file, main_command, subcommand, None)?;
        }
    }

    // nym-cli has subsubcommands so needs its own loop
    for (main_command, subcommands) in &commands_with_subsubcommands {
        let last_word = get_last_word_from_filepath(main_command);
        info!("{last_word:#?}");
        let mut file = File::create(format!("{}/{}-commands.md", PATH, last_word.unwrap()))?;
        writeln!(
            file,
            "# {} Binary Commands",
            format!("`{}`", last_word.unwrap())
        )?;
        writeln!(
            file,
            "\nThese docs are autogenerated by the `autodocs` script. 
            \n**TODO add link**"
        )?;
        let output = Command::new(main_command).arg("--help").output()?;

        write_output_to_file(&mut file, output)?;

        for (subcommand, subsubcommands) in subcommands {
            writeln!(file, "\n### `{}` ", subcommand)?;
            let output = Command::new(main_command)
                .arg(subcommand)
                .arg("--help")
                .output()?;
            if !output.stdout.is_empty() {
                write_output_to_file(&mut file, output)?;
            } else {
                info!("empty stdout - nothing to write");
            }
            for subsubcommand in subsubcommands {
                execute_command(&mut file, main_command, subcommand, Some(subsubcommand))?;
                /*
                println!(
                    "{:#?} {:#?} {:#?}",
                    last_word.unwrap(),
                    subcommand,
                    subsubcommand
                );
                */
            }
        }
    }

    Ok(())
}

fn get_last_word_from_filepath(filepath: &str) -> Option<&str> {
    let parts: Vec<&str> = filepath.split('/').collect();
    parts.last().copied()
}

fn execute_command(
    file: &mut File,
    main_command: &str,
    subcommand: &str,
    subsubcommand: Option<&str>,
) -> io::Result<()> {
    // checking for the nym-cli subsubcommands
    if subsubcommand.is_some() {
        writeln!(file, "\n### `{} {}`", subcommand, subsubcommand.unwrap())?;

        info!("executing {} {} --help ", main_command, subcommand);
        let output = Command::new(main_command)
            .arg(subcommand)
            .arg(subsubcommand.unwrap())
            .arg("--help")
            .output()?;
        if !output.stdout.is_empty() {
            write_output_to_file(file, output)?;
        } else {
            info!("empty stdout - nothing to write");
        }
    // just subcommands
    } else {
        writeln!(file, "\n### `{}`", subcommand)?;

        // println!("{}", subcommand);
        // execute help
        let output = Command::new(main_command)
            .arg(subcommand)
            .arg("--help")
            .output()?;
        if !output.stdout.is_empty() {
            write_output_to_file(file, output)?;
        } else {
            info!("empty stdout - nothing to write");
        }

        // then execute w/out help: the majority of functions will fail since you're not passing
        // required params but thats fine as we can just not render stderr into the final file.
        //
        // this check is basically checking for the rare commands (rn just one) that start a process with no params
        // perhaps if this list grows we could just add a timeout and shunt the running and writing
        // into a thread with a timeout or something but for right now its fine / thats overkill
        if get_last_word_from_filepath(main_command).unwrap() == "nym-node"
            || get_last_word_from_filepath(main_command).unwrap() == "nym-api"
            || get_last_word_from_filepath(main_command).unwrap() == "nymvisor"
                && subcommand == "run"
        {
            info!("SKIPPING {} {}", main_command, subcommand);
        } else {
            info!("executing {} {}", main_command, subcommand);
            let output = Command::new(main_command).arg(subcommand).output()?;
            if !output.stdout.is_empty() {
                writeln!(file, "Example output:")?;
                write_output_to_file(file, output)?;
            } else {
                info!("empty stdout - nothing to write");
                if !&output.stderr.is_empty() {
                    info!("stderr: {:#?}", String::from_utf8_lossy(&output.stderr));
                }
            }
        }
    }
    Ok(())
}

/*
 fn execute_command(file: &mut File, main_command: &str, subcommand: &str) -> io::Result<()> {
    // title
    writeln!(file, "\n### `{}`", subcommand)?;

    // first execute the command with `--help`
    info!("executing {} {} --help ", main_command, subcommand);
    let output = Command::new(main_command)
        .arg(subcommand)
        .arg("--help")
        .output()?;
    if !output.stdout.is_empty() {
        write_output_to_file(file, output)?;
    } else {
        info!("empty stdout - nothing to write");
    }

    // then execute w/out help: the majority of functions will fail since you're not passing
    // required params but thats fine as we can just not render stderr into the final file.
    //
    // this check is basically checking for the rare commands (rn just one) that start a process with no params
    // perhaps if this list grows we could just add a timeout and shunt the running and writing
    // into a thread with a timeout or something but for right now its fine / thats overkill
    if get_last_word_from_filepath(main_command).unwrap() == "nym-node"
        || get_last_word_from_filepath(main_command).unwrap() == "nym-api"
        || get_last_word_from_filepath(main_command).unwrap() == "nymvisor" && subcommand == "run"
    {
        info!("SKIPPING {} {}", main_command, subcommand);
    } else {
        info!("executing {} {}", main_command, subcommand);
        let output = Command::new(main_command).arg(subcommand).output()?;
        if !output.stdout.is_empty() {
            writeln!(file, "Example output:")?;
            write_output_to_file(file, output)?;
        } else {
            info!("empty stdout - nothing to write");
            if !&output.stderr.is_empty() {
                info!("stderr: {:#?}", String::from_utf8_lossy(&output.stderr));
            }
        }
    }
    Ok(())
}
*/

fn write_output_to_file(file: &mut File, output: Output) -> io::Result<()> {
    writeln!(file, "```")?;
    file.write_all(&output.stdout)?;
    writeln!(file, "```")?;

    // if we want to keep this we could create 2 copies if you run this in a certain mode ("debug"
    // oder so) so you can see the stderr but in reality, we want dont want the errors in teh md
    // file and also probaly not write 'stdout', but just have <command><output> in a clean fashion
    if !&output.stderr.is_empty() {
        info!("stderr: {:#?}", String::from_utf8_lossy(&output.stderr));
    }
    Ok(())
}
