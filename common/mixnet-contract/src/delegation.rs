// Copyright 2021 - Nym Technologies SA <contact@nymtech.net>
// SPDX-License-Identifier: Apache-2.0

// due to code generated by JsonSchema
#![allow(clippy::field_reassign_with_default)]

use crate::{Addr, IdentityKey};
use cosmwasm_std::{Coin, Uint128};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use std::fmt::Display;

#[derive(Clone, Debug, Deserialize, Serialize, PartialEq, JsonSchema)]
pub struct _Delegation {
    pub owner: Addr,
    pub node_identity: IdentityKey,
    pub amount: Coin,
    pub block_height: u64,
}

impl _Delegation {
    pub fn new(owner: Addr, node_identity: IdentityKey, amount: Coin, block_height: u64) -> Self {
        _Delegation {
            owner,
            node_identity,
            amount,
            block_height,
        }
    }

    pub fn storage_key(&self) -> (IdentityKey, Addr) {
        (self.node_identity(), self.owner())
    }

    pub fn increment_amount(&mut self, amount: Uint128, at_height: Option<u64>) {
        self.amount.amount += amount;
        if let Some(at_height) = at_height {
            self.block_height = at_height;
        }
    }

    pub fn amount(&self) -> &Coin {
        &self.amount
    }

    pub fn node_identity(&self) -> IdentityKey {
        self.node_identity.clone()
    }

    pub fn owner(&self) -> Addr {
        self.owner.clone()
    }

    pub fn block_height(&self) -> u64 {
        self.block_height
    }
}

#[derive(Clone, Debug, Deserialize, PartialEq, Serialize, JsonSchema)]
pub struct UnpackedDelegation<T> {
    pub owner: Addr,
    pub node_identity: IdentityKey,
    pub delegation_data: T,
}

impl<T> UnpackedDelegation<T> {
    pub fn new(owner: Addr, node_identity: IdentityKey, delegation_data: T) -> Self {
        UnpackedDelegation {
            owner,
            node_identity,
            delegation_data,
        }
    }
}

#[derive(Clone, Debug, Deserialize, PartialEq, Serialize, JsonSchema)]
pub struct RawDelegationData {
    pub amount: Uint128,
    pub block_height: u64,
}

impl RawDelegationData {
    pub fn new(amount: Uint128, block_height: u64) -> Self {
        RawDelegationData {
            amount,
            block_height,
        }
    }
}

#[derive(Clone, Debug, Deserialize, PartialEq, Serialize, JsonSchema)]
pub struct Delegation {
    owner: Addr,
    amount: Coin,
    block_height: u64,
}

impl Delegation {
    pub fn new(owner: Addr, amount: Coin, block_height: u64) -> Self {
        Delegation {
            owner,
            amount,
            block_height,
        }
    }

    pub fn amount(&self) -> &Coin {
        &self.amount
    }

    pub fn owner(&self) -> Addr {
        self.owner.clone()
    }

    pub fn block_height(&self) -> u64 {
        self.block_height
    }
}

impl Display for Delegation {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(
            f,
            "{} {} delegated by {} at block {}",
            self.amount.amount, self.amount.denom, self.owner, self.block_height
        )
    }
}

#[derive(Clone, Debug, Deserialize, PartialEq, Serialize, JsonSchema)]
pub struct PagedMixDelegationsResponse {
    pub delegations: Vec<_Delegation>,
    pub start_next_after: Option<Addr>,
}

impl PagedMixDelegationsResponse {
    pub fn new(delegations: Vec<_Delegation>, start_next_after: Option<Addr>) -> Self {
        PagedMixDelegationsResponse {
            delegations,
            start_next_after,
        }
    }
}

#[derive(Clone, Debug, Deserialize, PartialEq, Serialize, JsonSchema)]
pub struct PagedDelegatorDelegationsResponse {
    pub delegations: Vec<_Delegation>,
    pub start_next_after: Option<IdentityKey>,
}

impl PagedDelegatorDelegationsResponse {
    pub fn new(delegations: Vec<_Delegation>, start_next_after: Option<IdentityKey>) -> Self {
        PagedDelegatorDelegationsResponse {
            delegations,
            start_next_after,
        }
    }
}

#[derive(Clone, Debug, Deserialize, PartialEq, Serialize, JsonSchema)]
pub struct PagedAllDelegationsResponse {
    pub delegations: Vec<_Delegation>,
    pub start_next_after: Option<(IdentityKey, Addr)>,
}

impl PagedAllDelegationsResponse {
    pub fn new(
        delegations: Vec<_Delegation>,
        start_next_after: Option<(IdentityKey, Addr)>,
    ) -> Self {
        PagedAllDelegationsResponse {
            delegations,
            start_next_after,
        }
    }
}
