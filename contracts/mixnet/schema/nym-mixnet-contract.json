{
  "contract_name": "nym-mixnet-contract",
  "contract_version": "1.5.1",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "type": "object",
    "required": [
      "epoch_duration",
      "epochs_in_interval",
      "initial_rewarding_params",
      "rewarding_denom",
      "rewarding_validator_address",
      "vesting_contract_address"
    ],
    "properties": {
      "epoch_duration": {
        "$ref": "#/definitions/Duration"
      },
      "epochs_in_interval": {
        "type": "integer",
        "format": "uint32",
        "minimum": 0.0
      },
      "initial_rewarding_params": {
        "$ref": "#/definitions/InitialRewardingParams"
      },
      "rewarding_denom": {
        "type": "string"
      },
      "rewarding_validator_address": {
        "type": "string"
      },
      "vesting_contract_address": {
        "type": "string"
      }
    },
    "additionalProperties": false,
    "definitions": {
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "Duration": {
        "type": "object",
        "required": [
          "nanos",
          "secs"
        ],
        "properties": {
          "nanos": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0.0
          },
          "secs": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          }
        }
      },
      "InitialRewardingParams": {
        "type": "object",
        "required": [
          "active_set_size",
          "active_set_work_factor",
          "initial_reward_pool",
          "initial_staking_supply",
          "interval_pool_emission",
          "rewarded_set_size",
          "staking_supply_scale_factor",
          "sybil_resistance"
        ],
        "properties": {
          "active_set_size": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0.0
          },
          "active_set_work_factor": {
            "$ref": "#/definitions/Decimal"
          },
          "initial_reward_pool": {
            "$ref": "#/definitions/Decimal"
          },
          "initial_staking_supply": {
            "$ref": "#/definitions/Decimal"
          },
          "interval_pool_emission": {
            "$ref": "#/definitions/Percent"
          },
          "rewarded_set_size": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0.0
          },
          "staking_supply_scale_factor": {
            "$ref": "#/definitions/Percent"
          },
          "sybil_resistance": {
            "$ref": "#/definitions/Percent"
          }
        },
        "additionalProperties": false
      },
      "Percent": {
        "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
        "allOf": [
          {
            "$ref": "#/definitions/Decimal"
          }
        ]
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "assign_node_layer"
        ],
        "properties": {
          "assign_node_layer": {
            "type": "object",
            "required": [
              "layer",
              "mix_id"
            ],
            "properties": {
              "layer": {
                "$ref": "#/definitions/Layer"
              },
              "mix_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Only owner of the node can crate the family with node as head",
        "type": "object",
        "required": [
          "create_family"
        ],
        "properties": {
          "create_family": {
            "type": "object",
            "required": [
              "label"
            ],
            "properties": {
              "label": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Family head needs to sign the joining node IdentityKey",
        "type": "object",
        "required": [
          "join_family"
        ],
        "properties": {
          "join_family": {
            "type": "object",
            "required": [
              "family_head",
              "join_permit"
            ],
            "properties": {
              "family_head": {
                "$ref": "#/definitions/FamilyHead"
              },
              "join_permit": {
                "$ref": "#/definitions/MessageSignature"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "leave_family"
        ],
        "properties": {
          "leave_family": {
            "type": "object",
            "required": [
              "family_head"
            ],
            "properties": {
              "family_head": {
                "$ref": "#/definitions/FamilyHead"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "kick_family_member"
        ],
        "properties": {
          "kick_family_member": {
            "type": "object",
            "required": [
              "member"
            ],
            "properties": {
              "member": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "create_family_on_behalf"
        ],
        "properties": {
          "create_family_on_behalf": {
            "type": "object",
            "required": [
              "label",
              "owner_address"
            ],
            "properties": {
              "label": {
                "type": "string"
              },
              "owner_address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Family head needs to sign the joining node IdentityKey, MixNode needs to provide its signature proving that it wants to join the family",
        "type": "object",
        "required": [
          "join_family_on_behalf"
        ],
        "properties": {
          "join_family_on_behalf": {
            "type": "object",
            "required": [
              "family_head",
              "join_permit",
              "member_address"
            ],
            "properties": {
              "family_head": {
                "$ref": "#/definitions/FamilyHead"
              },
              "join_permit": {
                "$ref": "#/definitions/MessageSignature"
              },
              "member_address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "leave_family_on_behalf"
        ],
        "properties": {
          "leave_family_on_behalf": {
            "type": "object",
            "required": [
              "family_head",
              "member_address"
            ],
            "properties": {
              "family_head": {
                "$ref": "#/definitions/FamilyHead"
              },
              "member_address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "kick_family_member_on_behalf"
        ],
        "properties": {
          "kick_family_member_on_behalf": {
            "type": "object",
            "required": [
              "head_address",
              "member"
            ],
            "properties": {
              "head_address": {
                "type": "string"
              },
              "member": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_rewarding_validator_address"
        ],
        "properties": {
          "update_rewarding_validator_address": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_contract_state_params"
        ],
        "properties": {
          "update_contract_state_params": {
            "type": "object",
            "required": [
              "updated_parameters"
            ],
            "properties": {
              "updated_parameters": {
                "$ref": "#/definitions/ContractStateParams"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_active_set_size"
        ],
        "properties": {
          "update_active_set_size": {
            "type": "object",
            "required": [
              "active_set_size",
              "force_immediately"
            ],
            "properties": {
              "active_set_size": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              "force_immediately": {
                "type": "boolean"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_rewarding_params"
        ],
        "properties": {
          "update_rewarding_params": {
            "type": "object",
            "required": [
              "force_immediately",
              "updated_params"
            ],
            "properties": {
              "force_immediately": {
                "type": "boolean"
              },
              "updated_params": {
                "$ref": "#/definitions/IntervalRewardingParamsUpdate"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_interval_config"
        ],
        "properties": {
          "update_interval_config": {
            "type": "object",
            "required": [
              "epoch_duration_secs",
              "epochs_in_interval",
              "force_immediately"
            ],
            "properties": {
              "epoch_duration_secs": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              },
              "epochs_in_interval": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              "force_immediately": {
                "type": "boolean"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "begin_epoch_transition"
        ],
        "properties": {
          "begin_epoch_transition": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "advance_current_epoch"
        ],
        "properties": {
          "advance_current_epoch": {
            "type": "object",
            "required": [
              "expected_active_set_size",
              "new_rewarded_set"
            ],
            "properties": {
              "expected_active_set_size": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              "new_rewarded_set": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/LayerAssignment"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "reconcile_epoch_events"
        ],
        "properties": {
          "reconcile_epoch_events": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "bond_mixnode"
        ],
        "properties": {
          "bond_mixnode": {
            "type": "object",
            "required": [
              "cost_params",
              "mix_node",
              "owner_signature"
            ],
            "properties": {
              "cost_params": {
                "$ref": "#/definitions/MixNodeCostParams"
              },
              "mix_node": {
                "$ref": "#/definitions/MixNode"
              },
              "owner_signature": {
                "$ref": "#/definitions/MessageSignature"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "bond_mixnode_on_behalf"
        ],
        "properties": {
          "bond_mixnode_on_behalf": {
            "type": "object",
            "required": [
              "cost_params",
              "mix_node",
              "owner",
              "owner_signature"
            ],
            "properties": {
              "cost_params": {
                "$ref": "#/definitions/MixNodeCostParams"
              },
              "mix_node": {
                "$ref": "#/definitions/MixNode"
              },
              "owner": {
                "type": "string"
              },
              "owner_signature": {
                "$ref": "#/definitions/MessageSignature"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "pledge_more"
        ],
        "properties": {
          "pledge_more": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "pledge_more_on_behalf"
        ],
        "properties": {
          "pledge_more_on_behalf": {
            "type": "object",
            "required": [
              "owner"
            ],
            "properties": {
              "owner": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "decrease_pledge"
        ],
        "properties": {
          "decrease_pledge": {
            "type": "object",
            "required": [
              "decrease_by"
            ],
            "properties": {
              "decrease_by": {
                "$ref": "#/definitions/Coin"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "decrease_pledge_on_behalf"
        ],
        "properties": {
          "decrease_pledge_on_behalf": {
            "type": "object",
            "required": [
              "decrease_by",
              "owner"
            ],
            "properties": {
              "decrease_by": {
                "$ref": "#/definitions/Coin"
              },
              "owner": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "unbond_mixnode"
        ],
        "properties": {
          "unbond_mixnode": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "unbond_mixnode_on_behalf"
        ],
        "properties": {
          "unbond_mixnode_on_behalf": {
            "type": "object",
            "required": [
              "owner"
            ],
            "properties": {
              "owner": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_mixnode_cost_params"
        ],
        "properties": {
          "update_mixnode_cost_params": {
            "type": "object",
            "required": [
              "new_costs"
            ],
            "properties": {
              "new_costs": {
                "$ref": "#/definitions/MixNodeCostParams"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_mixnode_cost_params_on_behalf"
        ],
        "properties": {
          "update_mixnode_cost_params_on_behalf": {
            "type": "object",
            "required": [
              "new_costs",
              "owner"
            ],
            "properties": {
              "new_costs": {
                "$ref": "#/definitions/MixNodeCostParams"
              },
              "owner": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_mixnode_config"
        ],
        "properties": {
          "update_mixnode_config": {
            "type": "object",
            "required": [
              "new_config"
            ],
            "properties": {
              "new_config": {
                "$ref": "#/definitions/MixNodeConfigUpdate"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_mixnode_config_on_behalf"
        ],
        "properties": {
          "update_mixnode_config_on_behalf": {
            "type": "object",
            "required": [
              "new_config",
              "owner"
            ],
            "properties": {
              "new_config": {
                "$ref": "#/definitions/MixNodeConfigUpdate"
              },
              "owner": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "bond_gateway"
        ],
        "properties": {
          "bond_gateway": {
            "type": "object",
            "required": [
              "gateway",
              "owner_signature"
            ],
            "properties": {
              "gateway": {
                "$ref": "#/definitions/Gateway"
              },
              "owner_signature": {
                "$ref": "#/definitions/MessageSignature"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "bond_gateway_on_behalf"
        ],
        "properties": {
          "bond_gateway_on_behalf": {
            "type": "object",
            "required": [
              "gateway",
              "owner",
              "owner_signature"
            ],
            "properties": {
              "gateway": {
                "$ref": "#/definitions/Gateway"
              },
              "owner": {
                "type": "string"
              },
              "owner_signature": {
                "$ref": "#/definitions/MessageSignature"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "unbond_gateway"
        ],
        "properties": {
          "unbond_gateway": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "unbond_gateway_on_behalf"
        ],
        "properties": {
          "unbond_gateway_on_behalf": {
            "type": "object",
            "required": [
              "owner"
            ],
            "properties": {
              "owner": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_gateway_config"
        ],
        "properties": {
          "update_gateway_config": {
            "type": "object",
            "required": [
              "new_config"
            ],
            "properties": {
              "new_config": {
                "$ref": "#/definitions/GatewayConfigUpdate"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_gateway_config_on_behalf"
        ],
        "properties": {
          "update_gateway_config_on_behalf": {
            "type": "object",
            "required": [
              "new_config",
              "owner"
            ],
            "properties": {
              "new_config": {
                "$ref": "#/definitions/GatewayConfigUpdate"
              },
              "owner": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "delegate_to_mixnode"
        ],
        "properties": {
          "delegate_to_mixnode": {
            "type": "object",
            "required": [
              "mix_id"
            ],
            "properties": {
              "mix_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "delegate_to_mixnode_on_behalf"
        ],
        "properties": {
          "delegate_to_mixnode_on_behalf": {
            "type": "object",
            "required": [
              "delegate",
              "mix_id"
            ],
            "properties": {
              "delegate": {
                "type": "string"
              },
              "mix_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "undelegate_from_mixnode"
        ],
        "properties": {
          "undelegate_from_mixnode": {
            "type": "object",
            "required": [
              "mix_id"
            ],
            "properties": {
              "mix_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "undelegate_from_mixnode_on_behalf"
        ],
        "properties": {
          "undelegate_from_mixnode_on_behalf": {
            "type": "object",
            "required": [
              "delegate",
              "mix_id"
            ],
            "properties": {
              "delegate": {
                "type": "string"
              },
              "mix_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "reward_mixnode"
        ],
        "properties": {
          "reward_mixnode": {
            "type": "object",
            "required": [
              "mix_id",
              "performance"
            ],
            "properties": {
              "mix_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              "performance": {
                "$ref": "#/definitions/Percent"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "withdraw_operator_reward"
        ],
        "properties": {
          "withdraw_operator_reward": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "withdraw_operator_reward_on_behalf"
        ],
        "properties": {
          "withdraw_operator_reward_on_behalf": {
            "type": "object",
            "required": [
              "owner"
            ],
            "properties": {
              "owner": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "withdraw_delegator_reward"
        ],
        "properties": {
          "withdraw_delegator_reward": {
            "type": "object",
            "required": [
              "mix_id"
            ],
            "properties": {
              "mix_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "withdraw_delegator_reward_on_behalf"
        ],
        "properties": {
          "withdraw_delegator_reward_on_behalf": {
            "type": "object",
            "required": [
              "mix_id",
              "owner"
            ],
            "properties": {
              "mix_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              "owner": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "ContractStateParams": {
        "description": "Contract parameters that could be adjusted in a transaction by the contract admin.",
        "type": "object",
        "required": [
          "minimum_gateway_pledge",
          "minimum_mixnode_pledge"
        ],
        "properties": {
          "minimum_gateway_pledge": {
            "description": "Minimum amount a gateway must pledge to get into the system.",
            "allOf": [
              {
                "$ref": "#/definitions/Coin"
              }
            ]
          },
          "minimum_mixnode_delegation": {
            "description": "Minimum amount a delegator must stake in orders for his delegation to get accepted.",
            "anyOf": [
              {
                "$ref": "#/definitions/Coin"
              },
              {
                "type": "null"
              }
            ]
          },
          "minimum_mixnode_pledge": {
            "description": "Minimum amount a mixnode must pledge to get into the system.",
            "allOf": [
              {
                "$ref": "#/definitions/Coin"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "FamilyHead": {
        "description": "Head of particular family as identified by its identity key (i.e. public component of its ed25519 keypair stringified into base58).",
        "type": "string"
      },
      "Gateway": {
        "description": "Information provided by the node operator during bonding that are used to allow other entities to use the services of this node.",
        "type": "object",
        "required": [
          "clients_port",
          "host",
          "identity_key",
          "location",
          "mix_port",
          "sphinx_key",
          "version"
        ],
        "properties": {
          "clients_port": {
            "description": "Port used by this gateway for listening for client requests.",
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "host": {
            "description": "Network address of this gateway, for example 1.1.1.1 or foo.gateway.com",
            "type": "string"
          },
          "identity_key": {
            "description": "Base58 encoded ed25519 EdDSA public key of the gateway used to derive shared keys with clients",
            "type": "string"
          },
          "location": {
            "description": "The physical, self-reported, location of this gateway.",
            "type": "string"
          },
          "mix_port": {
            "description": "Port used by this gateway for listening for mix packets.",
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "sphinx_key": {
            "description": "Base58-encoded x25519 public key used for sphinx key derivation.",
            "type": "string"
          },
          "version": {
            "description": "The self-reported semver version of this gateway.",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "GatewayConfigUpdate": {
        "type": "object",
        "required": [
          "clients_port",
          "host",
          "location",
          "mix_port",
          "version"
        ],
        "properties": {
          "clients_port": {
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "host": {
            "type": "string"
          },
          "location": {
            "type": "string"
          },
          "mix_port": {
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "version": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "IntervalRewardingParamsUpdate": {
        "description": "Specification on how the rewarding params should be updated.",
        "type": "object",
        "properties": {
          "active_set_work_factor": {
            "description": "Defines the new value of the active set work factor.",
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "interval_pool_emission": {
            "description": "Defines the new value of the interval pool emission rate.",
            "anyOf": [
              {
                "$ref": "#/definitions/Percent"
              },
              {
                "type": "null"
              }
            ]
          },
          "reward_pool": {
            "description": "Defines the new value of the reward pool.",
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "rewarded_set_size": {
            "description": "Defines the new size of the rewarded set.",
            "type": [
              "integer",
              "null"
            ],
            "format": "uint32",
            "minimum": 0.0
          },
          "staking_supply": {
            "description": "Defines the new value of the staking supply.",
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "staking_supply_scale_factor": {
            "description": "Defines the new value of the staking supply scale factor.",
            "anyOf": [
              {
                "$ref": "#/definitions/Percent"
              },
              {
                "type": "null"
              }
            ]
          },
          "sybil_resistance_percent": {
            "description": "Defines the new value of the sybil resistance percent.",
            "anyOf": [
              {
                "$ref": "#/definitions/Percent"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "Layer": {
        "type": "string",
        "enum": [
          "One",
          "Two",
          "Three"
        ]
      },
      "LayerAssignment": {
        "description": "Specifies layer assignment for the given mixnode.",
        "type": "object",
        "required": [
          "layer",
          "mix_id"
        ],
        "properties": {
          "layer": {
            "description": "The layer to which it's going to be assigned",
            "allOf": [
              {
                "$ref": "#/definitions/Layer"
              }
            ]
          },
          "mix_id": {
            "description": "The id of the mixnode.",
            "type": "integer",
            "format": "uint32",
            "minimum": 0.0
          }
        },
        "additionalProperties": false
      },
      "MessageSignature": {
        "type": "array",
        "items": {
          "type": "integer",
          "format": "uint8",
          "minimum": 0.0
        }
      },
      "MixNode": {
        "description": "Information provided by the node operator during bonding that are used to allow other entities to use the services of this node.",
        "type": "object",
        "required": [
          "host",
          "http_api_port",
          "identity_key",
          "mix_port",
          "sphinx_key",
          "verloc_port",
          "version"
        ],
        "properties": {
          "host": {
            "description": "Network address of this mixnode, for example 1.1.1.1 or foo.mixnode.com",
            "type": "string"
          },
          "http_api_port": {
            "description": "Port used by this mixnode for its http(s) API",
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "identity_key": {
            "description": "Base58-encoded ed25519 EdDSA public key.",
            "type": "string"
          },
          "mix_port": {
            "description": "Port used by this mixnode for listening for mix packets.",
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "sphinx_key": {
            "description": "Base58-encoded x25519 public key used for sphinx key derivation.",
            "type": "string"
          },
          "verloc_port": {
            "description": "Port used by this mixnode for listening for verloc requests.",
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "version": {
            "description": "The self-reported semver version of this mixnode.",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "MixNodeConfigUpdate": {
        "type": "object",
        "required": [
          "host",
          "http_api_port",
          "mix_port",
          "verloc_port",
          "version"
        ],
        "properties": {
          "host": {
            "type": "string"
          },
          "http_api_port": {
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "mix_port": {
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "verloc_port": {
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "version": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "MixNodeCostParams": {
        "description": "The cost parameters, or the cost function, defined for the particular mixnode that influences how the rewards should be split between the node operator and its delegators.",
        "type": "object",
        "required": [
          "interval_operating_cost",
          "profit_margin_percent"
        ],
        "properties": {
          "interval_operating_cost": {
            "description": "Operating cost of the associated mixnode per the entire interval.",
            "allOf": [
              {
                "$ref": "#/definitions/Coin"
              }
            ]
          },
          "profit_margin_percent": {
            "description": "The profit margin of the associated mixnode, i.e. the desired percent of the reward to be distributed to the operator.",
            "allOf": [
              {
                "$ref": "#/definitions/Percent"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "Percent": {
        "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
        "allOf": [
          {
            "$ref": "#/definitions/Decimal"
          }
        ]
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "description": "Gets the list of families registered in this contract.",
        "type": "object",
        "required": [
          "get_all_families_paged"
        ],
        "properties": {
          "get_all_families_paged": {
            "type": "object",
            "properties": {
              "limit": {
                "description": "Controls the maximum number of entries returned by the query. Note that too large values will be overwritten by a saner default.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "Pagination control for the values returned by the query. Note that the provided value itself will **not** be used for the response.",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the list of all family members registered in this contract.",
        "type": "object",
        "required": [
          "get_all_members_paged"
        ],
        "properties": {
          "get_all_members_paged": {
            "type": "object",
            "properties": {
              "limit": {
                "description": "Controls the maximum number of entries returned by the query. Note that too large values will be overwritten by a saner default.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "Pagination control for the values returned by the query. Note that the provided value itself will **not** be used for the response.",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Attempts to lookup family information given the family head.",
        "type": "object",
        "required": [
          "get_family_by_head"
        ],
        "properties": {
          "get_family_by_head": {
            "type": "object",
            "required": [
              "head"
            ],
            "properties": {
              "head": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Attempts to lookup family information given the family label.",
        "type": "object",
        "required": [
          "get_family_by_label"
        ],
        "properties": {
          "get_family_by_label": {
            "type": "object",
            "required": [
              "label"
            ],
            "properties": {
              "label": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Attempts to retrieve family members given the family head.",
        "type": "object",
        "required": [
          "get_family_members_by_head"
        ],
        "properties": {
          "get_family_members_by_head": {
            "type": "object",
            "required": [
              "head"
            ],
            "properties": {
              "head": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Attempts to retrieve family members given the family label.",
        "type": "object",
        "required": [
          "get_family_members_by_label"
        ],
        "properties": {
          "get_family_members_by_label": {
            "type": "object",
            "required": [
              "label"
            ],
            "properties": {
              "label": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets build information of this contract, such as the commit hash used for the build or rustc version.",
        "type": "object",
        "required": [
          "get_contract_version"
        ],
        "properties": {
          "get_contract_version": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the stored contract version information that's required by the CW2 spec interface for migrations.",
        "type": "object",
        "required": [
          "get_cw2_contract_version"
        ],
        "properties": {
          "get_cw2_contract_version": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the address of the validator that's allowed to send rewarding transactions and transition the epoch.",
        "type": "object",
        "required": [
          "get_rewarding_validator_address"
        ],
        "properties": {
          "get_rewarding_validator_address": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the contract parameters that could be adjusted in a transaction by the contract admin.",
        "type": "object",
        "required": [
          "get_state_params"
        ],
        "properties": {
          "get_state_params": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the current state of the contract.",
        "type": "object",
        "required": [
          "get_state"
        ],
        "properties": {
          "get_state": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the current parameters used for reward calculation.",
        "type": "object",
        "required": [
          "get_rewarding_params"
        ],
        "properties": {
          "get_rewarding_params": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the status of the current rewarding epoch.",
        "type": "object",
        "required": [
          "get_epoch_status"
        ],
        "properties": {
          "get_epoch_status": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Get the details of the current rewarding interval.",
        "type": "object",
        "required": [
          "get_current_interval_details"
        ],
        "properties": {
          "get_current_interval_details": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the current list of mixnodes in the rewarded set.",
        "type": "object",
        "required": [
          "get_rewarded_set"
        ],
        "properties": {
          "get_rewarded_set": {
            "type": "object",
            "properties": {
              "limit": {
                "description": "Controls the maximum number of entries returned by the query. Note that too large values will be overwritten by a saner default.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "Pagination control for the values returned by the query. Note that the provided value itself will **not** be used for the response.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the basic list of all currently bonded mixnodes.",
        "type": "object",
        "required": [
          "get_mix_node_bonds"
        ],
        "properties": {
          "get_mix_node_bonds": {
            "type": "object",
            "properties": {
              "limit": {
                "description": "Controls the maximum number of entries returned by the query. Note that too large values will be overwritten by a saner default.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "Pagination control for the values returned by the query. Note that the provided value itself will **not** be used for the response.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the detailed list of all currently bonded mixnodes.",
        "type": "object",
        "required": [
          "get_mix_nodes_detailed"
        ],
        "properties": {
          "get_mix_nodes_detailed": {
            "type": "object",
            "properties": {
              "limit": {
                "description": "Controls the maximum number of entries returned by the query. Note that too large values will be overwritten by a saner default.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "Pagination control for the values returned by the query. Note that the provided value itself will **not** be used for the response.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the basic list of all unbonded mixnodes.",
        "type": "object",
        "required": [
          "get_unbonded_mix_nodes"
        ],
        "properties": {
          "get_unbonded_mix_nodes": {
            "type": "object",
            "properties": {
              "limit": {
                "description": "Controls the maximum number of entries returned by the query. Note that too large values will be overwritten by a saner default.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "Pagination control for the values returned by the query. Note that the provided value itself will **not** be used for the response.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the basic list of all unbonded mixnodes that belonged to a particular owner.",
        "type": "object",
        "required": [
          "get_unbonded_mix_nodes_by_owner"
        ],
        "properties": {
          "get_unbonded_mix_nodes_by_owner": {
            "type": "object",
            "required": [
              "owner"
            ],
            "properties": {
              "limit": {
                "description": "Controls the maximum number of entries returned by the query. Note that too large values will be overwritten by a saner default.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "owner": {
                "description": "The address of the owner of the the mixnodes used for the query.",
                "type": "string"
              },
              "start_after": {
                "description": "Pagination control for the values returned by the query. Note that the provided value itself will **not** be used for the response.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the basic list of all unbonded mixnodes that used the particular identity key.",
        "type": "object",
        "required": [
          "get_unbonded_mix_nodes_by_identity_key"
        ],
        "properties": {
          "get_unbonded_mix_nodes_by_identity_key": {
            "type": "object",
            "required": [
              "identity_key"
            ],
            "properties": {
              "identity_key": {
                "description": "The identity key (base58-encoded ed25519 public key) of the mixnode used for the query.",
                "type": "string"
              },
              "limit": {
                "description": "Controls the maximum number of entries returned by the query. Note that too large values will be overwritten by a saner default.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "Pagination control for the values returned by the query. Note that the provided value itself will **not** be used for the response.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the detailed mixnode information belonging to the particular owner.",
        "type": "object",
        "required": [
          "get_owned_mixnode"
        ],
        "properties": {
          "get_owned_mixnode": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "description": "Address of the mixnode owner to use for the query.",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the detailed mixnode information of a node with the provided id.",
        "type": "object",
        "required": [
          "get_mixnode_details"
        ],
        "properties": {
          "get_mixnode_details": {
            "type": "object",
            "required": [
              "mix_id"
            ],
            "properties": {
              "mix_id": {
                "description": "Id of the node to query.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the rewarding information of a mixnode with the provided id.",
        "type": "object",
        "required": [
          "get_mixnode_rewarding_details"
        ],
        "properties": {
          "get_mixnode_rewarding_details": {
            "type": "object",
            "required": [
              "mix_id"
            ],
            "properties": {
              "mix_id": {
                "description": "Id of the node to query.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the stake saturation of a mixnode with the provided id.",
        "type": "object",
        "required": [
          "get_stake_saturation"
        ],
        "properties": {
          "get_stake_saturation": {
            "type": "object",
            "required": [
              "mix_id"
            ],
            "properties": {
              "mix_id": {
                "description": "Id of the node to query.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the basic information of an unbonded mixnode with the provided id.",
        "type": "object",
        "required": [
          "get_unbonded_mix_node_information"
        ],
        "properties": {
          "get_unbonded_mix_node_information": {
            "type": "object",
            "required": [
              "mix_id"
            ],
            "properties": {
              "mix_id": {
                "description": "Id of the node to query.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the detailed mixnode information of a node given its current identity key.",
        "type": "object",
        "required": [
          "get_bonded_mixnode_details_by_identity"
        ],
        "properties": {
          "get_bonded_mixnode_details_by_identity": {
            "type": "object",
            "required": [
              "mix_identity"
            ],
            "properties": {
              "mix_identity": {
                "description": "The identity key (base58-encoded ed25519 public key) of the mixnode used for the query.",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the current layer configuration of the mix network.",
        "type": "object",
        "required": [
          "get_layer_distribution"
        ],
        "properties": {
          "get_layer_distribution": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the basic list of all currently bonded gateways.",
        "type": "object",
        "required": [
          "get_gateways"
        ],
        "properties": {
          "get_gateways": {
            "type": "object",
            "properties": {
              "limit": {
                "description": "Controls the maximum number of entries returned by the query. Note that too large values will be overwritten by a saner default.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "Pagination control for the values returned by the query. Note that the provided value itself will **not** be used for the response.",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the gateway details of a node given its identity key.",
        "type": "object",
        "required": [
          "get_gateway_bond"
        ],
        "properties": {
          "get_gateway_bond": {
            "type": "object",
            "required": [
              "identity"
            ],
            "properties": {
              "identity": {
                "description": "The identity key (base58-encoded ed25519 public key) of the gateway used for the query.",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the detailed gateway information belonging to the particular owner.",
        "type": "object",
        "required": [
          "get_owned_gateway"
        ],
        "properties": {
          "get_owned_gateway": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "description": "Address of the gateway owner to use for the query.",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets all delegations associated with particular mixnode",
        "type": "object",
        "required": [
          "get_mixnode_delegations"
        ],
        "properties": {
          "get_mixnode_delegations": {
            "type": "object",
            "required": [
              "mix_id"
            ],
            "properties": {
              "limit": {
                "description": "Controls the maximum number of entries returned by the query. Note that too large values will be overwritten by a saner default.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "mix_id": {
                "description": "Id of the node to query.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "Pagination control for the values returned by the query. Note that the provided value itself will **not** be used for the response.",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets all delegations associated with particular delegator",
        "type": "object",
        "required": [
          "get_delegator_delegations"
        ],
        "properties": {
          "get_delegator_delegations": {
            "type": "object",
            "required": [
              "delegator"
            ],
            "properties": {
              "delegator": {
                "description": "The address of the owner of the delegations.",
                "type": "string"
              },
              "limit": {
                "description": "Controls the maximum number of entries returned by the query. Note that too large values will be overwritten by a saner default.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "Pagination control for the values returned by the query. Note that the provided value itself will **not** be used for the response.",
                "type": [
                  "array",
                  "null"
                ],
                "items": [
                  {
                    "type": "integer",
                    "format": "uint32",
                    "minimum": 0.0
                  },
                  {
                    "type": "string"
                  }
                ],
                "maxItems": 2,
                "minItems": 2
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets delegation information associated with particular mixnode - delegator pair",
        "type": "object",
        "required": [
          "get_delegation_details"
        ],
        "properties": {
          "get_delegation_details": {
            "type": "object",
            "required": [
              "delegator",
              "mix_id"
            ],
            "properties": {
              "delegator": {
                "description": "The address of the owner of the delegation.",
                "type": "string"
              },
              "mix_id": {
                "description": "Id of the node to query.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              "proxy": {
                "description": "Entity who made the delegation on behalf of the owner. If present, it's most likely the address of the vesting contract.",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets all delegations in the system",
        "type": "object",
        "required": [
          "get_all_delegations"
        ],
        "properties": {
          "get_all_delegations": {
            "type": "object",
            "properties": {
              "limit": {
                "description": "Controls the maximum number of entries returned by the query. Note that too large values will be overwritten by a saner default.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "Pagination control for the values returned by the query. Note that the provided value itself will **not** be used for the response.",
                "type": [
                  "array",
                  "null"
                ],
                "items": [
                  {
                    "type": "integer",
                    "format": "uint32",
                    "minimum": 0.0
                  },
                  {
                    "type": "string"
                  }
                ],
                "maxItems": 2,
                "minItems": 2
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the reward amount accrued by the node operator that has not yet been claimed.",
        "type": "object",
        "required": [
          "get_pending_operator_reward"
        ],
        "properties": {
          "get_pending_operator_reward": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "description": "Address of the operator to use for the query.",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the reward amount accrued by the particular mixnode that has not yet been claimed.",
        "type": "object",
        "required": [
          "get_pending_mix_node_operator_reward"
        ],
        "properties": {
          "get_pending_mix_node_operator_reward": {
            "type": "object",
            "required": [
              "mix_id"
            ],
            "properties": {
              "mix_id": {
                "description": "Id of the node to query.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the reward amount accrued by the particular delegator that has not yet been claimed.",
        "type": "object",
        "required": [
          "get_pending_delegator_reward"
        ],
        "properties": {
          "get_pending_delegator_reward": {
            "type": "object",
            "required": [
              "address",
              "mix_id"
            ],
            "properties": {
              "address": {
                "description": "Address of the delegator to use for the query.",
                "type": "string"
              },
              "mix_id": {
                "description": "Id of the node to query.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              "proxy": {
                "description": "Entity who made the delegation on behalf of the owner. If present, it's most likely the address of the vesting contract.",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Given the provided node performance, attempt to estimate the operator reward for the current epoch.",
        "type": "object",
        "required": [
          "get_estimated_current_epoch_operator_reward"
        ],
        "properties": {
          "get_estimated_current_epoch_operator_reward": {
            "type": "object",
            "required": [
              "estimated_performance",
              "mix_id"
            ],
            "properties": {
              "estimated_performance": {
                "description": "The estimated performance for the current epoch of the given node.",
                "allOf": [
                  {
                    "$ref": "#/definitions/Percent"
                  }
                ]
              },
              "mix_id": {
                "description": "Id of the node to query.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Given the provided node performance, attempt to estimate the delegator reward for the current epoch.",
        "type": "object",
        "required": [
          "get_estimated_current_epoch_delegator_reward"
        ],
        "properties": {
          "get_estimated_current_epoch_delegator_reward": {
            "type": "object",
            "required": [
              "address",
              "estimated_performance",
              "mix_id"
            ],
            "properties": {
              "address": {
                "description": "Address of the delegator to use for the query.",
                "type": "string"
              },
              "estimated_performance": {
                "description": "The estimated performance for the current epoch of the given node.",
                "allOf": [
                  {
                    "$ref": "#/definitions/Percent"
                  }
                ]
              },
              "mix_id": {
                "description": "Id of the node to query.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              "proxy": {
                "description": "Entity who made the delegation on behalf of the owner. If present, it's most likely the address of the vesting contract.",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the list of all currently pending epoch events that will be resolved once the current epoch finishes.",
        "type": "object",
        "required": [
          "get_pending_epoch_events"
        ],
        "properties": {
          "get_pending_epoch_events": {
            "type": "object",
            "properties": {
              "limit": {
                "description": "Controls the maximum number of entries returned by the query. Note that too large values will be overwritten by a saner default.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "Pagination control for the values returned by the query. Note that the provided value itself will **not** be used for the response.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the list of all currently pending interval events that will be resolved once the current interval finishes.",
        "type": "object",
        "required": [
          "get_pending_interval_events"
        ],
        "properties": {
          "get_pending_interval_events": {
            "type": "object",
            "properties": {
              "limit": {
                "description": "Controls the maximum number of entries returned by the query. Note that too large values will be overwritten by a saner default.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "description": "Pagination control for the values returned by the query. Note that the provided value itself will **not** be used for the response.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets detailed information about a pending epoch event given its id.",
        "type": "object",
        "required": [
          "get_pending_epoch_event"
        ],
        "properties": {
          "get_pending_epoch_event": {
            "type": "object",
            "required": [
              "event_id"
            ],
            "properties": {
              "event_id": {
                "description": "The unique id associated with the event.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets detailed information about a pending interval event given its id.",
        "type": "object",
        "required": [
          "get_pending_interval_event"
        ],
        "properties": {
          "get_pending_interval_event": {
            "type": "object",
            "required": [
              "event_id"
            ],
            "properties": {
              "event_id": {
                "description": "The unique id associated with the event.",
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the information about the number of currently pending epoch and interval events.",
        "type": "object",
        "required": [
          "get_number_of_pending_events"
        ],
        "properties": {
          "get_number_of_pending_events": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the signing nonce associated with the particular cosmos address.",
        "type": "object",
        "required": [
          "get_signing_nonce"
        ],
        "properties": {
          "get_signing_nonce": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "description": "Cosmos address used for the query of the signing nonce.",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "Percent": {
        "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
        "allOf": [
          {
            "$ref": "#/definitions/Decimal"
          }
        ]
      }
    }
  },
  "migrate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "MigrateMsg",
    "type": "object",
    "properties": {
      "vesting_contract_address": {
        "type": [
          "string",
          "null"
        ]
      }
    },
    "additionalProperties": false
  },
  "sudo": null,
  "responses": {
    "get_all_delegations": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedAllDelegationsResponse",
      "description": "Response containing paged list of all delegations currently active.",
      "type": "object",
      "required": [
        "delegations"
      ],
      "properties": {
        "delegations": {
          "description": "Each individual delegation made.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Delegation"
          }
        },
        "start_next_after": {
          "description": "Field indicating paging information for the following queries if the caller wishes to get further entries.",
          "type": [
            "array",
            "null"
          ],
          "items": [
            {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            {
              "type": "string"
            }
          ],
          "maxItems": 2,
          "minItems": 2
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Delegation": {
          "description": "Information about tokens being delegated towards given mixnode in order to accrue rewards with their work.",
          "type": "object",
          "required": [
            "amount",
            "cumulative_reward_ratio",
            "height",
            "mix_id",
            "owner"
          ],
          "properties": {
            "amount": {
              "description": "Original delegation amount. Note that it is never mutated as delegation accumulates rewards.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "cumulative_reward_ratio": {
              "description": "Value of the \"unit delegation\" associated with the mixnode at the time of delegation.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "height": {
              "description": "Block height where this delegation occurred.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "mix_id": {
              "description": "Id of the MixNode that this delegation was performed against.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "owner": {
              "description": "Address of the owner of this delegation.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Proxy address used to delegate the funds on behalf of another address",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_all_families_paged": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedFamiliesResponse",
      "description": "Response containing paged list of all families registered in the contract.",
      "type": "object",
      "required": [
        "families"
      ],
      "properties": {
        "families": {
          "description": "The families registered in the contract.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Family"
          }
        },
        "start_next_after": {
          "description": "Field indicating paging information for the following queries if the caller wishes to get further entries.",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Family": {
          "description": "A group of mixnodes associated with particular staking entity. When defined all nodes belonging to the same family will be prioritised to be put onto the same layer.",
          "type": "object",
          "required": [
            "head",
            "label"
          ],
          "properties": {
            "head": {
              "description": "Owner of this family.",
              "allOf": [
                {
                  "$ref": "#/definitions/FamilyHead"
                }
              ]
            },
            "label": {
              "description": "Human readable label for this family.",
              "type": "string"
            },
            "proxy": {
              "description": "Optional proxy (i.e. vesting contract address) used when creating the family.",
              "type": [
                "string",
                "null"
              ]
            }
          },
          "additionalProperties": false
        },
        "FamilyHead": {
          "description": "Head of particular family as identified by its identity key (i.e. public component of its ed25519 keypair stringified into base58).",
          "type": "string"
        }
      }
    },
    "get_all_members_paged": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedMembersResponse",
      "description": "Response containing paged list of all family members (of ALL families) registered in the contract.",
      "type": "object",
      "required": [
        "members"
      ],
      "properties": {
        "members": {
          "description": "The members alongside their family heads.",
          "type": "array",
          "items": {
            "type": "array",
            "items": [
              {
                "type": "string"
              },
              {
                "$ref": "#/definitions/FamilyHead"
              }
            ],
            "maxItems": 2,
            "minItems": 2
          }
        },
        "start_next_after": {
          "description": "Field indicating paging information for the following queries if the caller wishes to get further entries.",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "FamilyHead": {
          "description": "Head of particular family as identified by its identity key (i.e. public component of its ed25519 keypair stringified into base58).",
          "type": "string"
        }
      }
    },
    "get_bonded_mixnode_details_by_identity": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "MixnodeDetailsByIdentityResponse",
      "description": "Response containing details of a bonded mixnode with the provided identity key.",
      "type": "object",
      "required": [
        "identity_key"
      ],
      "properties": {
        "identity_key": {
          "description": "The identity key (base58-encoded ed25519 public key) of the mixnode.",
          "type": "string"
        },
        "mixnode_details": {
          "description": "If there exists a bonded mixnode with the provided identity key, this field contains its detailed information.",
          "anyOf": [
            {
              "$ref": "#/definitions/MixNodeDetails"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Layer": {
          "type": "string",
          "enum": [
            "One",
            "Two",
            "Three"
          ]
        },
        "MixNode": {
          "description": "Information provided by the node operator during bonding that are used to allow other entities to use the services of this node.",
          "type": "object",
          "required": [
            "host",
            "http_api_port",
            "identity_key",
            "mix_port",
            "sphinx_key",
            "verloc_port",
            "version"
          ],
          "properties": {
            "host": {
              "description": "Network address of this mixnode, for example 1.1.1.1 or foo.mixnode.com",
              "type": "string"
            },
            "http_api_port": {
              "description": "Port used by this mixnode for its http(s) API",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            },
            "mix_port": {
              "description": "Port used by this mixnode for listening for mix packets.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "sphinx_key": {
              "description": "Base58-encoded x25519 public key used for sphinx key derivation.",
              "type": "string"
            },
            "verloc_port": {
              "description": "Port used by this mixnode for listening for verloc requests.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "version": {
              "description": "The self-reported semver version of this mixnode.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "MixNodeBond": {
          "description": "Basic mixnode information provided by the node operator.",
          "type": "object",
          "required": [
            "bonding_height",
            "is_unbonding",
            "layer",
            "mix_id",
            "mix_node",
            "original_pledge",
            "owner"
          ],
          "properties": {
            "bonding_height": {
              "description": "Block height at which this mixnode has been bonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "is_unbonding": {
              "description": "Flag to indicate whether this node is in the process of unbonding, that will conclude upon the epoch finishing.",
              "type": "boolean"
            },
            "layer": {
              "description": "Layer assigned to this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Layer"
                }
              ]
            },
            "mix_id": {
              "description": "Unique id assigned to the bonded mixnode.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "mix_node": {
              "description": "Information provided by the operator for the purposes of bonding.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNode"
                }
              ]
            },
            "original_pledge": {
              "description": "Original amount pledged by the operator of this node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "owner": {
              "description": "Address of the owner of this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Entity who bonded this mixnode on behalf of the owner. If exists, it's most likely the address of the vesting contract.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "MixNodeCostParams": {
          "description": "The cost parameters, or the cost function, defined for the particular mixnode that influences how the rewards should be split between the node operator and its delegators.",
          "type": "object",
          "required": [
            "interval_operating_cost",
            "profit_margin_percent"
          ],
          "properties": {
            "interval_operating_cost": {
              "description": "Operating cost of the associated mixnode per the entire interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "profit_margin_percent": {
              "description": "The profit margin of the associated mixnode, i.e. the desired percent of the reward to be distributed to the operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Percent"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "MixNodeDetails": {
          "description": "Full details associated with given mixnode.",
          "type": "object",
          "required": [
            "bond_information",
            "rewarding_details"
          ],
          "properties": {
            "bond_information": {
              "description": "Basic bond information of this mixnode, such as owner address, original pledge, etc.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNodeBond"
                }
              ]
            },
            "pending_changes": {
              "description": "Adjustments to the mixnode that are ought to happen during future epoch transitions.",
              "default": {
                "pledge_change": null
              },
              "allOf": [
                {
                  "$ref": "#/definitions/PendingMixNodeChanges"
                }
              ]
            },
            "rewarding_details": {
              "description": "Details used for computation of rewarding related data.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNodeRewarding"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "MixNodeRewarding": {
          "type": "object",
          "required": [
            "cost_params",
            "delegates",
            "last_rewarded_epoch",
            "operator",
            "total_unit_reward",
            "unique_delegations",
            "unit_delegation"
          ],
          "properties": {
            "cost_params": {
              "description": "Information provided by the operator that influence the cost function.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNodeCostParams"
                }
              ]
            },
            "delegates": {
              "description": "Total delegation and compounded reward earned by all node delegators.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "last_rewarded_epoch": {
              "description": "Marks the epoch when this node was last rewarded so that we wouldn't accidentally attempt to reward it multiple times in the same epoch.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "operator": {
              "description": "Total pledge and compounded reward earned by the node operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "total_unit_reward": {
              "description": "Cumulative reward earned by the \"unit delegation\" since the block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "unique_delegations": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "unit_delegation": {
              "description": "Value of the theoretical \"unit delegation\" that has delegated to this mixnode at block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PendingMixNodeChanges": {
          "type": "object",
          "properties": {
            "pledge_change": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Percent": {
          "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_c_w2_contract_version": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ContractVersion",
      "type": "object",
      "required": [
        "contract",
        "version"
      ],
      "properties": {
        "contract": {
          "description": "contract is the crate name of the implementing contract, eg. `crate:cw20-base` we will use other prefixes for other languages, and their standard global namespacing",
          "type": "string"
        },
        "version": {
          "description": "version is any string that this implementation knows. It may be simple counter \"1\", \"2\". or semantic version on release tags \"v0.7.0\", or some custom feature flag list. the only code that needs to understand the version parsing is code that knows how to migrate from the given contract (and is tied to it's implementation somehow)",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "get_contract_version": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ContractBuildInformation",
      "type": "object",
      "required": [
        "build_timestamp",
        "build_version",
        "commit_branch",
        "commit_sha",
        "commit_timestamp",
        "rustc_version"
      ],
      "properties": {
        "build_timestamp": {
          "description": "Provides the build timestamp, for example `2021-02-23T20:14:46.558472672+00:00`.",
          "type": "string"
        },
        "build_version": {
          "description": "Provides the build version, for example `0.1.0-9-g46f83e1`.",
          "type": "string"
        },
        "cargo_debug": {
          "description": "Provides the cargo debug mode that was used for the build.",
          "default": "unknown",
          "type": "string"
        },
        "cargo_opt_level": {
          "description": "Provides the opt value set by cargo during the build",
          "default": "unknown",
          "type": "string"
        },
        "commit_branch": {
          "description": "Provides the name of the git branch that was used for the build, for example `master`.",
          "type": "string"
        },
        "commit_sha": {
          "description": "Provides the hash of the commit that was used for the build, for example `46f83e112520533338245862d366f6a02cef07d4`.",
          "type": "string"
        },
        "commit_timestamp": {
          "description": "Provides the timestamp of the commit that was used for the build, for example `2021-02-23T08:08:02-05:00`.",
          "type": "string"
        },
        "contract_name": {
          "description": "Provides the name of the binary, i.e. the content of `CARGO_PKG_NAME` environmental variable.",
          "default": "unknown",
          "type": "string"
        },
        "rustc_version": {
          "description": "Provides the rustc version that was used for the build, for example `1.52.0-nightly`.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "get_current_interval_details": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "CurrentIntervalResponse",
      "description": "Information about the current rewarding interval.",
      "type": "object",
      "required": [
        "current_blocktime",
        "interval",
        "is_current_epoch_over",
        "is_current_interval_over"
      ],
      "properties": {
        "current_blocktime": {
          "description": "The current blocktime",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "interval": {
          "description": "Detailed information about the underlying interval.",
          "allOf": [
            {
              "$ref": "#/definitions/Interval"
            }
          ]
        },
        "is_current_epoch_over": {
          "description": "Flag indicating whether the current epoch is over and it should be advanced.",
          "type": "boolean"
        },
        "is_current_interval_over": {
          "description": "Flag indicating whether the current interval is over and it should be advanced.",
          "type": "boolean"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Duration": {
          "type": "object",
          "required": [
            "nanos",
            "secs"
          ],
          "properties": {
            "nanos": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "secs": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          }
        },
        "Interval": {
          "type": "object",
          "required": [
            "current_epoch_id",
            "current_epoch_start",
            "epoch_length",
            "epochs_in_interval",
            "id",
            "total_elapsed_epochs"
          ],
          "properties": {
            "current_epoch_id": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "current_epoch_start": {
              "type": "string"
            },
            "epoch_length": {
              "$ref": "#/definitions/Duration"
            },
            "epochs_in_interval": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "id": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "total_elapsed_epochs": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          }
        }
      }
    },
    "get_delegation_details": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "MixNodeDelegationResponse",
      "description": "Response containing delegation details.",
      "type": "object",
      "required": [
        "mixnode_still_bonded"
      ],
      "properties": {
        "delegation": {
          "description": "If the delegation exists, this field contains its detailed information.",
          "anyOf": [
            {
              "$ref": "#/definitions/Delegation"
            },
            {
              "type": "null"
            }
          ]
        },
        "mixnode_still_bonded": {
          "description": "Flag indicating whether the node towards which the delegation was made is still bonded in the network.",
          "type": "boolean"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Delegation": {
          "description": "Information about tokens being delegated towards given mixnode in order to accrue rewards with their work.",
          "type": "object",
          "required": [
            "amount",
            "cumulative_reward_ratio",
            "height",
            "mix_id",
            "owner"
          ],
          "properties": {
            "amount": {
              "description": "Original delegation amount. Note that it is never mutated as delegation accumulates rewards.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "cumulative_reward_ratio": {
              "description": "Value of the \"unit delegation\" associated with the mixnode at the time of delegation.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "height": {
              "description": "Block height where this delegation occurred.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "mix_id": {
              "description": "Id of the MixNode that this delegation was performed against.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "owner": {
              "description": "Address of the owner of this delegation.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Proxy address used to delegate the funds on behalf of another address",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_delegator_delegations": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedDelegatorDelegationsResponse",
      "description": "Response containing paged list of all delegations made by the particular address.",
      "type": "object",
      "required": [
        "delegations"
      ],
      "properties": {
        "delegations": {
          "description": "Each individual delegation made.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Delegation"
          }
        },
        "start_next_after": {
          "description": "Field indicating paging information for the following queries if the caller wishes to get further entries.",
          "type": [
            "array",
            "null"
          ],
          "items": [
            {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            {
              "type": "string"
            }
          ],
          "maxItems": 2,
          "minItems": 2
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Delegation": {
          "description": "Information about tokens being delegated towards given mixnode in order to accrue rewards with their work.",
          "type": "object",
          "required": [
            "amount",
            "cumulative_reward_ratio",
            "height",
            "mix_id",
            "owner"
          ],
          "properties": {
            "amount": {
              "description": "Original delegation amount. Note that it is never mutated as delegation accumulates rewards.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "cumulative_reward_ratio": {
              "description": "Value of the \"unit delegation\" associated with the mixnode at the time of delegation.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "height": {
              "description": "Block height where this delegation occurred.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "mix_id": {
              "description": "Id of the MixNode that this delegation was performed against.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "owner": {
              "description": "Address of the owner of this delegation.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Proxy address used to delegate the funds on behalf of another address",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_epoch_status": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "EpochStatus",
      "description": "The status of the current rewarding epoch.",
      "type": "object",
      "required": [
        "being_advanced_by",
        "state"
      ],
      "properties": {
        "being_advanced_by": {
          "description": "Specifies either, which validator is currently performing progression into the following epoch (if the epoch is currently being progressed), or which validator was responsible for progressing into the current epoch (if the epoch is currently in progress)",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "state": {
          "description": "The concrete state of the epoch.",
          "allOf": [
            {
              "$ref": "#/definitions/EpochState"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "EpochState": {
          "description": "The state of the current rewarding epoch.",
          "oneOf": [
            {
              "description": "Represents the state of an epoch that's in progress (well, duh.) All actions are allowed to be issued.",
              "type": "string",
              "enum": [
                "in_progress"
              ]
            },
            {
              "description": "Represents the state of an epoch when the rewarding entity has been decided on, and the mixnodes are in the process of being rewarded for their work in this epoch.",
              "type": "object",
              "required": [
                "rewarding"
              ],
              "properties": {
                "rewarding": {
                  "type": "object",
                  "required": [
                    "final_node_id",
                    "last_rewarded"
                  ],
                  "properties": {
                    "final_node_id": {
                      "description": "The id of the last node that's going to be rewarded before progressing into the next state.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    },
                    "last_rewarded": {
                      "description": "The id of the last node that has already received its rewards.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Represents the state of an epoch when all mixnodes have already been rewarded for their work in this epoch and all issued actions should now get resolved before being allowed to advance into the next epoch.",
              "type": "string",
              "enum": [
                "reconciling_events"
              ]
            },
            {
              "description": "Represents the state of an epoch when all mixnodes have already been rewarded for their work in this epoch, all issued actions got resolved and the epoch should now be advanced whilst assigning new rewarded set.",
              "type": "string",
              "enum": [
                "advancing_epoch"
              ]
            }
          ]
        }
      }
    },
    "get_estimated_current_epoch_delegator_reward": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "EstimatedCurrentEpochRewardResponse",
      "description": "Response containing estimation of node rewards for the current epoch.",
      "type": "object",
      "properties": {
        "current_stake_value": {
          "description": "The current stake value given all past rewarding and compounding since the original staking was performed.",
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "current_stake_value_detailed_amount": {
          "description": "The current stake value. Note that it's nearly identical to `current_stake_value`, however, it contains few additional decimal points for more accurate reward calculation.",
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "detailed_estimation_amount": {
          "description": "The full reward estimation. Note that it's nearly identical to `estimation`, however, it contains few additional decimal points for more accurate reward calculation.",
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "estimation": {
          "description": "The reward estimation for the current epoch, i.e. the amount of tokens that could be claimable after the epoch finishes and the state of the network does not change.",
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "original_stake": {
          "description": "The amount of tokens initially staked.",
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_estimated_current_epoch_operator_reward": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "EstimatedCurrentEpochRewardResponse",
      "description": "Response containing estimation of node rewards for the current epoch.",
      "type": "object",
      "properties": {
        "current_stake_value": {
          "description": "The current stake value given all past rewarding and compounding since the original staking was performed.",
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "current_stake_value_detailed_amount": {
          "description": "The current stake value. Note that it's nearly identical to `current_stake_value`, however, it contains few additional decimal points for more accurate reward calculation.",
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "detailed_estimation_amount": {
          "description": "The full reward estimation. Note that it's nearly identical to `estimation`, however, it contains few additional decimal points for more accurate reward calculation.",
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "estimation": {
          "description": "The reward estimation for the current epoch, i.e. the amount of tokens that could be claimable after the epoch finishes and the state of the network does not change.",
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "original_stake": {
          "description": "The amount of tokens initially staked.",
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_family_by_head": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "FamilyByHeadResponse",
      "description": "Response containing family information.",
      "type": "object",
      "required": [
        "head"
      ],
      "properties": {
        "family": {
          "description": "If applicable, the family associated with the provided head.",
          "anyOf": [
            {
              "$ref": "#/definitions/Family"
            },
            {
              "type": "null"
            }
          ]
        },
        "head": {
          "description": "The family head used for the query.",
          "allOf": [
            {
              "$ref": "#/definitions/FamilyHead"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Family": {
          "description": "A group of mixnodes associated with particular staking entity. When defined all nodes belonging to the same family will be prioritised to be put onto the same layer.",
          "type": "object",
          "required": [
            "head",
            "label"
          ],
          "properties": {
            "head": {
              "description": "Owner of this family.",
              "allOf": [
                {
                  "$ref": "#/definitions/FamilyHead"
                }
              ]
            },
            "label": {
              "description": "Human readable label for this family.",
              "type": "string"
            },
            "proxy": {
              "description": "Optional proxy (i.e. vesting contract address) used when creating the family.",
              "type": [
                "string",
                "null"
              ]
            }
          },
          "additionalProperties": false
        },
        "FamilyHead": {
          "description": "Head of particular family as identified by its identity key (i.e. public component of its ed25519 keypair stringified into base58).",
          "type": "string"
        }
      }
    },
    "get_family_by_label": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "FamilyByLabelResponse",
      "description": "Response containing family information.",
      "type": "object",
      "required": [
        "label"
      ],
      "properties": {
        "family": {
          "description": "If applicable, the family associated with the provided label.",
          "anyOf": [
            {
              "$ref": "#/definitions/Family"
            },
            {
              "type": "null"
            }
          ]
        },
        "label": {
          "description": "The family label used for the query.",
          "type": "string"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Family": {
          "description": "A group of mixnodes associated with particular staking entity. When defined all nodes belonging to the same family will be prioritised to be put onto the same layer.",
          "type": "object",
          "required": [
            "head",
            "label"
          ],
          "properties": {
            "head": {
              "description": "Owner of this family.",
              "allOf": [
                {
                  "$ref": "#/definitions/FamilyHead"
                }
              ]
            },
            "label": {
              "description": "Human readable label for this family.",
              "type": "string"
            },
            "proxy": {
              "description": "Optional proxy (i.e. vesting contract address) used when creating the family.",
              "type": [
                "string",
                "null"
              ]
            }
          },
          "additionalProperties": false
        },
        "FamilyHead": {
          "description": "Head of particular family as identified by its identity key (i.e. public component of its ed25519 keypair stringified into base58).",
          "type": "string"
        }
      }
    },
    "get_family_members_by_head": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "FamilyMembersByHeadResponse",
      "description": "Response containing family members information.",
      "type": "object",
      "required": [
        "head",
        "members"
      ],
      "properties": {
        "head": {
          "description": "The family head used for the query.",
          "allOf": [
            {
              "$ref": "#/definitions/FamilyHead"
            }
          ]
        },
        "members": {
          "description": "All members belonging to the specified family.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "FamilyHead": {
          "description": "Head of particular family as identified by its identity key (i.e. public component of its ed25519 keypair stringified into base58).",
          "type": "string"
        }
      }
    },
    "get_family_members_by_label": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "FamilyMembersByLabelResponse",
      "description": "Response containing family members information.",
      "type": "object",
      "required": [
        "label",
        "members"
      ],
      "properties": {
        "label": {
          "description": "The family label used for the query.",
          "type": "string"
        },
        "members": {
          "description": "All members belonging to the specified family.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "additionalProperties": false
    },
    "get_gateway_bond": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "GatewayBondResponse",
      "description": "Response containing details of a gateway with the provided identity key.",
      "type": "object",
      "required": [
        "identity"
      ],
      "properties": {
        "gateway": {
          "description": "If there exists a gateway with the provided identity key, this field contains its details.",
          "anyOf": [
            {
              "$ref": "#/definitions/GatewayBond"
            },
            {
              "type": "null"
            }
          ]
        },
        "identity": {
          "description": "The identity key (base58-encoded ed25519 public key) of the gateway.",
          "type": "string"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Gateway": {
          "description": "Information provided by the node operator during bonding that are used to allow other entities to use the services of this node.",
          "type": "object",
          "required": [
            "clients_port",
            "host",
            "identity_key",
            "location",
            "mix_port",
            "sphinx_key",
            "version"
          ],
          "properties": {
            "clients_port": {
              "description": "Port used by this gateway for listening for client requests.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "host": {
              "description": "Network address of this gateway, for example 1.1.1.1 or foo.gateway.com",
              "type": "string"
            },
            "identity_key": {
              "description": "Base58 encoded ed25519 EdDSA public key of the gateway used to derive shared keys with clients",
              "type": "string"
            },
            "location": {
              "description": "The physical, self-reported, location of this gateway.",
              "type": "string"
            },
            "mix_port": {
              "description": "Port used by this gateway for listening for mix packets.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "sphinx_key": {
              "description": "Base58-encoded x25519 public key used for sphinx key derivation.",
              "type": "string"
            },
            "version": {
              "description": "The self-reported semver version of this gateway.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "GatewayBond": {
          "description": "Basic gateway information provided by the node operator.",
          "type": "object",
          "required": [
            "block_height",
            "gateway",
            "owner",
            "pledge_amount"
          ],
          "properties": {
            "block_height": {
              "description": "Block height at which this gateway has been bonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "gateway": {
              "description": "Information provided by the operator for the purposes of bonding.",
              "allOf": [
                {
                  "$ref": "#/definitions/Gateway"
                }
              ]
            },
            "owner": {
              "description": "Address of the owner of this gateway.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "pledge_amount": {
              "description": "Original amount pledged by the operator of this node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "proxy": {
              "description": "Entity who bonded this gateway on behalf of the owner. If exists, it's most likely the address of the vesting contract.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_gateways": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedGatewayResponse",
      "description": "Response containing paged list of all gateway bonds in the contract.",
      "type": "object",
      "required": [
        "nodes",
        "per_page"
      ],
      "properties": {
        "nodes": {
          "description": "The gateway bond information present in the contract.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/GatewayBond"
          }
        },
        "per_page": {
          "description": "Maximum number of entries that could be included in a response. `per_page <= nodes.len()`",
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        },
        "start_next_after": {
          "description": "Field indicating paging information for the following queries if the caller wishes to get further entries.",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Gateway": {
          "description": "Information provided by the node operator during bonding that are used to allow other entities to use the services of this node.",
          "type": "object",
          "required": [
            "clients_port",
            "host",
            "identity_key",
            "location",
            "mix_port",
            "sphinx_key",
            "version"
          ],
          "properties": {
            "clients_port": {
              "description": "Port used by this gateway for listening for client requests.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "host": {
              "description": "Network address of this gateway, for example 1.1.1.1 or foo.gateway.com",
              "type": "string"
            },
            "identity_key": {
              "description": "Base58 encoded ed25519 EdDSA public key of the gateway used to derive shared keys with clients",
              "type": "string"
            },
            "location": {
              "description": "The physical, self-reported, location of this gateway.",
              "type": "string"
            },
            "mix_port": {
              "description": "Port used by this gateway for listening for mix packets.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "sphinx_key": {
              "description": "Base58-encoded x25519 public key used for sphinx key derivation.",
              "type": "string"
            },
            "version": {
              "description": "The self-reported semver version of this gateway.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "GatewayBond": {
          "description": "Basic gateway information provided by the node operator.",
          "type": "object",
          "required": [
            "block_height",
            "gateway",
            "owner",
            "pledge_amount"
          ],
          "properties": {
            "block_height": {
              "description": "Block height at which this gateway has been bonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "gateway": {
              "description": "Information provided by the operator for the purposes of bonding.",
              "allOf": [
                {
                  "$ref": "#/definitions/Gateway"
                }
              ]
            },
            "owner": {
              "description": "Address of the owner of this gateway.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "pledge_amount": {
              "description": "Original amount pledged by the operator of this node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "proxy": {
              "description": "Entity who bonded this gateway on behalf of the owner. If exists, it's most likely the address of the vesting contract.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_layer_distribution": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "LayerDistribution",
      "description": "The current layer distribution of the mix network.",
      "type": "object",
      "required": [
        "layer1",
        "layer2",
        "layer3"
      ],
      "properties": {
        "layer1": {
          "description": "Number of nodes on the first layer.",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "layer2": {
          "description": "Number of nodes on the second layer.",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "layer3": {
          "description": "Number of nodes on the third layer.",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        }
      },
      "additionalProperties": false
    },
    "get_mix_node_bonds": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedMixnodeBondsResponse",
      "description": "Response containing paged list of all mixnode bonds in the contract.",
      "type": "object",
      "required": [
        "nodes",
        "per_page"
      ],
      "properties": {
        "nodes": {
          "description": "The mixnode bond information present in the contract.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/MixNodeBond"
          }
        },
        "per_page": {
          "description": "Maximum number of entries that could be included in a response. `per_page <= nodes.len()`",
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        },
        "start_next_after": {
          "description": "Field indicating paging information for the following queries if the caller wishes to get further entries.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Layer": {
          "type": "string",
          "enum": [
            "One",
            "Two",
            "Three"
          ]
        },
        "MixNode": {
          "description": "Information provided by the node operator during bonding that are used to allow other entities to use the services of this node.",
          "type": "object",
          "required": [
            "host",
            "http_api_port",
            "identity_key",
            "mix_port",
            "sphinx_key",
            "verloc_port",
            "version"
          ],
          "properties": {
            "host": {
              "description": "Network address of this mixnode, for example 1.1.1.1 or foo.mixnode.com",
              "type": "string"
            },
            "http_api_port": {
              "description": "Port used by this mixnode for its http(s) API",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            },
            "mix_port": {
              "description": "Port used by this mixnode for listening for mix packets.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "sphinx_key": {
              "description": "Base58-encoded x25519 public key used for sphinx key derivation.",
              "type": "string"
            },
            "verloc_port": {
              "description": "Port used by this mixnode for listening for verloc requests.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "version": {
              "description": "The self-reported semver version of this mixnode.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "MixNodeBond": {
          "description": "Basic mixnode information provided by the node operator.",
          "type": "object",
          "required": [
            "bonding_height",
            "is_unbonding",
            "layer",
            "mix_id",
            "mix_node",
            "original_pledge",
            "owner"
          ],
          "properties": {
            "bonding_height": {
              "description": "Block height at which this mixnode has been bonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "is_unbonding": {
              "description": "Flag to indicate whether this node is in the process of unbonding, that will conclude upon the epoch finishing.",
              "type": "boolean"
            },
            "layer": {
              "description": "Layer assigned to this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Layer"
                }
              ]
            },
            "mix_id": {
              "description": "Unique id assigned to the bonded mixnode.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "mix_node": {
              "description": "Information provided by the operator for the purposes of bonding.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNode"
                }
              ]
            },
            "original_pledge": {
              "description": "Original amount pledged by the operator of this node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "owner": {
              "description": "Address of the owner of this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Entity who bonded this mixnode on behalf of the owner. If exists, it's most likely the address of the vesting contract.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_mix_nodes_detailed": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedMixnodesDetailsResponse",
      "description": "Response containing paged list of all mixnode details in the contract.",
      "type": "object",
      "required": [
        "nodes",
        "per_page"
      ],
      "properties": {
        "nodes": {
          "description": "All mixnode details stored in the contract. Apart from the basic bond information it also contains details required for all future reward calculation as well as any pending changes requested by the operator.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/MixNodeDetails"
          }
        },
        "per_page": {
          "description": "Maximum number of entries that could be included in a response. `per_page <= nodes.len()`",
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        },
        "start_next_after": {
          "description": "Field indicating paging information for the following queries if the caller wishes to get further entries.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Layer": {
          "type": "string",
          "enum": [
            "One",
            "Two",
            "Three"
          ]
        },
        "MixNode": {
          "description": "Information provided by the node operator during bonding that are used to allow other entities to use the services of this node.",
          "type": "object",
          "required": [
            "host",
            "http_api_port",
            "identity_key",
            "mix_port",
            "sphinx_key",
            "verloc_port",
            "version"
          ],
          "properties": {
            "host": {
              "description": "Network address of this mixnode, for example 1.1.1.1 or foo.mixnode.com",
              "type": "string"
            },
            "http_api_port": {
              "description": "Port used by this mixnode for its http(s) API",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            },
            "mix_port": {
              "description": "Port used by this mixnode for listening for mix packets.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "sphinx_key": {
              "description": "Base58-encoded x25519 public key used for sphinx key derivation.",
              "type": "string"
            },
            "verloc_port": {
              "description": "Port used by this mixnode for listening for verloc requests.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "version": {
              "description": "The self-reported semver version of this mixnode.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "MixNodeBond": {
          "description": "Basic mixnode information provided by the node operator.",
          "type": "object",
          "required": [
            "bonding_height",
            "is_unbonding",
            "layer",
            "mix_id",
            "mix_node",
            "original_pledge",
            "owner"
          ],
          "properties": {
            "bonding_height": {
              "description": "Block height at which this mixnode has been bonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "is_unbonding": {
              "description": "Flag to indicate whether this node is in the process of unbonding, that will conclude upon the epoch finishing.",
              "type": "boolean"
            },
            "layer": {
              "description": "Layer assigned to this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Layer"
                }
              ]
            },
            "mix_id": {
              "description": "Unique id assigned to the bonded mixnode.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "mix_node": {
              "description": "Information provided by the operator for the purposes of bonding.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNode"
                }
              ]
            },
            "original_pledge": {
              "description": "Original amount pledged by the operator of this node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "owner": {
              "description": "Address of the owner of this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Entity who bonded this mixnode on behalf of the owner. If exists, it's most likely the address of the vesting contract.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "MixNodeCostParams": {
          "description": "The cost parameters, or the cost function, defined for the particular mixnode that influences how the rewards should be split between the node operator and its delegators.",
          "type": "object",
          "required": [
            "interval_operating_cost",
            "profit_margin_percent"
          ],
          "properties": {
            "interval_operating_cost": {
              "description": "Operating cost of the associated mixnode per the entire interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "profit_margin_percent": {
              "description": "The profit margin of the associated mixnode, i.e. the desired percent of the reward to be distributed to the operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Percent"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "MixNodeDetails": {
          "description": "Full details associated with given mixnode.",
          "type": "object",
          "required": [
            "bond_information",
            "rewarding_details"
          ],
          "properties": {
            "bond_information": {
              "description": "Basic bond information of this mixnode, such as owner address, original pledge, etc.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNodeBond"
                }
              ]
            },
            "pending_changes": {
              "description": "Adjustments to the mixnode that are ought to happen during future epoch transitions.",
              "default": {
                "pledge_change": null
              },
              "allOf": [
                {
                  "$ref": "#/definitions/PendingMixNodeChanges"
                }
              ]
            },
            "rewarding_details": {
              "description": "Details used for computation of rewarding related data.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNodeRewarding"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "MixNodeRewarding": {
          "type": "object",
          "required": [
            "cost_params",
            "delegates",
            "last_rewarded_epoch",
            "operator",
            "total_unit_reward",
            "unique_delegations",
            "unit_delegation"
          ],
          "properties": {
            "cost_params": {
              "description": "Information provided by the operator that influence the cost function.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNodeCostParams"
                }
              ]
            },
            "delegates": {
              "description": "Total delegation and compounded reward earned by all node delegators.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "last_rewarded_epoch": {
              "description": "Marks the epoch when this node was last rewarded so that we wouldn't accidentally attempt to reward it multiple times in the same epoch.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "operator": {
              "description": "Total pledge and compounded reward earned by the node operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "total_unit_reward": {
              "description": "Cumulative reward earned by the \"unit delegation\" since the block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "unique_delegations": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "unit_delegation": {
              "description": "Value of the theoretical \"unit delegation\" that has delegated to this mixnode at block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PendingMixNodeChanges": {
          "type": "object",
          "properties": {
            "pledge_change": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Percent": {
          "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_mixnode_delegations": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedMixNodeDelegationsResponse",
      "description": "Response containing paged list of all delegations made towards particular mixnode.",
      "type": "object",
      "required": [
        "delegations"
      ],
      "properties": {
        "delegations": {
          "description": "Each individual delegation made.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Delegation"
          }
        },
        "start_next_after": {
          "description": "Field indicating paging information for the following queries if the caller wishes to get further entries.",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Delegation": {
          "description": "Information about tokens being delegated towards given mixnode in order to accrue rewards with their work.",
          "type": "object",
          "required": [
            "amount",
            "cumulative_reward_ratio",
            "height",
            "mix_id",
            "owner"
          ],
          "properties": {
            "amount": {
              "description": "Original delegation amount. Note that it is never mutated as delegation accumulates rewards.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "cumulative_reward_ratio": {
              "description": "Value of the \"unit delegation\" associated with the mixnode at the time of delegation.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "height": {
              "description": "Block height where this delegation occurred.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "mix_id": {
              "description": "Id of the MixNode that this delegation was performed against.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "owner": {
              "description": "Address of the owner of this delegation.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Proxy address used to delegate the funds on behalf of another address",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_mixnode_details": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "MixnodeDetailsResponse",
      "description": "Response containing details of a mixnode with the provided id.",
      "type": "object",
      "required": [
        "mix_id"
      ],
      "properties": {
        "mix_id": {
          "description": "Id of the requested mixnode.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "mixnode_details": {
          "description": "If there exists a mixnode with the provided id, this field contains its detailed information.",
          "anyOf": [
            {
              "$ref": "#/definitions/MixNodeDetails"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Layer": {
          "type": "string",
          "enum": [
            "One",
            "Two",
            "Three"
          ]
        },
        "MixNode": {
          "description": "Information provided by the node operator during bonding that are used to allow other entities to use the services of this node.",
          "type": "object",
          "required": [
            "host",
            "http_api_port",
            "identity_key",
            "mix_port",
            "sphinx_key",
            "verloc_port",
            "version"
          ],
          "properties": {
            "host": {
              "description": "Network address of this mixnode, for example 1.1.1.1 or foo.mixnode.com",
              "type": "string"
            },
            "http_api_port": {
              "description": "Port used by this mixnode for its http(s) API",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            },
            "mix_port": {
              "description": "Port used by this mixnode for listening for mix packets.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "sphinx_key": {
              "description": "Base58-encoded x25519 public key used for sphinx key derivation.",
              "type": "string"
            },
            "verloc_port": {
              "description": "Port used by this mixnode for listening for verloc requests.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "version": {
              "description": "The self-reported semver version of this mixnode.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "MixNodeBond": {
          "description": "Basic mixnode information provided by the node operator.",
          "type": "object",
          "required": [
            "bonding_height",
            "is_unbonding",
            "layer",
            "mix_id",
            "mix_node",
            "original_pledge",
            "owner"
          ],
          "properties": {
            "bonding_height": {
              "description": "Block height at which this mixnode has been bonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "is_unbonding": {
              "description": "Flag to indicate whether this node is in the process of unbonding, that will conclude upon the epoch finishing.",
              "type": "boolean"
            },
            "layer": {
              "description": "Layer assigned to this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Layer"
                }
              ]
            },
            "mix_id": {
              "description": "Unique id assigned to the bonded mixnode.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "mix_node": {
              "description": "Information provided by the operator for the purposes of bonding.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNode"
                }
              ]
            },
            "original_pledge": {
              "description": "Original amount pledged by the operator of this node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "owner": {
              "description": "Address of the owner of this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Entity who bonded this mixnode on behalf of the owner. If exists, it's most likely the address of the vesting contract.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "MixNodeCostParams": {
          "description": "The cost parameters, or the cost function, defined for the particular mixnode that influences how the rewards should be split between the node operator and its delegators.",
          "type": "object",
          "required": [
            "interval_operating_cost",
            "profit_margin_percent"
          ],
          "properties": {
            "interval_operating_cost": {
              "description": "Operating cost of the associated mixnode per the entire interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "profit_margin_percent": {
              "description": "The profit margin of the associated mixnode, i.e. the desired percent of the reward to be distributed to the operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Percent"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "MixNodeDetails": {
          "description": "Full details associated with given mixnode.",
          "type": "object",
          "required": [
            "bond_information",
            "rewarding_details"
          ],
          "properties": {
            "bond_information": {
              "description": "Basic bond information of this mixnode, such as owner address, original pledge, etc.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNodeBond"
                }
              ]
            },
            "pending_changes": {
              "description": "Adjustments to the mixnode that are ought to happen during future epoch transitions.",
              "default": {
                "pledge_change": null
              },
              "allOf": [
                {
                  "$ref": "#/definitions/PendingMixNodeChanges"
                }
              ]
            },
            "rewarding_details": {
              "description": "Details used for computation of rewarding related data.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNodeRewarding"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "MixNodeRewarding": {
          "type": "object",
          "required": [
            "cost_params",
            "delegates",
            "last_rewarded_epoch",
            "operator",
            "total_unit_reward",
            "unique_delegations",
            "unit_delegation"
          ],
          "properties": {
            "cost_params": {
              "description": "Information provided by the operator that influence the cost function.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNodeCostParams"
                }
              ]
            },
            "delegates": {
              "description": "Total delegation and compounded reward earned by all node delegators.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "last_rewarded_epoch": {
              "description": "Marks the epoch when this node was last rewarded so that we wouldn't accidentally attempt to reward it multiple times in the same epoch.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "operator": {
              "description": "Total pledge and compounded reward earned by the node operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "total_unit_reward": {
              "description": "Cumulative reward earned by the \"unit delegation\" since the block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "unique_delegations": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "unit_delegation": {
              "description": "Value of the theoretical \"unit delegation\" that has delegated to this mixnode at block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PendingMixNodeChanges": {
          "type": "object",
          "properties": {
            "pledge_change": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Percent": {
          "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_mixnode_rewarding_details": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "MixnodeRewardingDetailsResponse",
      "description": "Response containing rewarding information of a mixnode with the provided id.",
      "type": "object",
      "required": [
        "mix_id"
      ],
      "properties": {
        "mix_id": {
          "description": "Id of the requested mixnode.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "rewarding_details": {
          "description": "If there exists a mixnode with the provided id, this field contains its rewarding information.",
          "anyOf": [
            {
              "$ref": "#/definitions/MixNodeRewarding"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "MixNodeCostParams": {
          "description": "The cost parameters, or the cost function, defined for the particular mixnode that influences how the rewards should be split between the node operator and its delegators.",
          "type": "object",
          "required": [
            "interval_operating_cost",
            "profit_margin_percent"
          ],
          "properties": {
            "interval_operating_cost": {
              "description": "Operating cost of the associated mixnode per the entire interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "profit_margin_percent": {
              "description": "The profit margin of the associated mixnode, i.e. the desired percent of the reward to be distributed to the operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Percent"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "MixNodeRewarding": {
          "type": "object",
          "required": [
            "cost_params",
            "delegates",
            "last_rewarded_epoch",
            "operator",
            "total_unit_reward",
            "unique_delegations",
            "unit_delegation"
          ],
          "properties": {
            "cost_params": {
              "description": "Information provided by the operator that influence the cost function.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNodeCostParams"
                }
              ]
            },
            "delegates": {
              "description": "Total delegation and compounded reward earned by all node delegators.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "last_rewarded_epoch": {
              "description": "Marks the epoch when this node was last rewarded so that we wouldn't accidentally attempt to reward it multiple times in the same epoch.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "operator": {
              "description": "Total pledge and compounded reward earned by the node operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "total_unit_reward": {
              "description": "Cumulative reward earned by the \"unit delegation\" since the block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "unique_delegations": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "unit_delegation": {
              "description": "Value of the theoretical \"unit delegation\" that has delegated to this mixnode at block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Percent": {
          "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_number_of_pending_events": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "NumberOfPendingEventsResponse",
      "description": "Response containing number of currently pending epoch and interval events.",
      "type": "object",
      "required": [
        "epoch_events",
        "interval_events"
      ],
      "properties": {
        "epoch_events": {
          "description": "The number of the currently pending epoch events.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "interval_events": {
          "description": "The number of the currently pending epoch events.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false
    },
    "get_owned_gateway": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "GatewayOwnershipResponse",
      "description": "Response containing details of a gateway belonging to the particular owner.",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "address": {
          "description": "Validated address of the gateway owner.",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "gateway": {
          "description": "If the provided address owns a gateway, this field contains its details.",
          "anyOf": [
            {
              "$ref": "#/definitions/GatewayBond"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Gateway": {
          "description": "Information provided by the node operator during bonding that are used to allow other entities to use the services of this node.",
          "type": "object",
          "required": [
            "clients_port",
            "host",
            "identity_key",
            "location",
            "mix_port",
            "sphinx_key",
            "version"
          ],
          "properties": {
            "clients_port": {
              "description": "Port used by this gateway for listening for client requests.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "host": {
              "description": "Network address of this gateway, for example 1.1.1.1 or foo.gateway.com",
              "type": "string"
            },
            "identity_key": {
              "description": "Base58 encoded ed25519 EdDSA public key of the gateway used to derive shared keys with clients",
              "type": "string"
            },
            "location": {
              "description": "The physical, self-reported, location of this gateway.",
              "type": "string"
            },
            "mix_port": {
              "description": "Port used by this gateway for listening for mix packets.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "sphinx_key": {
              "description": "Base58-encoded x25519 public key used for sphinx key derivation.",
              "type": "string"
            },
            "version": {
              "description": "The self-reported semver version of this gateway.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "GatewayBond": {
          "description": "Basic gateway information provided by the node operator.",
          "type": "object",
          "required": [
            "block_height",
            "gateway",
            "owner",
            "pledge_amount"
          ],
          "properties": {
            "block_height": {
              "description": "Block height at which this gateway has been bonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "gateway": {
              "description": "Information provided by the operator for the purposes of bonding.",
              "allOf": [
                {
                  "$ref": "#/definitions/Gateway"
                }
              ]
            },
            "owner": {
              "description": "Address of the owner of this gateway.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "pledge_amount": {
              "description": "Original amount pledged by the operator of this node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "proxy": {
              "description": "Entity who bonded this gateway on behalf of the owner. If exists, it's most likely the address of the vesting contract.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_owned_mixnode": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "MixOwnershipResponse",
      "description": "Response containing details of a mixnode belonging to the particular owner.",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "address": {
          "description": "Validated address of the mixnode owner.",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "mixnode_details": {
          "description": "If the provided address owns a mixnode, this field contains its detailed information.",
          "anyOf": [
            {
              "$ref": "#/definitions/MixNodeDetails"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Layer": {
          "type": "string",
          "enum": [
            "One",
            "Two",
            "Three"
          ]
        },
        "MixNode": {
          "description": "Information provided by the node operator during bonding that are used to allow other entities to use the services of this node.",
          "type": "object",
          "required": [
            "host",
            "http_api_port",
            "identity_key",
            "mix_port",
            "sphinx_key",
            "verloc_port",
            "version"
          ],
          "properties": {
            "host": {
              "description": "Network address of this mixnode, for example 1.1.1.1 or foo.mixnode.com",
              "type": "string"
            },
            "http_api_port": {
              "description": "Port used by this mixnode for its http(s) API",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            },
            "mix_port": {
              "description": "Port used by this mixnode for listening for mix packets.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "sphinx_key": {
              "description": "Base58-encoded x25519 public key used for sphinx key derivation.",
              "type": "string"
            },
            "verloc_port": {
              "description": "Port used by this mixnode for listening for verloc requests.",
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "version": {
              "description": "The self-reported semver version of this mixnode.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "MixNodeBond": {
          "description": "Basic mixnode information provided by the node operator.",
          "type": "object",
          "required": [
            "bonding_height",
            "is_unbonding",
            "layer",
            "mix_id",
            "mix_node",
            "original_pledge",
            "owner"
          ],
          "properties": {
            "bonding_height": {
              "description": "Block height at which this mixnode has been bonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "is_unbonding": {
              "description": "Flag to indicate whether this node is in the process of unbonding, that will conclude upon the epoch finishing.",
              "type": "boolean"
            },
            "layer": {
              "description": "Layer assigned to this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Layer"
                }
              ]
            },
            "mix_id": {
              "description": "Unique id assigned to the bonded mixnode.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "mix_node": {
              "description": "Information provided by the operator for the purposes of bonding.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNode"
                }
              ]
            },
            "original_pledge": {
              "description": "Original amount pledged by the operator of this node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "owner": {
              "description": "Address of the owner of this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Entity who bonded this mixnode on behalf of the owner. If exists, it's most likely the address of the vesting contract.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "MixNodeCostParams": {
          "description": "The cost parameters, or the cost function, defined for the particular mixnode that influences how the rewards should be split between the node operator and its delegators.",
          "type": "object",
          "required": [
            "interval_operating_cost",
            "profit_margin_percent"
          ],
          "properties": {
            "interval_operating_cost": {
              "description": "Operating cost of the associated mixnode per the entire interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "profit_margin_percent": {
              "description": "The profit margin of the associated mixnode, i.e. the desired percent of the reward to be distributed to the operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Percent"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "MixNodeDetails": {
          "description": "Full details associated with given mixnode.",
          "type": "object",
          "required": [
            "bond_information",
            "rewarding_details"
          ],
          "properties": {
            "bond_information": {
              "description": "Basic bond information of this mixnode, such as owner address, original pledge, etc.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNodeBond"
                }
              ]
            },
            "pending_changes": {
              "description": "Adjustments to the mixnode that are ought to happen during future epoch transitions.",
              "default": {
                "pledge_change": null
              },
              "allOf": [
                {
                  "$ref": "#/definitions/PendingMixNodeChanges"
                }
              ]
            },
            "rewarding_details": {
              "description": "Details used for computation of rewarding related data.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNodeRewarding"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "MixNodeRewarding": {
          "type": "object",
          "required": [
            "cost_params",
            "delegates",
            "last_rewarded_epoch",
            "operator",
            "total_unit_reward",
            "unique_delegations",
            "unit_delegation"
          ],
          "properties": {
            "cost_params": {
              "description": "Information provided by the operator that influence the cost function.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNodeCostParams"
                }
              ]
            },
            "delegates": {
              "description": "Total delegation and compounded reward earned by all node delegators.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "last_rewarded_epoch": {
              "description": "Marks the epoch when this node was last rewarded so that we wouldn't accidentally attempt to reward it multiple times in the same epoch.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "operator": {
              "description": "Total pledge and compounded reward earned by the node operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "total_unit_reward": {
              "description": "Cumulative reward earned by the \"unit delegation\" since the block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "unique_delegations": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "unit_delegation": {
              "description": "Value of the theoretical \"unit delegation\" that has delegated to this mixnode at block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PendingMixNodeChanges": {
          "type": "object",
          "properties": {
            "pledge_change": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Percent": {
          "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_pending_delegator_reward": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PendingRewardResponse",
      "description": "Response containing information about accrued rewards.",
      "type": "object",
      "required": [
        "mixnode_still_fully_bonded"
      ],
      "properties": {
        "amount_earned": {
          "description": "The amount of tokens that could be claimed.",
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "amount_earned_detailed": {
          "description": "The full pending rewards. Note that it's nearly identical to `amount_earned`, however, it contains few additional decimal points for more accurate reward calculation.",
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "amount_staked": {
          "description": "The amount of tokens initially staked.",
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "mixnode_still_fully_bonded": {
          "description": "The associated mixnode is still fully bonded, meaning it is neither unbonded nor in the process of unbonding that would have finished at the epoch transition.",
          "type": "boolean"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_pending_epoch_event": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PendingEpochEventResponse",
      "type": "object",
      "required": [
        "event_id"
      ],
      "properties": {
        "event": {
          "anyOf": [
            {
              "$ref": "#/definitions/PendingEpochEventData"
            },
            {
              "type": "null"
            }
          ]
        },
        "event_id": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "PendingEpochEventData": {
          "description": "Details of a particular pending epoch event.",
          "type": "object",
          "required": [
            "created_at",
            "kind"
          ],
          "properties": {
            "created_at": {
              "description": "The block height at which the request has been made.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "kind": {
              "description": "The underlying event data, containing its concrete type and information on how it should get resolved.",
              "allOf": [
                {
                  "$ref": "#/definitions/PendingEpochEventKind"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PendingEpochEventKind": {
          "description": "Enum encompassing all possible epoch events.",
          "oneOf": [
            {
              "description": "Request to create a delegation towards particular mixnode. Note that if such delegation already exists, it will get updated with the provided token amount.",
              "type": "object",
              "required": [
                "delegate"
              ],
              "properties": {
                "delegate": {
                  "type": "object",
                  "required": [
                    "amount",
                    "mix_id",
                    "owner"
                  ],
                  "properties": {
                    "amount": {
                      "description": "The amount of tokens to use for the delegation.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Coin"
                        }
                      ]
                    },
                    "mix_id": {
                      "description": "The id of the mixnode used for the delegation.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    },
                    "owner": {
                      "description": "The address of the owner of the delegation.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Addr"
                        }
                      ]
                    },
                    "proxy": {
                      "description": "Entity who made the delegation on behalf of the owner. If present, it's most likely the address of the vesting contract.",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/Addr"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to remove delegation from particular mixnode.",
              "type": "object",
              "required": [
                "undelegate"
              ],
              "properties": {
                "undelegate": {
                  "type": "object",
                  "required": [
                    "mix_id",
                    "owner"
                  ],
                  "properties": {
                    "mix_id": {
                      "description": "The id of the mixnode used for the delegation.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    },
                    "owner": {
                      "description": "The address of the owner of the delegation.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Addr"
                        }
                      ]
                    },
                    "proxy": {
                      "description": "Entity who made the delegation on behalf of the owner. If present, it's most likely the address of the vesting contract.",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/Addr"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to pledge more tokens (by the node operator) towards its node.",
              "type": "object",
              "required": [
                "pledge_more"
              ],
              "properties": {
                "pledge_more": {
                  "type": "object",
                  "required": [
                    "amount",
                    "mix_id"
                  ],
                  "properties": {
                    "amount": {
                      "description": "The amount of additional tokens to use by the pledge.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Coin"
                        }
                      ]
                    },
                    "mix_id": {
                      "description": "The id of the mixnode that will have its pledge updated.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to decrease amount of pledged tokens (by the node operator) from its node.",
              "type": "object",
              "required": [
                "decrease_pledge"
              ],
              "properties": {
                "decrease_pledge": {
                  "type": "object",
                  "required": [
                    "decrease_by",
                    "mix_id"
                  ],
                  "properties": {
                    "decrease_by": {
                      "description": "The amount of tokens that should be removed from the pledge.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Coin"
                        }
                      ]
                    },
                    "mix_id": {
                      "description": "The id of the mixnode that will have its pledge updated.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to unbond a mixnode and completely remove it from the network.",
              "type": "object",
              "required": [
                "unbond_mixnode"
              ],
              "properties": {
                "unbond_mixnode": {
                  "type": "object",
                  "required": [
                    "mix_id"
                  ],
                  "properties": {
                    "mix_id": {
                      "description": "The id of the mixnode that will get unbonded.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to update the current size of the active set.",
              "type": "object",
              "required": [
                "update_active_set_size"
              ],
              "properties": {
                "update_active_set_size": {
                  "type": "object",
                  "required": [
                    "new_size"
                  ],
                  "properties": {
                    "new_size": {
                      "description": "The new desired size of the active set.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_pending_epoch_events": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PendingEpochEventsResponse",
      "description": "Response containing all currently pending epoch events that will be resolved once the current epoch finishes.",
      "type": "object",
      "required": [
        "events",
        "seconds_until_executable"
      ],
      "properties": {
        "events": {
          "description": "The currently pending events.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/PendingEpochEvent"
          }
        },
        "seconds_until_executable": {
          "description": "Amount of seconds until the events would be eligible to be resolved. It's equivalent to the time until the current epoch finishes.",
          "type": "integer",
          "format": "int64"
        },
        "start_next_after": {
          "description": "Field indicating paging information for the following queries if the caller wishes to get further entries.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "PendingEpochEvent": {
          "description": "A request made at some point in the current epoch that's going to get resolved once the epoch rolls over.",
          "type": "object",
          "required": [
            "event",
            "id"
          ],
          "properties": {
            "event": {
              "description": "The underlying event details, containing its type and information on how it should get resolved.",
              "allOf": [
                {
                  "$ref": "#/definitions/PendingEpochEventData"
                }
              ]
            },
            "id": {
              "description": "The unique id associated with the event.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "PendingEpochEventData": {
          "description": "Details of a particular pending epoch event.",
          "type": "object",
          "required": [
            "created_at",
            "kind"
          ],
          "properties": {
            "created_at": {
              "description": "The block height at which the request has been made.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "kind": {
              "description": "The underlying event data, containing its concrete type and information on how it should get resolved.",
              "allOf": [
                {
                  "$ref": "#/definitions/PendingEpochEventKind"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PendingEpochEventKind": {
          "description": "Enum encompassing all possible epoch events.",
          "oneOf": [
            {
              "description": "Request to create a delegation towards particular mixnode. Note that if such delegation already exists, it will get updated with the provided token amount.",
              "type": "object",
              "required": [
                "delegate"
              ],
              "properties": {
                "delegate": {
                  "type": "object",
                  "required": [
                    "amount",
                    "mix_id",
                    "owner"
                  ],
                  "properties": {
                    "amount": {
                      "description": "The amount of tokens to use for the delegation.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Coin"
                        }
                      ]
                    },
                    "mix_id": {
                      "description": "The id of the mixnode used for the delegation.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    },
                    "owner": {
                      "description": "The address of the owner of the delegation.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Addr"
                        }
                      ]
                    },
                    "proxy": {
                      "description": "Entity who made the delegation on behalf of the owner. If present, it's most likely the address of the vesting contract.",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/Addr"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to remove delegation from particular mixnode.",
              "type": "object",
              "required": [
                "undelegate"
              ],
              "properties": {
                "undelegate": {
                  "type": "object",
                  "required": [
                    "mix_id",
                    "owner"
                  ],
                  "properties": {
                    "mix_id": {
                      "description": "The id of the mixnode used for the delegation.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    },
                    "owner": {
                      "description": "The address of the owner of the delegation.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Addr"
                        }
                      ]
                    },
                    "proxy": {
                      "description": "Entity who made the delegation on behalf of the owner. If present, it's most likely the address of the vesting contract.",
                      "anyOf": [
                        {
                          "$ref": "#/definitions/Addr"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to pledge more tokens (by the node operator) towards its node.",
              "type": "object",
              "required": [
                "pledge_more"
              ],
              "properties": {
                "pledge_more": {
                  "type": "object",
                  "required": [
                    "amount",
                    "mix_id"
                  ],
                  "properties": {
                    "amount": {
                      "description": "The amount of additional tokens to use by the pledge.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Coin"
                        }
                      ]
                    },
                    "mix_id": {
                      "description": "The id of the mixnode that will have its pledge updated.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to decrease amount of pledged tokens (by the node operator) from its node.",
              "type": "object",
              "required": [
                "decrease_pledge"
              ],
              "properties": {
                "decrease_pledge": {
                  "type": "object",
                  "required": [
                    "decrease_by",
                    "mix_id"
                  ],
                  "properties": {
                    "decrease_by": {
                      "description": "The amount of tokens that should be removed from the pledge.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Coin"
                        }
                      ]
                    },
                    "mix_id": {
                      "description": "The id of the mixnode that will have its pledge updated.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to unbond a mixnode and completely remove it from the network.",
              "type": "object",
              "required": [
                "unbond_mixnode"
              ],
              "properties": {
                "unbond_mixnode": {
                  "type": "object",
                  "required": [
                    "mix_id"
                  ],
                  "properties": {
                    "mix_id": {
                      "description": "The id of the mixnode that will get unbonded.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to update the current size of the active set.",
              "type": "object",
              "required": [
                "update_active_set_size"
              ],
              "properties": {
                "update_active_set_size": {
                  "type": "object",
                  "required": [
                    "new_size"
                  ],
                  "properties": {
                    "new_size": {
                      "description": "The new desired size of the active set.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_pending_interval_event": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PendingIntervalEventResponse",
      "type": "object",
      "required": [
        "event_id"
      ],
      "properties": {
        "event": {
          "anyOf": [
            {
              "$ref": "#/definitions/PendingIntervalEventData"
            },
            {
              "type": "null"
            }
          ]
        },
        "event_id": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "IntervalRewardingParamsUpdate": {
          "description": "Specification on how the rewarding params should be updated.",
          "type": "object",
          "properties": {
            "active_set_work_factor": {
              "description": "Defines the new value of the active set work factor.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Decimal"
                },
                {
                  "type": "null"
                }
              ]
            },
            "interval_pool_emission": {
              "description": "Defines the new value of the interval pool emission rate.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Percent"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reward_pool": {
              "description": "Defines the new value of the reward pool.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Decimal"
                },
                {
                  "type": "null"
                }
              ]
            },
            "rewarded_set_size": {
              "description": "Defines the new size of the rewarded set.",
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            },
            "staking_supply": {
              "description": "Defines the new value of the staking supply.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Decimal"
                },
                {
                  "type": "null"
                }
              ]
            },
            "staking_supply_scale_factor": {
              "description": "Defines the new value of the staking supply scale factor.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Percent"
                },
                {
                  "type": "null"
                }
              ]
            },
            "sybil_resistance_percent": {
              "description": "Defines the new value of the sybil resistance percent.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Percent"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "MixNodeCostParams": {
          "description": "The cost parameters, or the cost function, defined for the particular mixnode that influences how the rewards should be split between the node operator and its delegators.",
          "type": "object",
          "required": [
            "interval_operating_cost",
            "profit_margin_percent"
          ],
          "properties": {
            "interval_operating_cost": {
              "description": "Operating cost of the associated mixnode per the entire interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "profit_margin_percent": {
              "description": "The profit margin of the associated mixnode, i.e. the desired percent of the reward to be distributed to the operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Percent"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PendingIntervalEventData": {
          "description": "Details of a particular pending interval event.",
          "type": "object",
          "required": [
            "created_at",
            "kind"
          ],
          "properties": {
            "created_at": {
              "description": "The block height at which the request has been made.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "kind": {
              "description": "The underlying event data, containing its concrete type and information on how it should get resolved.",
              "allOf": [
                {
                  "$ref": "#/definitions/PendingIntervalEventKind"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PendingIntervalEventKind": {
          "description": "Enum encompassing all possible interval events.",
          "oneOf": [
            {
              "description": "Request to update cost parameters of given mixnode.",
              "type": "object",
              "required": [
                "change_mix_cost_params"
              ],
              "properties": {
                "change_mix_cost_params": {
                  "type": "object",
                  "required": [
                    "mix_id",
                    "new_costs"
                  ],
                  "properties": {
                    "mix_id": {
                      "description": "The id of the mixnode that will have its cost parameters updated.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    },
                    "new_costs": {
                      "description": "The new updated cost function of this mixnode.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/MixNodeCostParams"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to update the underlying rewarding parameters used by the system",
              "type": "object",
              "required": [
                "update_rewarding_params"
              ],
              "properties": {
                "update_rewarding_params": {
                  "type": "object",
                  "required": [
                    "update"
                  ],
                  "properties": {
                    "update": {
                      "description": "The detailed specification of the update.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/IntervalRewardingParamsUpdate"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to change the next interval configuration.",
              "type": "object",
              "required": [
                "update_interval_config"
              ],
              "properties": {
                "update_interval_config": {
                  "type": "object",
                  "required": [
                    "epoch_duration_secs",
                    "epochs_in_interval"
                  ],
                  "properties": {
                    "epoch_duration_secs": {
                      "description": "The new epoch duration.",
                      "type": "integer",
                      "format": "uint64",
                      "minimum": 0.0
                    },
                    "epochs_in_interval": {
                      "description": "The new number of epochs in intervals.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Percent": {
          "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_pending_interval_events": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PendingIntervalEventsResponse",
      "description": "Response containing all currently pending interval events that will be resolved once the current interval finishes.",
      "type": "object",
      "required": [
        "events",
        "seconds_until_executable"
      ],
      "properties": {
        "events": {
          "description": "The currently pending events.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/PendingIntervalEvent"
          }
        },
        "seconds_until_executable": {
          "description": "Amount of seconds until the events would be eligible to be resolved. It's equivalent to the time until the current interval finishes.",
          "type": "integer",
          "format": "int64"
        },
        "start_next_after": {
          "description": "Field indicating paging information for the following queries if the caller wishes to get further entries.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "IntervalRewardingParamsUpdate": {
          "description": "Specification on how the rewarding params should be updated.",
          "type": "object",
          "properties": {
            "active_set_work_factor": {
              "description": "Defines the new value of the active set work factor.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Decimal"
                },
                {
                  "type": "null"
                }
              ]
            },
            "interval_pool_emission": {
              "description": "Defines the new value of the interval pool emission rate.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Percent"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reward_pool": {
              "description": "Defines the new value of the reward pool.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Decimal"
                },
                {
                  "type": "null"
                }
              ]
            },
            "rewarded_set_size": {
              "description": "Defines the new size of the rewarded set.",
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            },
            "staking_supply": {
              "description": "Defines the new value of the staking supply.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Decimal"
                },
                {
                  "type": "null"
                }
              ]
            },
            "staking_supply_scale_factor": {
              "description": "Defines the new value of the staking supply scale factor.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Percent"
                },
                {
                  "type": "null"
                }
              ]
            },
            "sybil_resistance_percent": {
              "description": "Defines the new value of the sybil resistance percent.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Percent"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "MixNodeCostParams": {
          "description": "The cost parameters, or the cost function, defined for the particular mixnode that influences how the rewards should be split between the node operator and its delegators.",
          "type": "object",
          "required": [
            "interval_operating_cost",
            "profit_margin_percent"
          ],
          "properties": {
            "interval_operating_cost": {
              "description": "Operating cost of the associated mixnode per the entire interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "profit_margin_percent": {
              "description": "The profit margin of the associated mixnode, i.e. the desired percent of the reward to be distributed to the operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Percent"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PendingIntervalEvent": {
          "description": "A request made at some point in the current interval that's going to get resolved once the interval rolls over.",
          "type": "object",
          "required": [
            "event",
            "id"
          ],
          "properties": {
            "event": {
              "description": "The underlying event details, containing its type and information on how it should get resolved.",
              "allOf": [
                {
                  "$ref": "#/definitions/PendingIntervalEventData"
                }
              ]
            },
            "id": {
              "description": "The unique id associated with the event.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "PendingIntervalEventData": {
          "description": "Details of a particular pending interval event.",
          "type": "object",
          "required": [
            "created_at",
            "kind"
          ],
          "properties": {
            "created_at": {
              "description": "The block height at which the request has been made.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "kind": {
              "description": "The underlying event data, containing its concrete type and information on how it should get resolved.",
              "allOf": [
                {
                  "$ref": "#/definitions/PendingIntervalEventKind"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PendingIntervalEventKind": {
          "description": "Enum encompassing all possible interval events.",
          "oneOf": [
            {
              "description": "Request to update cost parameters of given mixnode.",
              "type": "object",
              "required": [
                "change_mix_cost_params"
              ],
              "properties": {
                "change_mix_cost_params": {
                  "type": "object",
                  "required": [
                    "mix_id",
                    "new_costs"
                  ],
                  "properties": {
                    "mix_id": {
                      "description": "The id of the mixnode that will have its cost parameters updated.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    },
                    "new_costs": {
                      "description": "The new updated cost function of this mixnode.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/MixNodeCostParams"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to update the underlying rewarding parameters used by the system",
              "type": "object",
              "required": [
                "update_rewarding_params"
              ],
              "properties": {
                "update_rewarding_params": {
                  "type": "object",
                  "required": [
                    "update"
                  ],
                  "properties": {
                    "update": {
                      "description": "The detailed specification of the update.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/IntervalRewardingParamsUpdate"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Request to change the next interval configuration.",
              "type": "object",
              "required": [
                "update_interval_config"
              ],
              "properties": {
                "update_interval_config": {
                  "type": "object",
                  "required": [
                    "epoch_duration_secs",
                    "epochs_in_interval"
                  ],
                  "properties": {
                    "epoch_duration_secs": {
                      "description": "The new epoch duration.",
                      "type": "integer",
                      "format": "uint64",
                      "minimum": 0.0
                    },
                    "epochs_in_interval": {
                      "description": "The new number of epochs in intervals.",
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Percent": {
          "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_pending_mix_node_operator_reward": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PendingRewardResponse",
      "description": "Response containing information about accrued rewards.",
      "type": "object",
      "required": [
        "mixnode_still_fully_bonded"
      ],
      "properties": {
        "amount_earned": {
          "description": "The amount of tokens that could be claimed.",
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "amount_earned_detailed": {
          "description": "The full pending rewards. Note that it's nearly identical to `amount_earned`, however, it contains few additional decimal points for more accurate reward calculation.",
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "amount_staked": {
          "description": "The amount of tokens initially staked.",
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "mixnode_still_fully_bonded": {
          "description": "The associated mixnode is still fully bonded, meaning it is neither unbonded nor in the process of unbonding that would have finished at the epoch transition.",
          "type": "boolean"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_pending_operator_reward": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PendingRewardResponse",
      "description": "Response containing information about accrued rewards.",
      "type": "object",
      "required": [
        "mixnode_still_fully_bonded"
      ],
      "properties": {
        "amount_earned": {
          "description": "The amount of tokens that could be claimed.",
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "amount_earned_detailed": {
          "description": "The full pending rewards. Note that it's nearly identical to `amount_earned`, however, it contains few additional decimal points for more accurate reward calculation.",
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "amount_staked": {
          "description": "The amount of tokens initially staked.",
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "mixnode_still_fully_bonded": {
          "description": "The associated mixnode is still fully bonded, meaning it is neither unbonded nor in the process of unbonding that would have finished at the epoch transition.",
          "type": "boolean"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_rewarded_set": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedRewardedSetResponse",
      "description": "Response containing paged list of all mixnodes in the rewarded set.",
      "type": "object",
      "required": [
        "nodes"
      ],
      "properties": {
        "nodes": {
          "description": "Nodes in the current rewarded set.",
          "type": "array",
          "items": {
            "type": "array",
            "items": [
              {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              {
                "$ref": "#/definitions/RewardedSetNodeStatus"
              }
            ],
            "maxItems": 2,
            "minItems": 2
          }
        },
        "start_next_after": {
          "description": "Field indicating paging information for the following queries if the caller wishes to get further entries.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "RewardedSetNodeStatus": {
          "description": "Current state of given node in the rewarded set.",
          "oneOf": [
            {
              "description": "Node that is currently active, i.e. is expected to be used by clients for mixing packets.",
              "type": "string",
              "enum": [
                "active"
              ]
            },
            {
              "description": "Node that is currently in standby, i.e. it's present in the rewarded set but is not active.",
              "type": "string",
              "enum": [
                "standby"
              ]
            }
          ]
        }
      }
    },
    "get_rewarding_params": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "RewardingParams",
      "description": "Parameters used for reward calculation.",
      "type": "object",
      "required": [
        "active_set_size",
        "interval",
        "rewarded_set_size"
      ],
      "properties": {
        "active_set_size": {
          "description": "The expected number of mixnodes in the active set.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "interval": {
          "description": "Parameters that should remain unchanged throughout an interval.",
          "allOf": [
            {
              "$ref": "#/definitions/IntervalRewardParams"
            }
          ]
        },
        "rewarded_set_size": {
          "description": "The expected number of mixnodes in the rewarded set (i.e. active + standby).",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "IntervalRewardParams": {
          "description": "Parameters required by the mix-mining reward distribution that do not change during an interval.",
          "type": "object",
          "required": [
            "active_set_work_factor",
            "epoch_reward_budget",
            "interval_pool_emission",
            "reward_pool",
            "stake_saturation_point",
            "staking_supply",
            "staking_supply_scale_factor",
            "sybil_resistance"
          ],
          "properties": {
            "active_set_work_factor": {
              "description": "Current active set work factor. It is not really expected to be changing very often. As a matter of fact, unless there's a very specific reason, it should remain constant.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "epoch_reward_budget": {
              "description": "Current value of the computed reward budget per epoch, per node. It is expected to be constant throughout the interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "interval_pool_emission": {
              "description": "Current maximum interval pool emission. Assuming all nodes in the rewarded set are fully saturated and have 100% performance, this % of the reward pool would get distributed in rewards to all operators and its delegators. It is not really expected to be changing very often. As a matter of fact, unless there's a very specific reason, it should remain constant.",
              "allOf": [
                {
                  "$ref": "#/definitions/Percent"
                }
              ]
            },
            "reward_pool": {
              "description": "Current value of the rewarding pool. It is expected to be constant throughout the interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "stake_saturation_point": {
              "description": "Current value of the stake saturation point. It is expected to be constant throughout the interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "staking_supply": {
              "description": "Current value of the staking supply. It is expected to be constant throughout the interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "staking_supply_scale_factor": {
              "description": "Defines the percentage of stake needed to reach saturation for all of the nodes in the rewarded set. Also known as `beta`.",
              "allOf": [
                {
                  "$ref": "#/definitions/Percent"
                }
              ]
            },
            "sybil_resistance": {
              "description": "Current value of the sybil resistance percent (`alpha`). It is not really expected to be changing very often. As a matter of fact, unless there's a very specific reason, it should remain constant.",
              "allOf": [
                {
                  "$ref": "#/definitions/Percent"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Percent": {
          "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        }
      }
    },
    "get_rewarding_validator_address": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "String",
      "type": "string"
    },
    "get_signing_nonce": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "uint32",
      "type": "integer",
      "format": "uint32",
      "minimum": 0.0
    },
    "get_stake_saturation": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "StakeSaturationResponse",
      "description": "Response containing the current state of the stake saturation of a mixnode with the provided id.",
      "type": "object",
      "required": [
        "mix_id"
      ],
      "properties": {
        "current_saturation": {
          "description": "The current stake saturation of this node that is indirectly used in reward calculation formulas. Note that it can't be larger than 1.",
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "mix_id": {
          "description": "Id of the requested mixnode.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "uncapped_saturation": {
          "description": "The current, absolute, stake saturation of this node. Note that as the name suggests it can be larger than 1. However, anything beyond that value has no effect on the total node reward.",
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        }
      }
    },
    "get_state": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ContractState",
      "description": "The current state of the mixnet contract.",
      "type": "object",
      "required": [
        "owner",
        "params",
        "rewarding_denom",
        "rewarding_validator_address",
        "vesting_contract_address"
      ],
      "properties": {
        "owner": {
          "description": "Address of the contract owner.",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "params": {
          "description": "Contract parameters that could be adjusted in a transaction the contract admin.",
          "allOf": [
            {
              "$ref": "#/definitions/ContractStateParams"
            }
          ]
        },
        "rewarding_denom": {
          "description": "The expected denom used for rewarding (and realistically any other operation). Default: `unym`",
          "type": "string"
        },
        "rewarding_validator_address": {
          "description": "Address of \"rewarding validator\" (nym-api) that's allowed to send any rewarding-related transactions.",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "vesting_contract_address": {
          "description": "Address of the vesting contract to which the mixnet contract would be sending all track-related messages.",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "ContractStateParams": {
          "description": "Contract parameters that could be adjusted in a transaction by the contract admin.",
          "type": "object",
          "required": [
            "minimum_gateway_pledge",
            "minimum_mixnode_pledge"
          ],
          "properties": {
            "minimum_gateway_pledge": {
              "description": "Minimum amount a gateway must pledge to get into the system.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "minimum_mixnode_delegation": {
              "description": "Minimum amount a delegator must stake in orders for his delegation to get accepted.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Coin"
                },
                {
                  "type": "null"
                }
              ]
            },
            "minimum_mixnode_pledge": {
              "description": "Minimum amount a mixnode must pledge to get into the system.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_state_params": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ContractStateParams",
      "description": "Contract parameters that could be adjusted in a transaction by the contract admin.",
      "type": "object",
      "required": [
        "minimum_gateway_pledge",
        "minimum_mixnode_pledge"
      ],
      "properties": {
        "minimum_gateway_pledge": {
          "description": "Minimum amount a gateway must pledge to get into the system.",
          "allOf": [
            {
              "$ref": "#/definitions/Coin"
            }
          ]
        },
        "minimum_mixnode_delegation": {
          "description": "Minimum amount a delegator must stake in orders for his delegation to get accepted.",
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "minimum_mixnode_pledge": {
          "description": "Minimum amount a mixnode must pledge to get into the system.",
          "allOf": [
            {
              "$ref": "#/definitions/Coin"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_unbonded_mix_node_information": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "UnbondedMixnodeResponse",
      "description": "Response containing basic information of an unbonded mixnode with the provided id.",
      "type": "object",
      "required": [
        "mix_id"
      ],
      "properties": {
        "mix_id": {
          "description": "Id of the requested mixnode.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "unbonded_info": {
          "description": "If there existed a mixnode with the provided id, this field contains its basic information.",
          "anyOf": [
            {
              "$ref": "#/definitions/UnbondedMixnode"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "UnbondedMixnode": {
          "description": "Basic information of a node that used to be part of the mix network but has already unbonded.",
          "type": "object",
          "required": [
            "identity_key",
            "owner",
            "unbonding_height"
          ],
          "properties": {
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            },
            "owner": {
              "description": "Address of the owner of this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Entity who bonded this mixnode on behalf of the owner. If exists, it's most likely the address of the vesting contract.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "unbonding_height": {
              "description": "Block height at which this mixnode has unbonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      }
    },
    "get_unbonded_mix_nodes": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedUnbondedMixnodesResponse",
      "description": "Response containing paged list of all mixnodes that have ever unbonded.",
      "type": "object",
      "required": [
        "nodes",
        "per_page"
      ],
      "properties": {
        "nodes": {
          "description": "The past ids of unbonded mixnodes alongside their basic information such as the owner or the identity key.",
          "type": "array",
          "items": {
            "type": "array",
            "items": [
              {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              {
                "$ref": "#/definitions/UnbondedMixnode"
              }
            ],
            "maxItems": 2,
            "minItems": 2
          }
        },
        "per_page": {
          "description": "Maximum number of entries that could be included in a response. `per_page <= nodes.len()`",
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        },
        "start_next_after": {
          "description": "Field indicating paging information for the following queries if the caller wishes to get further entries.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "UnbondedMixnode": {
          "description": "Basic information of a node that used to be part of the mix network but has already unbonded.",
          "type": "object",
          "required": [
            "identity_key",
            "owner",
            "unbonding_height"
          ],
          "properties": {
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            },
            "owner": {
              "description": "Address of the owner of this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Entity who bonded this mixnode on behalf of the owner. If exists, it's most likely the address of the vesting contract.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "unbonding_height": {
              "description": "Block height at which this mixnode has unbonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      }
    },
    "get_unbonded_mix_nodes_by_identity_key": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedUnbondedMixnodesResponse",
      "description": "Response containing paged list of all mixnodes that have ever unbonded.",
      "type": "object",
      "required": [
        "nodes",
        "per_page"
      ],
      "properties": {
        "nodes": {
          "description": "The past ids of unbonded mixnodes alongside their basic information such as the owner or the identity key.",
          "type": "array",
          "items": {
            "type": "array",
            "items": [
              {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              {
                "$ref": "#/definitions/UnbondedMixnode"
              }
            ],
            "maxItems": 2,
            "minItems": 2
          }
        },
        "per_page": {
          "description": "Maximum number of entries that could be included in a response. `per_page <= nodes.len()`",
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        },
        "start_next_after": {
          "description": "Field indicating paging information for the following queries if the caller wishes to get further entries.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "UnbondedMixnode": {
          "description": "Basic information of a node that used to be part of the mix network but has already unbonded.",
          "type": "object",
          "required": [
            "identity_key",
            "owner",
            "unbonding_height"
          ],
          "properties": {
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            },
            "owner": {
              "description": "Address of the owner of this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Entity who bonded this mixnode on behalf of the owner. If exists, it's most likely the address of the vesting contract.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "unbonding_height": {
              "description": "Block height at which this mixnode has unbonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      }
    },
    "get_unbonded_mix_nodes_by_owner": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedUnbondedMixnodesResponse",
      "description": "Response containing paged list of all mixnodes that have ever unbonded.",
      "type": "object",
      "required": [
        "nodes",
        "per_page"
      ],
      "properties": {
        "nodes": {
          "description": "The past ids of unbonded mixnodes alongside their basic information such as the owner or the identity key.",
          "type": "array",
          "items": {
            "type": "array",
            "items": [
              {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              {
                "$ref": "#/definitions/UnbondedMixnode"
              }
            ],
            "maxItems": 2,
            "minItems": 2
          }
        },
        "per_page": {
          "description": "Maximum number of entries that could be included in a response. `per_page <= nodes.len()`",
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        },
        "start_next_after": {
          "description": "Field indicating paging information for the following queries if the caller wishes to get further entries.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "UnbondedMixnode": {
          "description": "Basic information of a node that used to be part of the mix network but has already unbonded.",
          "type": "object",
          "required": [
            "identity_key",
            "owner",
            "unbonding_height"
          ],
          "properties": {
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            },
            "owner": {
              "description": "Address of the owner of this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Entity who bonded this mixnode on behalf of the owner. If exists, it's most likely the address of the vesting contract.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "unbonding_height": {
              "description": "Block height at which this mixnode has unbonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      }
    }
  }
}
