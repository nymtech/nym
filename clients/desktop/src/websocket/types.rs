// Copyright 2020 Nym Technologies SA
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use nymsphinx::addressing::clients::Recipient;
use serde::{Deserialize, Serialize};
use std::convert::TryFrom;
use tokio_tungstenite::tungstenite::protocol::Message;

#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "type", rename_all = "camelCase")]
pub enum ClientRequest {
    Send { message: String, recipient: String },
    GetClients,
    SelfAddress,
}

impl TryFrom<String> for ClientRequest {
    type Error = serde_json::Error;

    fn try_from(msg: String) -> Result<Self, Self::Error> {
        serde_json::from_str(&msg)
    }
}

impl Into<Message> for ClientRequest {
    fn into(self) -> Message {
        let str_req = serde_json::to_string(&self).unwrap();
        Message::Text(str_req)
    }
}

pub enum BinaryClientRequest {
    Send { recipient: Recipient, data: Vec<u8> },
}

impl BinaryClientRequest {
    // TODO: perhaps do it the proper way and introduce an error type
    pub fn try_from_bytes(req: &[u8]) -> Option<Self> {
        if req.len() < Recipient::LEN {
            return None;
        }
        let mut recipient_bytes = [0u8; Recipient::LEN];
        recipient_bytes.copy_from_slice(&req[..Recipient::LEN]);
        let recipient = Recipient::from_bytes(recipient_bytes);

        Some(BinaryClientRequest::Send {
            recipient,
            data: req[Recipient::LEN..].to_vec(),
        })
    }

    pub fn into_bytes(self) -> Vec<u8> {
        match self {
            Self::Send { recipient, data } => recipient
                .into_bytes()
                .iter()
                .cloned()
                .chain(data.into_iter())
                .collect(),
        }
    }
}

impl Into<Message> for BinaryClientRequest {
    fn into(self) -> Message {
        Message::Binary(self.into_bytes())
    }
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "type", rename_all = "camelCase")]
pub enum ServerResponse {
    Send,
    Received { messages: Vec<String> },
    GetClients { clients: Vec<String> },
    SelfAddress { address: String },
    Error { message: String },
}

impl ServerResponse {
    pub fn new_error<S: Into<String>>(msg: S) -> Self {
        ServerResponse::Error {
            message: msg.into(),
        }
    }
}

impl TryFrom<String> for ServerResponse {
    type Error = serde_json::Error;

    fn try_from(msg: String) -> Result<Self, <ServerResponse as TryFrom<String>>::Error> {
        serde_json::from_str(&msg)
    }
}

impl Into<Message> for ServerResponse {
    fn into(self) -> Message {
        // it should be safe to call `unwrap` here as the message is generated by the server
        // so if it fails (and consequently panics) it's a bug that should be resolved
        let str_res = serde_json::to_string(&self).unwrap();
        Message::Text(str_res)
    }
}
