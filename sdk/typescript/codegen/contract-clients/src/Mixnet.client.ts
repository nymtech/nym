/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { Decimal, Percent, InstantiateMsg, Duration, InitialRewardingParams, ExecuteMsg, Layer, FamilyHead, MessageSignature, Uint128, ContractStateParams, Coin, IntervalRewardingParamsUpdate, LayerAssignment, MixNodeCostParams, MixNode, MixNodeConfigUpdate, Gateway, GatewayConfigUpdate, QueryMsg, MigrateMsg, Addr, PagedAllDelegationsResponse, Delegation, PagedFamiliesResponse, Family, PagedMembersResponse, MixnodeDetailsByIdentityResponse, MixNodeDetails, MixNodeBond, PendingMixNodeChanges, MixNodeRewarding, ContractVersion, ContractBuildInformation, CurrentIntervalResponse, Interval, MixNodeDelegationResponse, PagedDelegatorDelegationsResponse, EpochState, EpochStatus, EstimatedCurrentEpochRewardResponse, FamilyByHeadResponse, FamilyByLabelResponse, FamilyMembersByHeadResponse, FamilyMembersByLabelResponse, GatewayBondResponse, GatewayBond, PagedGatewayResponse, LayerDistribution, PagedMixnodeBondsResponse, PagedMixnodesDetailsResponse, PagedMixNodeDelegationsResponse, MixnodeDetailsResponse, MixnodeRewardingDetailsResponse, NumberOfPendingEventsResponse, GatewayOwnershipResponse, MixOwnershipResponse, PendingRewardResponse, PendingEpochEventKind, PendingEpochEventResponse, PendingEpochEventData, PendingEpochEventsResponse, PendingEpochEvent, PendingIntervalEventKind, PendingIntervalEventResponse, PendingIntervalEventData, PendingIntervalEventsResponse, PendingIntervalEvent, RewardedSetNodeStatus, PagedRewardedSetResponse, RewardingParams, IntervalRewardParams, String, Uint32, StakeSaturationResponse, ContractState, UnbondedMixnodeResponse, UnbondedMixnode, PagedUnbondedMixnodesResponse } from "./Mixnet.types";
import { GetCw2ContractVersionResponse } from './types';
export interface MixnetReadOnlyInterface {
  contractAddress: string;
  getAllFamiliesPaged: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<PagedFamiliesResponse>;
  getAllMembersPaged: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<PagedMembersResponse>;
  getFamilyByHead: ({
    head
  }: {
    head: string;
  }) => Promise<FamilyByHeadResponse>;
  getFamilyByLabel: ({
    label
  }: {
    label: string;
  }) => Promise<FamilyByLabelResponse>;
  getFamilyMembersByHead: ({
    head
  }: {
    head: string;
  }) => Promise<FamilyMembersByHeadResponse>;
  getFamilyMembersByLabel: ({
    label
  }: {
    label: string;
  }) => Promise<FamilyMembersByLabelResponse>;
  getContractVersion: () => Promise<ContractBuildInformation>;
  getCw2ContractVersion: () => Promise<GetCw2ContractVersionResponse>;
  getRewardingValidatorAddress: () => Promise<String>;
  getStateParams: () => Promise<ContractStateParams>;
  getState: () => Promise<ContractState>;
  getRewardingParams: () => Promise<RewardingParams>;
  getEpochStatus: () => Promise<EpochStatus>;
  getCurrentIntervalDetails: () => Promise<CurrentIntervalResponse>;
  getRewardedSet: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<PagedRewardedSetResponse>;
  getMixNodeBonds: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<PagedMixnodeBondsResponse>;
  getMixNodesDetailed: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<PagedMixnodesDetailsResponse>;
  getUnbondedMixNodes: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<PagedUnbondedMixnodesResponse>;
  getUnbondedMixNodesByOwner: ({
    limit,
    owner,
    startAfter
  }: {
    limit?: number;
    owner: string;
    startAfter?: number;
  }) => Promise<PagedUnbondedMixnodesResponse>;
  getUnbondedMixNodesByIdentityKey: ({
    identityKey,
    limit,
    startAfter
  }: {
    identityKey: string;
    limit?: number;
    startAfter?: number;
  }) => Promise<PagedUnbondedMixnodesResponse>;
  getOwnedMixnode: ({
    address
  }: {
    address: string;
  }) => Promise<MixOwnershipResponse>;
  getMixnodeDetails: ({
    mixId
  }: {
    mixId: number;
  }) => Promise<MixnodeDetailsResponse>;
  getMixnodeRewardingDetails: ({
    mixId
  }: {
    mixId: number;
  }) => Promise<MixnodeRewardingDetailsResponse>;
  getStakeSaturation: ({
    mixId
  }: {
    mixId: number;
  }) => Promise<StakeSaturationResponse>;
  getUnbondedMixNodeInformation: ({
    mixId
  }: {
    mixId: number;
  }) => Promise<UnbondedMixnodeResponse>;
  getBondedMixnodeDetailsByIdentity: ({
    mixIdentity
  }: {
    mixIdentity: string;
  }) => Promise<MixnodeDetailsByIdentityResponse>;
  getLayerDistribution: () => Promise<LayerDistribution>;
  getGateways: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<PagedGatewayResponse>;
  getGatewayBond: ({
    identity
  }: {
    identity: string;
  }) => Promise<GatewayBondResponse>;
  getOwnedGateway: ({
    address
  }: {
    address: string;
  }) => Promise<GatewayOwnershipResponse>;
  getMixnodeDelegations: ({
    limit,
    mixId,
    startAfter
  }: {
    limit?: number;
    mixId: number;
    startAfter?: string;
  }) => Promise<PagedMixNodeDelegationsResponse>;
  getDelegatorDelegations: ({
    delegator,
    limit,
    startAfter
  }: {
    delegator: string;
    limit?: number;
    startAfter?: number[][];
  }) => Promise<PagedDelegatorDelegationsResponse>;
  getDelegationDetails: ({
    delegator,
    mixId,
    proxy
  }: {
    delegator: string;
    mixId: number;
    proxy?: string;
  }) => Promise<MixNodeDelegationResponse>;
  getAllDelegations: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number[][];
  }) => Promise<PagedAllDelegationsResponse>;
  getPendingOperatorReward: ({
    address
  }: {
    address: string;
  }) => Promise<PendingRewardResponse>;
  getPendingMixNodeOperatorReward: ({
    mixId
  }: {
    mixId: number;
  }) => Promise<PendingRewardResponse>;
  getPendingDelegatorReward: ({
    address,
    mixId,
    proxy
  }: {
    address: string;
    mixId: number;
    proxy?: string;
  }) => Promise<PendingRewardResponse>;
  getEstimatedCurrentEpochOperatorReward: ({
    estimatedPerformance,
    mixId
  }: {
    estimatedPerformance: Percent;
    mixId: number;
  }) => Promise<EstimatedCurrentEpochRewardResponse>;
  getEstimatedCurrentEpochDelegatorReward: ({
    address,
    estimatedPerformance,
    mixId,
    proxy
  }: {
    address: string;
    estimatedPerformance: Percent;
    mixId: number;
    proxy?: string;
  }) => Promise<EstimatedCurrentEpochRewardResponse>;
  getPendingEpochEvents: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<PendingEpochEventsResponse>;
  getPendingIntervalEvents: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<PendingIntervalEventsResponse>;
  getPendingEpochEvent: ({
    eventId
  }: {
    eventId: number;
  }) => Promise<PendingEpochEventResponse>;
  getPendingIntervalEvent: ({
    eventId
  }: {
    eventId: number;
  }) => Promise<PendingIntervalEventResponse>;
  getNumberOfPendingEvents: () => Promise<NumberOfPendingEventsResponse>;
  getSigningNonce: ({
    address
  }: {
    address: string;
  }) => Promise<Uint32>;
}
export class MixnetQueryClient implements MixnetReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.getAllFamiliesPaged = this.getAllFamiliesPaged.bind(this);
    this.getAllMembersPaged = this.getAllMembersPaged.bind(this);
    this.getFamilyByHead = this.getFamilyByHead.bind(this);
    this.getFamilyByLabel = this.getFamilyByLabel.bind(this);
    this.getFamilyMembersByHead = this.getFamilyMembersByHead.bind(this);
    this.getFamilyMembersByLabel = this.getFamilyMembersByLabel.bind(this);
    this.getContractVersion = this.getContractVersion.bind(this);
    this.getCw2ContractVersion = this.getCw2ContractVersion.bind(this);
    this.getRewardingValidatorAddress = this.getRewardingValidatorAddress.bind(this);
    this.getStateParams = this.getStateParams.bind(this);
    this.getState = this.getState.bind(this);
    this.getRewardingParams = this.getRewardingParams.bind(this);
    this.getEpochStatus = this.getEpochStatus.bind(this);
    this.getCurrentIntervalDetails = this.getCurrentIntervalDetails.bind(this);
    this.getRewardedSet = this.getRewardedSet.bind(this);
    this.getMixNodeBonds = this.getMixNodeBonds.bind(this);
    this.getMixNodesDetailed = this.getMixNodesDetailed.bind(this);
    this.getUnbondedMixNodes = this.getUnbondedMixNodes.bind(this);
    this.getUnbondedMixNodesByOwner = this.getUnbondedMixNodesByOwner.bind(this);
    this.getUnbondedMixNodesByIdentityKey = this.getUnbondedMixNodesByIdentityKey.bind(this);
    this.getOwnedMixnode = this.getOwnedMixnode.bind(this);
    this.getMixnodeDetails = this.getMixnodeDetails.bind(this);
    this.getMixnodeRewardingDetails = this.getMixnodeRewardingDetails.bind(this);
    this.getStakeSaturation = this.getStakeSaturation.bind(this);
    this.getUnbondedMixNodeInformation = this.getUnbondedMixNodeInformation.bind(this);
    this.getBondedMixnodeDetailsByIdentity = this.getBondedMixnodeDetailsByIdentity.bind(this);
    this.getLayerDistribution = this.getLayerDistribution.bind(this);
    this.getGateways = this.getGateways.bind(this);
    this.getGatewayBond = this.getGatewayBond.bind(this);
    this.getOwnedGateway = this.getOwnedGateway.bind(this);
    this.getMixnodeDelegations = this.getMixnodeDelegations.bind(this);
    this.getDelegatorDelegations = this.getDelegatorDelegations.bind(this);
    this.getDelegationDetails = this.getDelegationDetails.bind(this);
    this.getAllDelegations = this.getAllDelegations.bind(this);
    this.getPendingOperatorReward = this.getPendingOperatorReward.bind(this);
    this.getPendingMixNodeOperatorReward = this.getPendingMixNodeOperatorReward.bind(this);
    this.getPendingDelegatorReward = this.getPendingDelegatorReward.bind(this);
    this.getEstimatedCurrentEpochOperatorReward = this.getEstimatedCurrentEpochOperatorReward.bind(this);
    this.getEstimatedCurrentEpochDelegatorReward = this.getEstimatedCurrentEpochDelegatorReward.bind(this);
    this.getPendingEpochEvents = this.getPendingEpochEvents.bind(this);
    this.getPendingIntervalEvents = this.getPendingIntervalEvents.bind(this);
    this.getPendingEpochEvent = this.getPendingEpochEvent.bind(this);
    this.getPendingIntervalEvent = this.getPendingIntervalEvent.bind(this);
    this.getNumberOfPendingEvents = this.getNumberOfPendingEvents.bind(this);
    this.getSigningNonce = this.getSigningNonce.bind(this);
  }

  getAllFamiliesPaged = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<PagedFamiliesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_all_families_paged: {
        limit,
        start_after: startAfter
      }
    });
  };
  getAllMembersPaged = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<PagedMembersResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_all_members_paged: {
        limit,
        start_after: startAfter
      }
    });
  };
  getFamilyByHead = async ({
    head
  }: {
    head: string;
  }): Promise<FamilyByHeadResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_family_by_head: {
        head
      }
    });
  };
  getFamilyByLabel = async ({
    label
  }: {
    label: string;
  }): Promise<FamilyByLabelResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_family_by_label: {
        label
      }
    });
  };
  getFamilyMembersByHead = async ({
    head
  }: {
    head: string;
  }): Promise<FamilyMembersByHeadResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_family_members_by_head: {
        head
      }
    });
  };
  getFamilyMembersByLabel = async ({
    label
  }: {
    label: string;
  }): Promise<FamilyMembersByLabelResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_family_members_by_label: {
        label
      }
    });
  };
  getContractVersion = async (): Promise<ContractBuildInformation> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_contract_version: {}
    });
  };
  getCw2ContractVersion = async (): Promise<GetCw2ContractVersionResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_cw2_contract_version: {}
    });
  };
  getRewardingValidatorAddress = async (): Promise<String> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_rewarding_validator_address: {}
    });
  };
  getStateParams = async (): Promise<ContractStateParams> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_state_params: {}
    });
  };
  getState = async (): Promise<ContractState> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_state: {}
    });
  };
  getRewardingParams = async (): Promise<RewardingParams> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_rewarding_params: {}
    });
  };
  getEpochStatus = async (): Promise<EpochStatus> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_epoch_status: {}
    });
  };
  getCurrentIntervalDetails = async (): Promise<CurrentIntervalResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_current_interval_details: {}
    });
  };
  getRewardedSet = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<PagedRewardedSetResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_rewarded_set: {
        limit,
        start_after: startAfter
      }
    });
  };
  getMixNodeBonds = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<PagedMixnodeBondsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_mix_node_bonds: {
        limit,
        start_after: startAfter
      }
    });
  };
  getMixNodesDetailed = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<PagedMixnodesDetailsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_mix_nodes_detailed: {
        limit,
        start_after: startAfter
      }
    });
  };
  getUnbondedMixNodes = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<PagedUnbondedMixnodesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_unbonded_mix_nodes: {
        limit,
        start_after: startAfter
      }
    });
  };
  getUnbondedMixNodesByOwner = async ({
    limit,
    owner,
    startAfter
  }: {
    limit?: number;
    owner: string;
    startAfter?: number;
  }): Promise<PagedUnbondedMixnodesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_unbonded_mix_nodes_by_owner: {
        limit,
        owner,
        start_after: startAfter
      }
    });
  };
  getUnbondedMixNodesByIdentityKey = async ({
    identityKey,
    limit,
    startAfter
  }: {
    identityKey: string;
    limit?: number;
    startAfter?: number;
  }): Promise<PagedUnbondedMixnodesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_unbonded_mix_nodes_by_identity_key: {
        identity_key: identityKey,
        limit,
        start_after: startAfter
      }
    });
  };
  getOwnedMixnode = async ({
    address
  }: {
    address: string;
  }): Promise<MixOwnershipResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_owned_mixnode: {
        address
      }
    });
  };
  getMixnodeDetails = async ({
    mixId
  }: {
    mixId: number;
  }): Promise<MixnodeDetailsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_mixnode_details: {
        mix_id: mixId
      }
    });
  };
  getMixnodeRewardingDetails = async ({
    mixId
  }: {
    mixId: number;
  }): Promise<MixnodeRewardingDetailsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_mixnode_rewarding_details: {
        mix_id: mixId
      }
    });
  };
  getStakeSaturation = async ({
    mixId
  }: {
    mixId: number;
  }): Promise<StakeSaturationResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_stake_saturation: {
        mix_id: mixId
      }
    });
  };
  getUnbondedMixNodeInformation = async ({
    mixId
  }: {
    mixId: number;
  }): Promise<UnbondedMixnodeResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_unbonded_mix_node_information: {
        mix_id: mixId
      }
    });
  };
  getBondedMixnodeDetailsByIdentity = async ({
    mixIdentity
  }: {
    mixIdentity: string;
  }): Promise<MixnodeDetailsByIdentityResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_bonded_mixnode_details_by_identity: {
        mix_identity: mixIdentity
      }
    });
  };
  getLayerDistribution = async (): Promise<LayerDistribution> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_layer_distribution: {}
    });
  };
  getGateways = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<PagedGatewayResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_gateways: {
        limit,
        start_after: startAfter
      }
    });
  };
  getGatewayBond = async ({
    identity
  }: {
    identity: string;
  }): Promise<GatewayBondResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_gateway_bond: {
        identity
      }
    });
  };
  getOwnedGateway = async ({
    address
  }: {
    address: string;
  }): Promise<GatewayOwnershipResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_owned_gateway: {
        address
      }
    });
  };
  getMixnodeDelegations = async ({
    limit,
    mixId,
    startAfter
  }: {
    limit?: number;
    mixId: number;
    startAfter?: string;
  }): Promise<PagedMixNodeDelegationsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_mixnode_delegations: {
        limit,
        mix_id: mixId,
        start_after: startAfter
      }
    });
  };
  getDelegatorDelegations = async ({
    delegator,
    limit,
    startAfter
  }: {
    delegator: string;
    limit?: number;
    startAfter?: number[][];
  }): Promise<PagedDelegatorDelegationsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_delegator_delegations: {
        delegator,
        limit,
        start_after: startAfter
      }
    });
  };
  getDelegationDetails = async ({
    delegator,
    mixId,
    proxy
  }: {
    delegator: string;
    mixId: number;
    proxy?: string;
  }): Promise<MixNodeDelegationResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_delegation_details: {
        delegator,
        mix_id: mixId,
        proxy
      }
    });
  };
  getAllDelegations = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number[][];
  }): Promise<PagedAllDelegationsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_all_delegations: {
        limit,
        start_after: startAfter
      }
    });
  };
  getPendingOperatorReward = async ({
    address
  }: {
    address: string;
  }): Promise<PendingRewardResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_pending_operator_reward: {
        address
      }
    });
  };
  getPendingMixNodeOperatorReward = async ({
    mixId
  }: {
    mixId: number;
  }): Promise<PendingRewardResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_pending_mix_node_operator_reward: {
        mix_id: mixId
      }
    });
  };
  getPendingDelegatorReward = async ({
    address,
    mixId,
    proxy
  }: {
    address: string;
    mixId: number;
    proxy?: string;
  }): Promise<PendingRewardResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_pending_delegator_reward: {
        address,
        mix_id: mixId,
        proxy
      }
    });
  };
  getEstimatedCurrentEpochOperatorReward = async ({
    estimatedPerformance,
    mixId
  }: {
    estimatedPerformance: Percent;
    mixId: number;
  }): Promise<EstimatedCurrentEpochRewardResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_estimated_current_epoch_operator_reward: {
        estimated_performance: estimatedPerformance,
        mix_id: mixId
      }
    });
  };
  getEstimatedCurrentEpochDelegatorReward = async ({
    address,
    estimatedPerformance,
    mixId,
    proxy
  }: {
    address: string;
    estimatedPerformance: Percent;
    mixId: number;
    proxy?: string;
  }): Promise<EstimatedCurrentEpochRewardResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_estimated_current_epoch_delegator_reward: {
        address,
        estimated_performance: estimatedPerformance,
        mix_id: mixId,
        proxy
      }
    });
  };
  getPendingEpochEvents = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<PendingEpochEventsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_pending_epoch_events: {
        limit,
        start_after: startAfter
      }
    });
  };
  getPendingIntervalEvents = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<PendingIntervalEventsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_pending_interval_events: {
        limit,
        start_after: startAfter
      }
    });
  };
  getPendingEpochEvent = async ({
    eventId
  }: {
    eventId: number;
  }): Promise<PendingEpochEventResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_pending_epoch_event: {
        event_id: eventId
      }
    });
  };
  getPendingIntervalEvent = async ({
    eventId
  }: {
    eventId: number;
  }): Promise<PendingIntervalEventResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_pending_interval_event: {
        event_id: eventId
      }
    });
  };
  getNumberOfPendingEvents = async (): Promise<NumberOfPendingEventsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_number_of_pending_events: {}
    });
  };
  getSigningNonce = async ({
    address
  }: {
    address: string;
  }): Promise<Uint32> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_signing_nonce: {
        address
      }
    });
  };
}
export interface MixnetInterface extends MixnetReadOnlyInterface {
  contractAddress: string;
  sender: string;
  assignNodeLayer: ({
    layer,
    mixId
  }: {
    layer: Layer;
    mixId: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  createFamily: ({
    label
  }: {
    label: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  joinFamily: ({
    familyHead,
    joinPermit
  }: {
    familyHead: FamilyHead;
    joinPermit: MessageSignature;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  leaveFamily: ({
    familyHead
  }: {
    familyHead: FamilyHead;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  kickFamilyMember: ({
    member
  }: {
    member: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  createFamilyOnBehalf: ({
    label,
    ownerAddress
  }: {
    label: string;
    ownerAddress: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  joinFamilyOnBehalf: ({
    familyHead,
    joinPermit,
    memberAddress
  }: {
    familyHead: FamilyHead;
    joinPermit: MessageSignature;
    memberAddress: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  leaveFamilyOnBehalf: ({
    familyHead,
    memberAddress
  }: {
    familyHead: FamilyHead;
    memberAddress: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  kickFamilyMemberOnBehalf: ({
    headAddress,
    member
  }: {
    headAddress: string;
    member: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateRewardingValidatorAddress: ({
    address
  }: {
    address: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateContractStateParams: ({
    updatedParameters
  }: {
    updatedParameters: ContractStateParams;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateActiveSetSize: ({
    activeSetSize,
    forceImmediately
  }: {
    activeSetSize: number;
    forceImmediately: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateRewardingParams: ({
    forceImmediately,
    updatedParams
  }: {
    forceImmediately: boolean;
    updatedParams: IntervalRewardingParamsUpdate;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateIntervalConfig: ({
    epochDurationSecs,
    epochsInInterval,
    forceImmediately
  }: {
    epochDurationSecs: number;
    epochsInInterval: number;
    forceImmediately: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  beginEpochTransition: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  advanceCurrentEpoch: ({
    expectedActiveSetSize,
    newRewardedSet
  }: {
    expectedActiveSetSize: number;
    newRewardedSet: LayerAssignment[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  reconcileEpochEvents: ({
    limit
  }: {
    limit?: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  bondMixnode: ({
    costParams,
    mixNode,
    ownerSignature
  }: {
    costParams: MixNodeCostParams;
    mixNode: MixNode;
    ownerSignature: MessageSignature;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  bondMixnodeOnBehalf: ({
    costParams,
    mixNode,
    owner,
    ownerSignature
  }: {
    costParams: MixNodeCostParams;
    mixNode: MixNode;
    owner: string;
    ownerSignature: MessageSignature;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  pledgeMore: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  pledgeMoreOnBehalf: ({
    owner
  }: {
    owner: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  decreasePledge: ({
    decreaseBy
  }: {
    decreaseBy: Coin;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  decreasePledgeOnBehalf: ({
    decreaseBy,
    owner
  }: {
    decreaseBy: Coin;
    owner: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  unbondMixnode: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  unbondMixnodeOnBehalf: ({
    owner
  }: {
    owner: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateMixnodeCostParams: ({
    newCosts
  }: {
    newCosts: MixNodeCostParams;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateMixnodeCostParamsOnBehalf: ({
    newCosts,
    owner
  }: {
    newCosts: MixNodeCostParams;
    owner: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateMixnodeConfig: ({
    newConfig
  }: {
    newConfig: MixNodeConfigUpdate;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateMixnodeConfigOnBehalf: ({
    newConfig,
    owner
  }: {
    newConfig: MixNodeConfigUpdate;
    owner: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  bondGateway: ({
    gateway,
    ownerSignature
  }: {
    gateway: Gateway;
    ownerSignature: MessageSignature;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  bondGatewayOnBehalf: ({
    gateway,
    owner,
    ownerSignature
  }: {
    gateway: Gateway;
    owner: string;
    ownerSignature: MessageSignature;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  unbondGateway: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  unbondGatewayOnBehalf: ({
    owner
  }: {
    owner: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateGatewayConfig: ({
    newConfig
  }: {
    newConfig: GatewayConfigUpdate;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateGatewayConfigOnBehalf: ({
    newConfig,
    owner
  }: {
    newConfig: GatewayConfigUpdate;
    owner: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  delegateToMixnode: ({
    mixId
  }: {
    mixId: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  delegateToMixnodeOnBehalf: ({
    delegate,
    mixId
  }: {
    delegate: string;
    mixId: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  undelegateFromMixnode: ({
    mixId
  }: {
    mixId: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  undelegateFromMixnodeOnBehalf: ({
    delegate,
    mixId
  }: {
    delegate: string;
    mixId: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  rewardMixnode: ({
    mixId,
    performance
  }: {
    mixId: number;
    performance: Percent;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdrawOperatorReward: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdrawOperatorRewardOnBehalf: ({
    owner
  }: {
    owner: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdrawDelegatorReward: ({
    mixId
  }: {
    mixId: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdrawDelegatorRewardOnBehalf: ({
    mixId,
    owner
  }: {
    mixId: number;
    owner: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class MixnetClient extends MixnetQueryClient implements MixnetInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.assignNodeLayer = this.assignNodeLayer.bind(this);
    this.createFamily = this.createFamily.bind(this);
    this.joinFamily = this.joinFamily.bind(this);
    this.leaveFamily = this.leaveFamily.bind(this);
    this.kickFamilyMember = this.kickFamilyMember.bind(this);
    this.createFamilyOnBehalf = this.createFamilyOnBehalf.bind(this);
    this.joinFamilyOnBehalf = this.joinFamilyOnBehalf.bind(this);
    this.leaveFamilyOnBehalf = this.leaveFamilyOnBehalf.bind(this);
    this.kickFamilyMemberOnBehalf = this.kickFamilyMemberOnBehalf.bind(this);
    this.updateRewardingValidatorAddress = this.updateRewardingValidatorAddress.bind(this);
    this.updateContractStateParams = this.updateContractStateParams.bind(this);
    this.updateActiveSetSize = this.updateActiveSetSize.bind(this);
    this.updateRewardingParams = this.updateRewardingParams.bind(this);
    this.updateIntervalConfig = this.updateIntervalConfig.bind(this);
    this.beginEpochTransition = this.beginEpochTransition.bind(this);
    this.advanceCurrentEpoch = this.advanceCurrentEpoch.bind(this);
    this.reconcileEpochEvents = this.reconcileEpochEvents.bind(this);
    this.bondMixnode = this.bondMixnode.bind(this);
    this.bondMixnodeOnBehalf = this.bondMixnodeOnBehalf.bind(this);
    this.pledgeMore = this.pledgeMore.bind(this);
    this.pledgeMoreOnBehalf = this.pledgeMoreOnBehalf.bind(this);
    this.decreasePledge = this.decreasePledge.bind(this);
    this.decreasePledgeOnBehalf = this.decreasePledgeOnBehalf.bind(this);
    this.unbondMixnode = this.unbondMixnode.bind(this);
    this.unbondMixnodeOnBehalf = this.unbondMixnodeOnBehalf.bind(this);
    this.updateMixnodeCostParams = this.updateMixnodeCostParams.bind(this);
    this.updateMixnodeCostParamsOnBehalf = this.updateMixnodeCostParamsOnBehalf.bind(this);
    this.updateMixnodeConfig = this.updateMixnodeConfig.bind(this);
    this.updateMixnodeConfigOnBehalf = this.updateMixnodeConfigOnBehalf.bind(this);
    this.bondGateway = this.bondGateway.bind(this);
    this.bondGatewayOnBehalf = this.bondGatewayOnBehalf.bind(this);
    this.unbondGateway = this.unbondGateway.bind(this);
    this.unbondGatewayOnBehalf = this.unbondGatewayOnBehalf.bind(this);
    this.updateGatewayConfig = this.updateGatewayConfig.bind(this);
    this.updateGatewayConfigOnBehalf = this.updateGatewayConfigOnBehalf.bind(this);
    this.delegateToMixnode = this.delegateToMixnode.bind(this);
    this.delegateToMixnodeOnBehalf = this.delegateToMixnodeOnBehalf.bind(this);
    this.undelegateFromMixnode = this.undelegateFromMixnode.bind(this);
    this.undelegateFromMixnodeOnBehalf = this.undelegateFromMixnodeOnBehalf.bind(this);
    this.rewardMixnode = this.rewardMixnode.bind(this);
    this.withdrawOperatorReward = this.withdrawOperatorReward.bind(this);
    this.withdrawOperatorRewardOnBehalf = this.withdrawOperatorRewardOnBehalf.bind(this);
    this.withdrawDelegatorReward = this.withdrawDelegatorReward.bind(this);
    this.withdrawDelegatorRewardOnBehalf = this.withdrawDelegatorRewardOnBehalf.bind(this);
  }

  assignNodeLayer = async ({
    layer,
    mixId
  }: {
    layer: Layer;
    mixId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      assign_node_layer: {
        layer,
        mix_id: mixId
      }
    }, fee, memo, _funds);
  };
  createFamily = async ({
    label
  }: {
    label: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_family: {
        label
      }
    }, fee, memo, _funds);
  };
  joinFamily = async ({
    familyHead,
    joinPermit
  }: {
    familyHead: FamilyHead;
    joinPermit: MessageSignature;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      join_family: {
        family_head: familyHead,
        join_permit: joinPermit
      }
    }, fee, memo, _funds);
  };
  leaveFamily = async ({
    familyHead
  }: {
    familyHead: FamilyHead;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      leave_family: {
        family_head: familyHead
      }
    }, fee, memo, _funds);
  };
  kickFamilyMember = async ({
    member
  }: {
    member: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      kick_family_member: {
        member
      }
    }, fee, memo, _funds);
  };
  createFamilyOnBehalf = async ({
    label,
    ownerAddress
  }: {
    label: string;
    ownerAddress: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_family_on_behalf: {
        label,
        owner_address: ownerAddress
      }
    }, fee, memo, _funds);
  };
  joinFamilyOnBehalf = async ({
    familyHead,
    joinPermit,
    memberAddress
  }: {
    familyHead: FamilyHead;
    joinPermit: MessageSignature;
    memberAddress: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      join_family_on_behalf: {
        family_head: familyHead,
        join_permit: joinPermit,
        member_address: memberAddress
      }
    }, fee, memo, _funds);
  };
  leaveFamilyOnBehalf = async ({
    familyHead,
    memberAddress
  }: {
    familyHead: FamilyHead;
    memberAddress: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      leave_family_on_behalf: {
        family_head: familyHead,
        member_address: memberAddress
      }
    }, fee, memo, _funds);
  };
  kickFamilyMemberOnBehalf = async ({
    headAddress,
    member
  }: {
    headAddress: string;
    member: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      kick_family_member_on_behalf: {
        head_address: headAddress,
        member
      }
    }, fee, memo, _funds);
  };
  updateRewardingValidatorAddress = async ({
    address
  }: {
    address: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_rewarding_validator_address: {
        address
      }
    }, fee, memo, _funds);
  };
  updateContractStateParams = async ({
    updatedParameters
  }: {
    updatedParameters: ContractStateParams;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_contract_state_params: {
        updated_parameters: updatedParameters
      }
    }, fee, memo, _funds);
  };
  updateActiveSetSize = async ({
    activeSetSize,
    forceImmediately
  }: {
    activeSetSize: number;
    forceImmediately: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_active_set_size: {
        active_set_size: activeSetSize,
        force_immediately: forceImmediately
      }
    }, fee, memo, _funds);
  };
  updateRewardingParams = async ({
    forceImmediately,
    updatedParams
  }: {
    forceImmediately: boolean;
    updatedParams: IntervalRewardingParamsUpdate;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_rewarding_params: {
        force_immediately: forceImmediately,
        updated_params: updatedParams
      }
    }, fee, memo, _funds);
  };
  updateIntervalConfig = async ({
    epochDurationSecs,
    epochsInInterval,
    forceImmediately
  }: {
    epochDurationSecs: number;
    epochsInInterval: number;
    forceImmediately: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_interval_config: {
        epoch_duration_secs: epochDurationSecs,
        epochs_in_interval: epochsInInterval,
        force_immediately: forceImmediately
      }
    }, fee, memo, _funds);
  };
  beginEpochTransition = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      begin_epoch_transition: {}
    }, fee, memo, _funds);
  };
  advanceCurrentEpoch = async ({
    expectedActiveSetSize,
    newRewardedSet
  }: {
    expectedActiveSetSize: number;
    newRewardedSet: LayerAssignment[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      advance_current_epoch: {
        expected_active_set_size: expectedActiveSetSize,
        new_rewarded_set: newRewardedSet
      }
    }, fee, memo, _funds);
  };
  reconcileEpochEvents = async ({
    limit
  }: {
    limit?: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      reconcile_epoch_events: {
        limit
      }
    }, fee, memo, _funds);
  };
  bondMixnode = async ({
    costParams,
    mixNode,
    ownerSignature
  }: {
    costParams: MixNodeCostParams;
    mixNode: MixNode;
    ownerSignature: MessageSignature;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      bond_mixnode: {
        cost_params: costParams,
        mix_node: mixNode,
        owner_signature: ownerSignature
      }
    }, fee, memo, _funds);
  };
  bondMixnodeOnBehalf = async ({
    costParams,
    mixNode,
    owner,
    ownerSignature
  }: {
    costParams: MixNodeCostParams;
    mixNode: MixNode;
    owner: string;
    ownerSignature: MessageSignature;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      bond_mixnode_on_behalf: {
        cost_params: costParams,
        mix_node: mixNode,
        owner,
        owner_signature: ownerSignature
      }
    }, fee, memo, _funds);
  };
  pledgeMore = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      pledge_more: {}
    }, fee, memo, _funds);
  };
  pledgeMoreOnBehalf = async ({
    owner
  }: {
    owner: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      pledge_more_on_behalf: {
        owner
      }
    }, fee, memo, _funds);
  };
  decreasePledge = async ({
    decreaseBy
  }: {
    decreaseBy: Coin;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      decrease_pledge: {
        decrease_by: decreaseBy
      }
    }, fee, memo, _funds);
  };
  decreasePledgeOnBehalf = async ({
    decreaseBy,
    owner
  }: {
    decreaseBy: Coin;
    owner: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      decrease_pledge_on_behalf: {
        decrease_by: decreaseBy,
        owner
      }
    }, fee, memo, _funds);
  };
  unbondMixnode = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unbond_mixnode: {}
    }, fee, memo, _funds);
  };
  unbondMixnodeOnBehalf = async ({
    owner
  }: {
    owner: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unbond_mixnode_on_behalf: {
        owner
      }
    }, fee, memo, _funds);
  };
  updateMixnodeCostParams = async ({
    newCosts
  }: {
    newCosts: MixNodeCostParams;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_mixnode_cost_params: {
        new_costs: newCosts
      }
    }, fee, memo, _funds);
  };
  updateMixnodeCostParamsOnBehalf = async ({
    newCosts,
    owner
  }: {
    newCosts: MixNodeCostParams;
    owner: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_mixnode_cost_params_on_behalf: {
        new_costs: newCosts,
        owner
      }
    }, fee, memo, _funds);
  };
  updateMixnodeConfig = async ({
    newConfig
  }: {
    newConfig: MixNodeConfigUpdate;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_mixnode_config: {
        new_config: newConfig
      }
    }, fee, memo, _funds);
  };
  updateMixnodeConfigOnBehalf = async ({
    newConfig,
    owner
  }: {
    newConfig: MixNodeConfigUpdate;
    owner: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_mixnode_config_on_behalf: {
        new_config: newConfig,
        owner
      }
    }, fee, memo, _funds);
  };
  bondGateway = async ({
    gateway,
    ownerSignature
  }: {
    gateway: Gateway;
    ownerSignature: MessageSignature;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      bond_gateway: {
        gateway,
        owner_signature: ownerSignature
      }
    }, fee, memo, _funds);
  };
  bondGatewayOnBehalf = async ({
    gateway,
    owner,
    ownerSignature
  }: {
    gateway: Gateway;
    owner: string;
    ownerSignature: MessageSignature;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      bond_gateway_on_behalf: {
        gateway,
        owner,
        owner_signature: ownerSignature
      }
    }, fee, memo, _funds);
  };
  unbondGateway = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unbond_gateway: {}
    }, fee, memo, _funds);
  };
  unbondGatewayOnBehalf = async ({
    owner
  }: {
    owner: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unbond_gateway_on_behalf: {
        owner
      }
    }, fee, memo, _funds);
  };
  updateGatewayConfig = async ({
    newConfig
  }: {
    newConfig: GatewayConfigUpdate;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_gateway_config: {
        new_config: newConfig
      }
    }, fee, memo, _funds);
  };
  updateGatewayConfigOnBehalf = async ({
    newConfig,
    owner
  }: {
    newConfig: GatewayConfigUpdate;
    owner: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_gateway_config_on_behalf: {
        new_config: newConfig,
        owner
      }
    }, fee, memo, _funds);
  };
  delegateToMixnode = async ({
    mixId
  }: {
    mixId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      delegate_to_mixnode: {
        mix_id: mixId
      }
    }, fee, memo, _funds);
  };
  delegateToMixnodeOnBehalf = async ({
    delegate,
    mixId
  }: {
    delegate: string;
    mixId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      delegate_to_mixnode_on_behalf: {
        delegate,
        mix_id: mixId
      }
    }, fee, memo, _funds);
  };
  undelegateFromMixnode = async ({
    mixId
  }: {
    mixId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      undelegate_from_mixnode: {
        mix_id: mixId
      }
    }, fee, memo, _funds);
  };
  undelegateFromMixnodeOnBehalf = async ({
    delegate,
    mixId
  }: {
    delegate: string;
    mixId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      undelegate_from_mixnode_on_behalf: {
        delegate,
        mix_id: mixId
      }
    }, fee, memo, _funds);
  };
  rewardMixnode = async ({
    mixId,
    performance
  }: {
    mixId: number;
    performance: Percent;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      reward_mixnode: {
        mix_id: mixId,
        performance
      }
    }, fee, memo, _funds);
  };
  withdrawOperatorReward = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_operator_reward: {}
    }, fee, memo, _funds);
  };
  withdrawOperatorRewardOnBehalf = async ({
    owner
  }: {
    owner: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_operator_reward_on_behalf: {
        owner
      }
    }, fee, memo, _funds);
  };
  withdrawDelegatorReward = async ({
    mixId
  }: {
    mixId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_delegator_reward: {
        mix_id: mixId
      }
    }, fee, memo, _funds);
  };
  withdrawDelegatorRewardOnBehalf = async ({
    mixId,
    owner
  }: {
    mixId: number;
    owner: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_delegator_reward_on_behalf: {
        mix_id: mixId,
        owner
      }
    }, fee, memo, _funds);
  };
}
