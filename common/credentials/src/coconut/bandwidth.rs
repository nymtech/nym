// Copyright 2021 - Nym Technologies SA <contact@nymtech.net>
// SPDX-License-Identifier: Apache-2.0

// for time being assume the bandwidth credential consists of public identity of the requester
// and private (though known... just go along with it) infinite bandwidth value
// right now this has no double-spending protection, spender binding, etc
// it's the simplest possible case

use coconut_interface::{
    BlindSignRequest, Credential, Parameters, PrivateAttribute, PublicAttribute, Signature,
    VerificationKey,
};
use crypto::asymmetric::identity::PrivateKey;
use network_defaults::BANDWIDTH_VALUE;

use crate::error::Error;

use super::utils::prepare_credential_for_spending;

pub const PUBLIC_ATTRIBUTES: u32 = 2;
pub const PRIVATE_ATTRIBUTES: u32 = 2;
pub const TOTAL_ATTRIBUTES: u32 = PUBLIC_ATTRIBUTES + PRIVATE_ATTRIBUTES;

pub struct BandwidthVoucher {
    // a random secret value generated by the client used for double-spending detection
    serial_number: PrivateAttribute,
    // a random secret value generated by the client used to bind multiple credentials together
    binding_number: PrivateAttribute,
    // the value (e.g., bandwidth) encoded in this voucher
    voucher_value: PublicAttribute,
    // a field with public information, e.g., type of voucher, interval etc.
    voucher_info: PublicAttribute,
    // the hash of the deposit transaction
    tx_hash: String,
    // base58 encoded key ensuring the depositer requested these attributes
    signing_key: String,
}

impl BandwidthVoucher {
    pub fn new(
        serial_number: PrivateAttribute,
        binding_number: PrivateAttribute,
        voucher_value: PublicAttribute,
        voucher_info: PublicAttribute,
        tx_hash: String,
        signing_key: String,
    ) -> Self {
        BandwidthVoucher {
            serial_number,
            binding_number,
            voucher_value,
            voucher_info,
            tx_hash,
            signing_key,
        }
    }

    pub fn tx_hash(&self) -> &str {
        &self.tx_hash
    }

    pub fn get_public_attributes(&self) -> Vec<PublicAttribute> {
        vec![self.voucher_value, self.voucher_info]
    }

    pub fn get_private_attributes(&self) -> Vec<PrivateAttribute> {
        vec![self.serial_number, self.binding_number]
    }

    pub fn sign(&self, request: &BlindSignRequest) -> String {
        let private_key = PrivateKey::from_base58_string(&self.signing_key).unwrap();
        let mut message = request.to_bytes();
        message.extend_from_slice(self.tx_hash.as_bytes());
        private_key.sign(&message).to_base58_string()
    }
}

pub fn prepare_for_spending(
    raw_identity: &[u8],
    signature: &Signature,
    attributes: &BandwidthVoucher,
    verification_key: &VerificationKey,
) -> Result<Credential, Error> {
    let public_attributes = vec![
        raw_identity.to_vec(),
        BANDWIDTH_VALUE.to_be_bytes().to_vec(),
    ];

    let params = Parameters::new(TOTAL_ATTRIBUTES)?;

    prepare_credential_for_spending(
        &params,
        public_attributes,
        attributes.serial_number,
        attributes.binding_number,
        signature,
        verification_key,
    )
}
