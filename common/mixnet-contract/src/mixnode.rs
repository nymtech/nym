// due to code generated by JsonSchema
#![allow(clippy::field_reassign_with_default)]

use crate::{IdentityKey, SphinxKey};
use cosmwasm_std::{Coin, HumanAddr};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use std::fmt::Display;
use std::io;
use std::net::{SocketAddr, ToSocketAddrs};

#[derive(Clone, Debug, Deserialize, PartialEq, Serialize, JsonSchema)]
pub struct MixNode {
    pub host: String,
    pub layer: u64,
    pub location: String,
    pub sphinx_key: SphinxKey,
    /// Base58 encoded ed25519 EdDSA public key.
    pub identity_key: IdentityKey,
    pub version: String,
}

impl MixNode {
    pub fn new(
        host: String,
        layer: u64,
        location: String,
        sphinx_key: SphinxKey,
        identity_key: IdentityKey,
        version: String,
    ) -> Self {
        MixNode {
            host,
            layer,
            location,
            sphinx_key,
            identity_key,
            version,
        }
    }

    pub fn try_resolve_hostname(&self) -> Result<SocketAddr, io::Error> {
        self.host
            .to_socket_addrs()?
            .next()
            .ok_or_else(|| io::Error::new(io::ErrorKind::Other, "no valid socket address"))
    }
}

/*
By the way, I've also been thinking of some potential changes in the contract we could introduce once we have to make an incompatible upgrade (say to cosmwasm 0.14+). Is there some place I could write them down so that we would not forget about them? Should I make a GitHub issue, a google doc or maybe put it on GitLab?

 */

#[derive(Clone, Debug, Deserialize, PartialEq, Serialize, JsonSchema)]
pub struct MixNodeBond {
    // TODO:
    // JS: When we go onto the next testnet and we have to make incompatible changes in the contract (such as upgrade to cosmwasm 0.14+)
    // I'd change `amount` from `Vec<Coin>` to just `Coin` (or maybe even `Uint128` since denomination is implicit)
    // I would also put here field like `total_delegation` which would also be a `Coin` or `Uint128` that
    // indicates the sum of all delegations towards this node
    //
    // I would also modify the `MixNode` struct:
    //  - remove `location` field
    //  - repurpose `host` field to hold either ip or hostname (WITHOUT port information)
    //  - introduce `mix_port` field
    //  - introduce `rest_api_port` field
    //  - [POTENTIALLY] introduce `verloc_port` field or keep it accessible via http api
    //
    // I would also introduce the identical changes to GatewayBond
    pub amount: Vec<Coin>,
    pub owner: HumanAddr,
    pub mix_node: MixNode,
}

impl MixNodeBond {
    pub fn new(amount: Vec<Coin>, owner: HumanAddr, mix_node: MixNode) -> Self {
        MixNodeBond {
            amount,
            owner,
            mix_node,
        }
    }

    pub fn identity(&self) -> &String {
        &self.mix_node.identity_key
    }

    pub fn amount(&self) -> &[Coin] {
        &self.amount
    }

    pub fn owner(&self) -> &HumanAddr {
        &self.owner
    }

    pub fn mix_node(&self) -> &MixNode {
        &self.mix_node
    }
}

impl Display for MixNodeBond {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        // Write strictly the first element into the supplied output
        // stream: `f`. Returns `fmt::Result` which indicates whether the
        // operation succeeded or failed. Note that `write!` uses syntax which
        // is very similar to `println!`.
        if self.amount.len() != 1 {
            write!(f, "amount: {:?}, owner: {}", self.amount, self.owner)
        } else {
            write!(
                f,
                "amount: {} {}, owner: {}",
                self.amount[0].amount, self.amount[0].denom, self.owner
            )
        }
    }
}

#[derive(Clone, Debug, Deserialize, PartialEq, Serialize, JsonSchema)]
pub struct PagedResponse {
    pub nodes: Vec<MixNodeBond>,
    pub per_page: usize,
    pub start_next_after: Option<String>,
}

impl PagedResponse {
    pub fn new(nodes: Vec<MixNodeBond>, per_page: usize, start_next_after: Option<String>) -> Self {
        PagedResponse {
            nodes,
            per_page,
            start_next_after,
        }
    }
}

#[derive(Clone, Debug, Deserialize, PartialEq, Serialize, JsonSchema)]
pub struct MixOwnershipResponse {
    pub address: HumanAddr,
    pub has_node: bool,
}
