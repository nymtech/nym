{
  "contract_name": "nym-mixnet-contract",
  "contract_version": "1.4.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "type": "object",
    "required": [
      "epoch_duration",
      "epochs_in_interval",
      "initial_rewarding_params",
      "rewarding_denom",
      "rewarding_validator_address",
      "vesting_contract_address"
    ],
    "properties": {
      "epoch_duration": {
        "$ref": "#/definitions/Duration"
      },
      "epochs_in_interval": {
        "type": "integer",
        "format": "uint32",
        "minimum": 0.0
      },
      "initial_rewarding_params": {
        "$ref": "#/definitions/InitialRewardingParams"
      },
      "rewarding_denom": {
        "type": "string"
      },
      "rewarding_validator_address": {
        "type": "string"
      },
      "vesting_contract_address": {
        "type": "string"
      }
    },
    "additionalProperties": false,
    "definitions": {
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "Duration": {
        "type": "object",
        "required": [
          "nanos",
          "secs"
        ],
        "properties": {
          "nanos": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0.0
          },
          "secs": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          }
        }
      },
      "InitialRewardingParams": {
        "type": "object",
        "required": [
          "active_set_size",
          "active_set_work_factor",
          "initial_reward_pool",
          "initial_staking_supply",
          "interval_pool_emission",
          "rewarded_set_size",
          "staking_supply_scale_factor",
          "sybil_resistance"
        ],
        "properties": {
          "active_set_size": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0.0
          },
          "active_set_work_factor": {
            "$ref": "#/definitions/Decimal"
          },
          "initial_reward_pool": {
            "$ref": "#/definitions/Decimal"
          },
          "initial_staking_supply": {
            "$ref": "#/definitions/Decimal"
          },
          "interval_pool_emission": {
            "$ref": "#/definitions/Percent"
          },
          "rewarded_set_size": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0.0
          },
          "staking_supply_scale_factor": {
            "$ref": "#/definitions/Percent"
          },
          "sybil_resistance": {
            "$ref": "#/definitions/Percent"
          }
        },
        "additionalProperties": false
      },
      "Percent": {
        "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
        "allOf": [
          {
            "$ref": "#/definitions/Decimal"
          }
        ]
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "assign_node_layer"
        ],
        "properties": {
          "assign_node_layer": {
            "type": "object",
            "required": [
              "layer",
              "mix_id"
            ],
            "properties": {
              "layer": {
                "$ref": "#/definitions/Layer"
              },
              "mix_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Only owner of the node can crate the family with node as head",
        "type": "object",
        "required": [
          "create_family"
        ],
        "properties": {
          "create_family": {
            "type": "object",
            "required": [
              "label"
            ],
            "properties": {
              "label": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Family head needs to sign the joining node IdentityKey",
        "type": "object",
        "required": [
          "join_family"
        ],
        "properties": {
          "join_family": {
            "type": "object",
            "required": [
              "family_head",
              "join_permit"
            ],
            "properties": {
              "family_head": {
                "$ref": "#/definitions/FamilyHead"
              },
              "join_permit": {
                "$ref": "#/definitions/MessageSignature"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "leave_family"
        ],
        "properties": {
          "leave_family": {
            "type": "object",
            "required": [
              "family_head"
            ],
            "properties": {
              "family_head": {
                "$ref": "#/definitions/FamilyHead"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "kick_family_member"
        ],
        "properties": {
          "kick_family_member": {
            "type": "object",
            "required": [
              "member"
            ],
            "properties": {
              "member": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "create_family_on_behalf"
        ],
        "properties": {
          "create_family_on_behalf": {
            "type": "object",
            "required": [
              "label",
              "owner_address"
            ],
            "properties": {
              "label": {
                "type": "string"
              },
              "owner_address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Family head needs to sign the joining node IdentityKey, MixNode needs to provide its signature proving that it wants to join the family",
        "type": "object",
        "required": [
          "join_family_on_behalf"
        ],
        "properties": {
          "join_family_on_behalf": {
            "type": "object",
            "required": [
              "family_head",
              "join_permit",
              "member_address"
            ],
            "properties": {
              "family_head": {
                "$ref": "#/definitions/FamilyHead"
              },
              "join_permit": {
                "$ref": "#/definitions/MessageSignature"
              },
              "member_address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "leave_family_on_behalf"
        ],
        "properties": {
          "leave_family_on_behalf": {
            "type": "object",
            "required": [
              "family_head",
              "member_address"
            ],
            "properties": {
              "family_head": {
                "$ref": "#/definitions/FamilyHead"
              },
              "member_address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "kick_family_member_on_behalf"
        ],
        "properties": {
          "kick_family_member_on_behalf": {
            "type": "object",
            "required": [
              "head_address",
              "member"
            ],
            "properties": {
              "head_address": {
                "type": "string"
              },
              "member": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_rewarding_validator_address"
        ],
        "properties": {
          "update_rewarding_validator_address": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_contract_state_params"
        ],
        "properties": {
          "update_contract_state_params": {
            "type": "object",
            "required": [
              "updated_parameters"
            ],
            "properties": {
              "updated_parameters": {
                "$ref": "#/definitions/ContractStateParams"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_active_set_size"
        ],
        "properties": {
          "update_active_set_size": {
            "type": "object",
            "required": [
              "active_set_size",
              "force_immediately"
            ],
            "properties": {
              "active_set_size": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              "force_immediately": {
                "type": "boolean"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_rewarding_params"
        ],
        "properties": {
          "update_rewarding_params": {
            "type": "object",
            "required": [
              "force_immediately",
              "updated_params"
            ],
            "properties": {
              "force_immediately": {
                "type": "boolean"
              },
              "updated_params": {
                "$ref": "#/definitions/IntervalRewardingParamsUpdate"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_interval_config"
        ],
        "properties": {
          "update_interval_config": {
            "type": "object",
            "required": [
              "epoch_duration_secs",
              "epochs_in_interval",
              "force_immediately"
            ],
            "properties": {
              "epoch_duration_secs": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              },
              "epochs_in_interval": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              "force_immediately": {
                "type": "boolean"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "begin_epoch_transition"
        ],
        "properties": {
          "begin_epoch_transition": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "advance_current_epoch"
        ],
        "properties": {
          "advance_current_epoch": {
            "type": "object",
            "required": [
              "expected_active_set_size",
              "new_rewarded_set"
            ],
            "properties": {
              "expected_active_set_size": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              "new_rewarded_set": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/LayerAssignment"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "reconcile_epoch_events"
        ],
        "properties": {
          "reconcile_epoch_events": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "bond_mixnode"
        ],
        "properties": {
          "bond_mixnode": {
            "type": "object",
            "required": [
              "cost_params",
              "mix_node",
              "owner_signature"
            ],
            "properties": {
              "cost_params": {
                "$ref": "#/definitions/MixNodeCostParams"
              },
              "mix_node": {
                "$ref": "#/definitions/MixNode"
              },
              "owner_signature": {
                "$ref": "#/definitions/MessageSignature"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "bond_mixnode_on_behalf"
        ],
        "properties": {
          "bond_mixnode_on_behalf": {
            "type": "object",
            "required": [
              "cost_params",
              "mix_node",
              "owner",
              "owner_signature"
            ],
            "properties": {
              "cost_params": {
                "$ref": "#/definitions/MixNodeCostParams"
              },
              "mix_node": {
                "$ref": "#/definitions/MixNode"
              },
              "owner": {
                "type": "string"
              },
              "owner_signature": {
                "$ref": "#/definitions/MessageSignature"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "pledge_more"
        ],
        "properties": {
          "pledge_more": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "pledge_more_on_behalf"
        ],
        "properties": {
          "pledge_more_on_behalf": {
            "type": "object",
            "required": [
              "owner"
            ],
            "properties": {
              "owner": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "decrease_pledge"
        ],
        "properties": {
          "decrease_pledge": {
            "type": "object",
            "required": [
              "decrease_by"
            ],
            "properties": {
              "decrease_by": {
                "$ref": "#/definitions/Coin"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "decrease_pledge_on_behalf"
        ],
        "properties": {
          "decrease_pledge_on_behalf": {
            "type": "object",
            "required": [
              "decrease_by",
              "owner"
            ],
            "properties": {
              "decrease_by": {
                "$ref": "#/definitions/Coin"
              },
              "owner": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "unbond_mixnode"
        ],
        "properties": {
          "unbond_mixnode": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "unbond_mixnode_on_behalf"
        ],
        "properties": {
          "unbond_mixnode_on_behalf": {
            "type": "object",
            "required": [
              "owner"
            ],
            "properties": {
              "owner": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_mixnode_cost_params"
        ],
        "properties": {
          "update_mixnode_cost_params": {
            "type": "object",
            "required": [
              "new_costs"
            ],
            "properties": {
              "new_costs": {
                "$ref": "#/definitions/MixNodeCostParams"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_mixnode_cost_params_on_behalf"
        ],
        "properties": {
          "update_mixnode_cost_params_on_behalf": {
            "type": "object",
            "required": [
              "new_costs",
              "owner"
            ],
            "properties": {
              "new_costs": {
                "$ref": "#/definitions/MixNodeCostParams"
              },
              "owner": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_mixnode_config"
        ],
        "properties": {
          "update_mixnode_config": {
            "type": "object",
            "required": [
              "new_config"
            ],
            "properties": {
              "new_config": {
                "$ref": "#/definitions/MixNodeConfigUpdate"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_mixnode_config_on_behalf"
        ],
        "properties": {
          "update_mixnode_config_on_behalf": {
            "type": "object",
            "required": [
              "new_config",
              "owner"
            ],
            "properties": {
              "new_config": {
                "$ref": "#/definitions/MixNodeConfigUpdate"
              },
              "owner": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "bond_gateway"
        ],
        "properties": {
          "bond_gateway": {
            "type": "object",
            "required": [
              "gateway",
              "owner_signature"
            ],
            "properties": {
              "gateway": {
                "$ref": "#/definitions/Gateway"
              },
              "owner_signature": {
                "$ref": "#/definitions/MessageSignature"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "bond_gateway_on_behalf"
        ],
        "properties": {
          "bond_gateway_on_behalf": {
            "type": "object",
            "required": [
              "gateway",
              "owner",
              "owner_signature"
            ],
            "properties": {
              "gateway": {
                "$ref": "#/definitions/Gateway"
              },
              "owner": {
                "type": "string"
              },
              "owner_signature": {
                "$ref": "#/definitions/MessageSignature"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "unbond_gateway"
        ],
        "properties": {
          "unbond_gateway": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "unbond_gateway_on_behalf"
        ],
        "properties": {
          "unbond_gateway_on_behalf": {
            "type": "object",
            "required": [
              "owner"
            ],
            "properties": {
              "owner": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_gateway_config"
        ],
        "properties": {
          "update_gateway_config": {
            "type": "object",
            "required": [
              "new_config"
            ],
            "properties": {
              "new_config": {
                "$ref": "#/definitions/GatewayConfigUpdate"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_gateway_config_on_behalf"
        ],
        "properties": {
          "update_gateway_config_on_behalf": {
            "type": "object",
            "required": [
              "new_config",
              "owner"
            ],
            "properties": {
              "new_config": {
                "$ref": "#/definitions/GatewayConfigUpdate"
              },
              "owner": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "delegate_to_mixnode"
        ],
        "properties": {
          "delegate_to_mixnode": {
            "type": "object",
            "required": [
              "mix_id"
            ],
            "properties": {
              "mix_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "delegate_to_mixnode_on_behalf"
        ],
        "properties": {
          "delegate_to_mixnode_on_behalf": {
            "type": "object",
            "required": [
              "delegate",
              "mix_id"
            ],
            "properties": {
              "delegate": {
                "type": "string"
              },
              "mix_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "undelegate_from_mixnode"
        ],
        "properties": {
          "undelegate_from_mixnode": {
            "type": "object",
            "required": [
              "mix_id"
            ],
            "properties": {
              "mix_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "undelegate_from_mixnode_on_behalf"
        ],
        "properties": {
          "undelegate_from_mixnode_on_behalf": {
            "type": "object",
            "required": [
              "delegate",
              "mix_id"
            ],
            "properties": {
              "delegate": {
                "type": "string"
              },
              "mix_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "reward_mixnode"
        ],
        "properties": {
          "reward_mixnode": {
            "type": "object",
            "required": [
              "mix_id",
              "performance"
            ],
            "properties": {
              "mix_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              "performance": {
                "$ref": "#/definitions/Percent"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "withdraw_operator_reward"
        ],
        "properties": {
          "withdraw_operator_reward": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "withdraw_operator_reward_on_behalf"
        ],
        "properties": {
          "withdraw_operator_reward_on_behalf": {
            "type": "object",
            "required": [
              "owner"
            ],
            "properties": {
              "owner": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "withdraw_delegator_reward"
        ],
        "properties": {
          "withdraw_delegator_reward": {
            "type": "object",
            "required": [
              "mix_id"
            ],
            "properties": {
              "mix_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "withdraw_delegator_reward_on_behalf"
        ],
        "properties": {
          "withdraw_delegator_reward_on_behalf": {
            "type": "object",
            "required": [
              "mix_id",
              "owner"
            ],
            "properties": {
              "mix_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              "owner": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "ContractStateParams": {
        "type": "object",
        "required": [
          "minimum_gateway_pledge",
          "minimum_mixnode_pledge"
        ],
        "properties": {
          "minimum_gateway_pledge": {
            "description": "Minimum amount a gateway must pledge to get into the system.",
            "allOf": [
              {
                "$ref": "#/definitions/Coin"
              }
            ]
          },
          "minimum_mixnode_delegation": {
            "description": "Minimum amount a delegator must stake in orders for his delegation to get accepted.",
            "anyOf": [
              {
                "$ref": "#/definitions/Coin"
              },
              {
                "type": "null"
              }
            ]
          },
          "minimum_mixnode_pledge": {
            "description": "Minimum amount a mixnode must pledge to get into the system.",
            "allOf": [
              {
                "$ref": "#/definitions/Coin"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "FamilyHead": {
        "type": "string"
      },
      "Gateway": {
        "type": "object",
        "required": [
          "clients_port",
          "host",
          "identity_key",
          "location",
          "mix_port",
          "sphinx_key",
          "version"
        ],
        "properties": {
          "clients_port": {
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "host": {
            "type": "string"
          },
          "identity_key": {
            "description": "Base58 encoded ed25519 EdDSA public key of the gateway used to derive shared keys with clients",
            "type": "string"
          },
          "location": {
            "type": "string"
          },
          "mix_port": {
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "sphinx_key": {
            "type": "string"
          },
          "version": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "GatewayConfigUpdate": {
        "type": "object",
        "required": [
          "clients_port",
          "host",
          "location",
          "mix_port",
          "version"
        ],
        "properties": {
          "clients_port": {
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "host": {
            "type": "string"
          },
          "location": {
            "type": "string"
          },
          "mix_port": {
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "version": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "IntervalRewardingParamsUpdate": {
        "type": "object",
        "properties": {
          "active_set_work_factor": {
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "interval_pool_emission": {
            "anyOf": [
              {
                "$ref": "#/definitions/Percent"
              },
              {
                "type": "null"
              }
            ]
          },
          "reward_pool": {
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "rewarded_set_size": {
            "type": [
              "integer",
              "null"
            ],
            "format": "uint32",
            "minimum": 0.0
          },
          "staking_supply": {
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "staking_supply_scale_factor": {
            "anyOf": [
              {
                "$ref": "#/definitions/Percent"
              },
              {
                "type": "null"
              }
            ]
          },
          "sybil_resistance_percent": {
            "anyOf": [
              {
                "$ref": "#/definitions/Percent"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "Layer": {
        "type": "string",
        "enum": [
          "One",
          "Two",
          "Three"
        ]
      },
      "LayerAssignment": {
        "type": "object",
        "required": [
          "layer",
          "mix_id"
        ],
        "properties": {
          "layer": {
            "$ref": "#/definitions/Layer"
          },
          "mix_id": {
            "type": "integer",
            "format": "uint32",
            "minimum": 0.0
          }
        },
        "additionalProperties": false
      },
      "MessageSignature": {
        "type": "array",
        "items": {
          "type": "integer",
          "format": "uint8",
          "minimum": 0.0
        }
      },
      "MixNode": {
        "type": "object",
        "required": [
          "host",
          "http_api_port",
          "identity_key",
          "mix_port",
          "sphinx_key",
          "verloc_port",
          "version"
        ],
        "properties": {
          "host": {
            "description": "Network address of this mixnode, for example 1.1.1.1:1234 or foo.mixnode.com",
            "type": "string"
          },
          "http_api_port": {
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "identity_key": {
            "description": "Base58-encoded ed25519 EdDSA public key.",
            "type": "string"
          },
          "mix_port": {
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "sphinx_key": {
            "description": "Base58-encoded x25519 public key used for sphinx key derivation.",
            "type": "string"
          },
          "verloc_port": {
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "version": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "MixNodeConfigUpdate": {
        "type": "object",
        "required": [
          "host",
          "http_api_port",
          "mix_port",
          "verloc_port",
          "version"
        ],
        "properties": {
          "host": {
            "type": "string"
          },
          "http_api_port": {
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "mix_port": {
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "verloc_port": {
            "type": "integer",
            "format": "uint16",
            "minimum": 0.0
          },
          "version": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "MixNodeCostParams": {
        "type": "object",
        "required": [
          "interval_operating_cost",
          "profit_margin_percent"
        ],
        "properties": {
          "interval_operating_cost": {
            "description": "Operating cost of the associated mixnode per the entire interval.",
            "allOf": [
              {
                "$ref": "#/definitions/Coin"
              }
            ]
          },
          "profit_margin_percent": {
            "$ref": "#/definitions/Percent"
          }
        },
        "additionalProperties": false
      },
      "Percent": {
        "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
        "allOf": [
          {
            "$ref": "#/definitions/Decimal"
          }
        ]
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "get_all_families_paged"
        ],
        "properties": {
          "get_all_families_paged": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_all_members_paged"
        ],
        "properties": {
          "get_all_members_paged": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_family_by_head"
        ],
        "properties": {
          "get_family_by_head": {
            "type": "object",
            "required": [
              "head"
            ],
            "properties": {
              "head": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_family_by_label"
        ],
        "properties": {
          "get_family_by_label": {
            "type": "object",
            "required": [
              "label"
            ],
            "properties": {
              "label": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_family_members_by_head"
        ],
        "properties": {
          "get_family_members_by_head": {
            "type": "object",
            "required": [
              "head"
            ],
            "properties": {
              "head": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_family_members_by_label"
        ],
        "properties": {
          "get_family_members_by_label": {
            "type": "object",
            "required": [
              "label"
            ],
            "properties": {
              "label": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_contract_version"
        ],
        "properties": {
          "get_contract_version": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_cw2_contract_version"
        ],
        "properties": {
          "get_cw2_contract_version": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_rewarding_validator_address"
        ],
        "properties": {
          "get_rewarding_validator_address": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_state_params"
        ],
        "properties": {
          "get_state_params": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_state"
        ],
        "properties": {
          "get_state": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_rewarding_params"
        ],
        "properties": {
          "get_rewarding_params": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_epoch_status"
        ],
        "properties": {
          "get_epoch_status": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_current_interval_details"
        ],
        "properties": {
          "get_current_interval_details": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_rewarded_set"
        ],
        "properties": {
          "get_rewarded_set": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_mix_node_bonds"
        ],
        "properties": {
          "get_mix_node_bonds": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_mix_nodes_detailed"
        ],
        "properties": {
          "get_mix_nodes_detailed": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_unbonded_mix_nodes"
        ],
        "properties": {
          "get_unbonded_mix_nodes": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_unbonded_mix_nodes_by_owner"
        ],
        "properties": {
          "get_unbonded_mix_nodes_by_owner": {
            "type": "object",
            "required": [
              "owner"
            ],
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "owner": {
                "type": "string"
              },
              "start_after": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_unbonded_mix_nodes_by_identity_key"
        ],
        "properties": {
          "get_unbonded_mix_nodes_by_identity_key": {
            "type": "object",
            "required": [
              "identity_key"
            ],
            "properties": {
              "identity_key": {
                "type": "string"
              },
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_owned_mixnode"
        ],
        "properties": {
          "get_owned_mixnode": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_mixnode_details"
        ],
        "properties": {
          "get_mixnode_details": {
            "type": "object",
            "required": [
              "mix_id"
            ],
            "properties": {
              "mix_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_mixnode_rewarding_details"
        ],
        "properties": {
          "get_mixnode_rewarding_details": {
            "type": "object",
            "required": [
              "mix_id"
            ],
            "properties": {
              "mix_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_stake_saturation"
        ],
        "properties": {
          "get_stake_saturation": {
            "type": "object",
            "required": [
              "mix_id"
            ],
            "properties": {
              "mix_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_unbonded_mix_node_information"
        ],
        "properties": {
          "get_unbonded_mix_node_information": {
            "type": "object",
            "required": [
              "mix_id"
            ],
            "properties": {
              "mix_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_bonded_mixnode_details_by_identity"
        ],
        "properties": {
          "get_bonded_mixnode_details_by_identity": {
            "type": "object",
            "required": [
              "mix_identity"
            ],
            "properties": {
              "mix_identity": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_layer_distribution"
        ],
        "properties": {
          "get_layer_distribution": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_gateways"
        ],
        "properties": {
          "get_gateways": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_gateway_bond"
        ],
        "properties": {
          "get_gateway_bond": {
            "type": "object",
            "required": [
              "identity"
            ],
            "properties": {
              "identity": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_owned_gateway"
        ],
        "properties": {
          "get_owned_gateway": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_mixnode_delegations"
        ],
        "properties": {
          "get_mixnode_delegations": {
            "type": "object",
            "required": [
              "mix_id"
            ],
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "mix_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_delegator_delegations"
        ],
        "properties": {
          "get_delegator_delegations": {
            "type": "object",
            "required": [
              "delegator"
            ],
            "properties": {
              "delegator": {
                "type": "string"
              },
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "array",
                  "null"
                ],
                "items": [
                  {
                    "type": "integer",
                    "format": "uint32",
                    "minimum": 0.0
                  },
                  {
                    "type": "string"
                  }
                ],
                "maxItems": 2,
                "minItems": 2
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_delegation_details"
        ],
        "properties": {
          "get_delegation_details": {
            "type": "object",
            "required": [
              "delegator",
              "mix_id"
            ],
            "properties": {
              "delegator": {
                "type": "string"
              },
              "mix_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              "proxy": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_all_delegations"
        ],
        "properties": {
          "get_all_delegations": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "array",
                  "null"
                ],
                "items": [
                  {
                    "type": "integer",
                    "format": "uint32",
                    "minimum": 0.0
                  },
                  {
                    "type": "string"
                  }
                ],
                "maxItems": 2,
                "minItems": 2
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_pending_operator_reward"
        ],
        "properties": {
          "get_pending_operator_reward": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_pending_mix_node_operator_reward"
        ],
        "properties": {
          "get_pending_mix_node_operator_reward": {
            "type": "object",
            "required": [
              "mix_id"
            ],
            "properties": {
              "mix_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_pending_delegator_reward"
        ],
        "properties": {
          "get_pending_delegator_reward": {
            "type": "object",
            "required": [
              "address",
              "mix_id"
            ],
            "properties": {
              "address": {
                "type": "string"
              },
              "mix_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              "proxy": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_estimated_current_epoch_operator_reward"
        ],
        "properties": {
          "get_estimated_current_epoch_operator_reward": {
            "type": "object",
            "required": [
              "estimated_performance",
              "mix_id"
            ],
            "properties": {
              "estimated_performance": {
                "$ref": "#/definitions/Percent"
              },
              "mix_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_estimated_current_epoch_delegator_reward"
        ],
        "properties": {
          "get_estimated_current_epoch_delegator_reward": {
            "type": "object",
            "required": [
              "address",
              "estimated_performance",
              "mix_id"
            ],
            "properties": {
              "address": {
                "type": "string"
              },
              "estimated_performance": {
                "$ref": "#/definitions/Percent"
              },
              "mix_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              "proxy": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_pending_epoch_events"
        ],
        "properties": {
          "get_pending_epoch_events": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_pending_interval_events"
        ],
        "properties": {
          "get_pending_interval_events": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_pending_epoch_event"
        ],
        "properties": {
          "get_pending_epoch_event": {
            "type": "object",
            "required": [
              "event_id"
            ],
            "properties": {
              "event_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_pending_interval_event"
        ],
        "properties": {
          "get_pending_interval_event": {
            "type": "object",
            "required": [
              "event_id"
            ],
            "properties": {
              "event_id": {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_number_of_pending_events"
        ],
        "properties": {
          "get_number_of_pending_events": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_signing_nonce"
        ],
        "properties": {
          "get_signing_nonce": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "Percent": {
        "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
        "allOf": [
          {
            "$ref": "#/definitions/Decimal"
          }
        ]
      }
    }
  },
  "migrate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "MigrateMsg",
    "type": "object",
    "properties": {
      "vesting_contract_address": {
        "type": [
          "string",
          "null"
        ]
      }
    },
    "additionalProperties": false
  },
  "sudo": null,
  "responses": {
    "get_all_delegations": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedAllDelegationsResponse",
      "type": "object",
      "required": [
        "delegations"
      ],
      "properties": {
        "delegations": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Delegation"
          }
        },
        "start_next_after": {
          "type": [
            "array",
            "null"
          ],
          "items": [
            {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            {
              "type": "string"
            }
          ],
          "maxItems": 2,
          "minItems": 2
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Delegation": {
          "type": "object",
          "required": [
            "amount",
            "cumulative_reward_ratio",
            "height",
            "mix_id",
            "owner"
          ],
          "properties": {
            "amount": {
              "description": "Original delegation amount. Note that it is never mutated as delegation accumulates rewards.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "cumulative_reward_ratio": {
              "description": "Value of the \"unit delegation\" associated with the mixnode at the time of delegation.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "height": {
              "description": "Block height where this delegation occurred.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "mix_id": {
              "description": "Id of the MixNode that this delegation was performed against.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "owner": {
              "description": "Address of the owner of this delegation.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Proxy address used to delegate the funds on behalf of another address",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_all_families_paged": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedFamiliesResponse",
      "type": "object",
      "required": [
        "families"
      ],
      "properties": {
        "families": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Family"
          }
        },
        "start_next_after": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Family": {
          "type": "object",
          "required": [
            "head",
            "label"
          ],
          "properties": {
            "head": {
              "$ref": "#/definitions/FamilyHead"
            },
            "label": {
              "type": "string"
            },
            "proxy": {
              "type": [
                "string",
                "null"
              ]
            }
          },
          "additionalProperties": false
        },
        "FamilyHead": {
          "type": "string"
        }
      }
    },
    "get_all_members_paged": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedMembersResponse",
      "type": "object",
      "required": [
        "members"
      ],
      "properties": {
        "members": {
          "type": "array",
          "items": {
            "type": "array",
            "items": [
              {
                "type": "string"
              },
              {
                "$ref": "#/definitions/FamilyHead"
              }
            ],
            "maxItems": 2,
            "minItems": 2
          }
        },
        "start_next_after": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "FamilyHead": {
          "type": "string"
        }
      }
    },
    "get_bonded_mixnode_details_by_identity": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Nullable_MixNodeDetails",
      "anyOf": [
        {
          "$ref": "#/definitions/MixNodeDetails"
        },
        {
          "type": "null"
        }
      ],
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Layer": {
          "type": "string",
          "enum": [
            "One",
            "Two",
            "Three"
          ]
        },
        "MixNode": {
          "type": "object",
          "required": [
            "host",
            "http_api_port",
            "identity_key",
            "mix_port",
            "sphinx_key",
            "verloc_port",
            "version"
          ],
          "properties": {
            "host": {
              "description": "Network address of this mixnode, for example 1.1.1.1:1234 or foo.mixnode.com",
              "type": "string"
            },
            "http_api_port": {
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            },
            "mix_port": {
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "sphinx_key": {
              "description": "Base58-encoded x25519 public key used for sphinx key derivation.",
              "type": "string"
            },
            "verloc_port": {
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "version": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "MixNodeBond": {
          "type": "object",
          "required": [
            "bonding_height",
            "is_unbonding",
            "layer",
            "mix_id",
            "mix_node",
            "original_pledge",
            "owner"
          ],
          "properties": {
            "bonding_height": {
              "description": "Block height at which this mixnode has been bonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "is_unbonding": {
              "description": "Flag to indicate whether this node is in the process of unbonding, that will conclude upon the epoch finishing.",
              "type": "boolean"
            },
            "layer": {
              "description": "Layer assigned to this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Layer"
                }
              ]
            },
            "mix_id": {
              "description": "Unique id assigned to the bonded mixnode.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "mix_node": {
              "description": "Information provided by the operator for the purposes of bonding.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNode"
                }
              ]
            },
            "original_pledge": {
              "description": "Original amount pledged by the operator of this node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "owner": {
              "description": "Address of the owner of this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Entity who bonded this mixnode on behalf of the owner. If exists, it's most likely the address of the vesting contract.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "MixNodeCostParams": {
          "type": "object",
          "required": [
            "interval_operating_cost",
            "profit_margin_percent"
          ],
          "properties": {
            "interval_operating_cost": {
              "description": "Operating cost of the associated mixnode per the entire interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "profit_margin_percent": {
              "$ref": "#/definitions/Percent"
            }
          },
          "additionalProperties": false
        },
        "MixNodeDetails": {
          "type": "object",
          "required": [
            "bond_information",
            "rewarding_details"
          ],
          "properties": {
            "bond_information": {
              "$ref": "#/definitions/MixNodeBond"
            },
            "pending_changes": {
              "default": {
                "pledge_change": null
              },
              "allOf": [
                {
                  "$ref": "#/definitions/PendingMixNodeChanges"
                }
              ]
            },
            "rewarding_details": {
              "$ref": "#/definitions/MixNodeRewarding"
            }
          },
          "additionalProperties": false
        },
        "MixNodeRewarding": {
          "type": "object",
          "required": [
            "cost_params",
            "delegates",
            "last_rewarded_epoch",
            "operator",
            "total_unit_reward",
            "unique_delegations",
            "unit_delegation"
          ],
          "properties": {
            "cost_params": {
              "description": "Information provided by the operator that influence the cost function.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNodeCostParams"
                }
              ]
            },
            "delegates": {
              "description": "Total delegation and compounded reward earned by all node delegators.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "last_rewarded_epoch": {
              "description": "Marks the epoch when this node was last rewarded so that we wouldn't accidentally attempt to reward it multiple times in the same epoch.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "operator": {
              "description": "Total pledge and compounded reward earned by the node operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "total_unit_reward": {
              "description": "Cumulative reward earned by the \"unit delegation\" since the block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "unique_delegations": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "unit_delegation": {
              "description": "Value of the theoretical \"unit delegation\" that has delegated to this mixnode at block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PendingMixNodeChanges": {
          "type": "object",
          "properties": {
            "pledge_change": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Percent": {
          "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_c_w2_contract_version": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ContractVersion",
      "type": "object",
      "required": [
        "contract",
        "version"
      ],
      "properties": {
        "contract": {
          "description": "contract is the crate name of the implementing contract, eg. `crate:cw20-base` we will use other prefixes for other languages, and their standard global namespacing",
          "type": "string"
        },
        "version": {
          "description": "version is any string that this implementation knows. It may be simple counter \"1\", \"2\". or semantic version on release tags \"v0.7.0\", or some custom feature flag list. the only code that needs to understand the version parsing is code that knows how to migrate from the given contract (and is tied to it's implementation somehow)",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "get_contract_version": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ContractBuildInformation",
      "type": "object",
      "required": [
        "build_timestamp",
        "build_version",
        "commit_branch",
        "commit_sha",
        "commit_timestamp",
        "rustc_version"
      ],
      "properties": {
        "build_timestamp": {
          "description": "Provides the build timestamp, for example `2021-02-23T20:14:46.558472672+00:00`.",
          "type": "string"
        },
        "build_version": {
          "description": "Provides the build version, for example `0.1.0-9-g46f83e1`.",
          "type": "string"
        },
        "commit_branch": {
          "description": "Provides the name of the git branch that was used for the build, for example `master`.",
          "type": "string"
        },
        "commit_sha": {
          "description": "Provides the hash of the commit that was used for the build, for example `46f83e112520533338245862d366f6a02cef07d4`.",
          "type": "string"
        },
        "commit_timestamp": {
          "description": "Provides the timestamp of the commit that was used for the build, for example `2021-02-23T08:08:02-05:00`.",
          "type": "string"
        },
        "rustc_version": {
          "description": "Provides the rustc version that was used for the build, for example `1.52.0-nightly`.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "get_current_interval_details": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "CurrentIntervalResponse",
      "type": "object",
      "required": [
        "current_blocktime",
        "interval",
        "is_current_epoch_over",
        "is_current_interval_over"
      ],
      "properties": {
        "current_blocktime": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "interval": {
          "$ref": "#/definitions/Interval"
        },
        "is_current_epoch_over": {
          "type": "boolean"
        },
        "is_current_interval_over": {
          "type": "boolean"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Duration": {
          "type": "object",
          "required": [
            "nanos",
            "secs"
          ],
          "properties": {
            "nanos": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "secs": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          }
        },
        "Interval": {
          "type": "object",
          "required": [
            "current_epoch_id",
            "current_epoch_start",
            "epoch_length",
            "epochs_in_interval",
            "id",
            "total_elapsed_epochs"
          ],
          "properties": {
            "current_epoch_id": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "current_epoch_start": {
              "type": "string"
            },
            "epoch_length": {
              "$ref": "#/definitions/Duration"
            },
            "epochs_in_interval": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "id": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "total_elapsed_epochs": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          }
        }
      }
    },
    "get_delegation_details": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "MixNodeDelegationResponse",
      "type": "object",
      "required": [
        "mixnode_still_bonded"
      ],
      "properties": {
        "delegation": {
          "anyOf": [
            {
              "$ref": "#/definitions/Delegation"
            },
            {
              "type": "null"
            }
          ]
        },
        "mixnode_still_bonded": {
          "type": "boolean"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Delegation": {
          "type": "object",
          "required": [
            "amount",
            "cumulative_reward_ratio",
            "height",
            "mix_id",
            "owner"
          ],
          "properties": {
            "amount": {
              "description": "Original delegation amount. Note that it is never mutated as delegation accumulates rewards.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "cumulative_reward_ratio": {
              "description": "Value of the \"unit delegation\" associated with the mixnode at the time of delegation.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "height": {
              "description": "Block height where this delegation occurred.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "mix_id": {
              "description": "Id of the MixNode that this delegation was performed against.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "owner": {
              "description": "Address of the owner of this delegation.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Proxy address used to delegate the funds on behalf of another address",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_delegator_delegations": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedDelegatorDelegationsResponse",
      "type": "object",
      "required": [
        "delegations"
      ],
      "properties": {
        "delegations": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Delegation"
          }
        },
        "start_next_after": {
          "type": [
            "array",
            "null"
          ],
          "items": [
            {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            {
              "type": "string"
            }
          ],
          "maxItems": 2,
          "minItems": 2
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Delegation": {
          "type": "object",
          "required": [
            "amount",
            "cumulative_reward_ratio",
            "height",
            "mix_id",
            "owner"
          ],
          "properties": {
            "amount": {
              "description": "Original delegation amount. Note that it is never mutated as delegation accumulates rewards.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "cumulative_reward_ratio": {
              "description": "Value of the \"unit delegation\" associated with the mixnode at the time of delegation.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "height": {
              "description": "Block height where this delegation occurred.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "mix_id": {
              "description": "Id of the MixNode that this delegation was performed against.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "owner": {
              "description": "Address of the owner of this delegation.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Proxy address used to delegate the funds on behalf of another address",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_epoch_status": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "EpochStatus",
      "type": "object",
      "required": [
        "being_advanced_by",
        "state"
      ],
      "properties": {
        "being_advanced_by": {
          "description": "Specifies either, which validator is currently performing progression into the following epoch (if the epoch is currently being progressed), or which validator was responsible for progressing into the current epoch (if the epoch is currently in progress)",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "state": {
          "$ref": "#/definitions/EpochState"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "EpochState": {
          "oneOf": [
            {
              "description": "Represents the state of an epoch that's in progress (well, duh.) All actions are allowed to be issued.",
              "type": "string",
              "enum": [
                "in_progress"
              ]
            },
            {
              "description": "Represents the state of an epoch when the rewarding entity has been decided on, and the mixnodes are in the process of being rewarded for their work in this epoch.",
              "type": "object",
              "required": [
                "rewarding"
              ],
              "properties": {
                "rewarding": {
                  "type": "object",
                  "required": [
                    "final_node_id",
                    "last_rewarded"
                  ],
                  "properties": {
                    "final_node_id": {
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    },
                    "last_rewarded": {
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Represents the state of an epoch when all mixnodes have already been rewarded for their work in this epoch and all issued actions should now get resolved before being allowed to advance into the next epoch.",
              "type": "string",
              "enum": [
                "reconciling_events"
              ]
            },
            {
              "description": "Represents the state of an epoch when all mixnodes have already been rewarded for their work in this epoch, all issued actions got resolved and the epoch should now be advanced whilst assigning new rewarded set.",
              "type": "string",
              "enum": [
                "advancing_epoch"
              ]
            }
          ]
        }
      }
    },
    "get_estimated_current_epoch_delegator_reward": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "EstimatedCurrentEpochRewardResponse",
      "type": "object",
      "properties": {
        "current_stake_value": {
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "current_stake_value_detailed_amount": {
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "detailed_estimation_amount": {
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "estimation": {
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "original_stake": {
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_estimated_current_epoch_operator_reward": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "EstimatedCurrentEpochRewardResponse",
      "type": "object",
      "properties": {
        "current_stake_value": {
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "current_stake_value_detailed_amount": {
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "detailed_estimation_amount": {
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "estimation": {
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "original_stake": {
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_family_by_head": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Nullable_Family",
      "anyOf": [
        {
          "$ref": "#/definitions/Family"
        },
        {
          "type": "null"
        }
      ],
      "definitions": {
        "Family": {
          "type": "object",
          "required": [
            "head",
            "label"
          ],
          "properties": {
            "head": {
              "$ref": "#/definitions/FamilyHead"
            },
            "label": {
              "type": "string"
            },
            "proxy": {
              "type": [
                "string",
                "null"
              ]
            }
          },
          "additionalProperties": false
        },
        "FamilyHead": {
          "type": "string"
        }
      }
    },
    "get_family_by_label": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Nullable_Family",
      "anyOf": [
        {
          "$ref": "#/definitions/Family"
        },
        {
          "type": "null"
        }
      ],
      "definitions": {
        "Family": {
          "type": "object",
          "required": [
            "head",
            "label"
          ],
          "properties": {
            "head": {
              "$ref": "#/definitions/FamilyHead"
            },
            "label": {
              "type": "string"
            },
            "proxy": {
              "type": [
                "string",
                "null"
              ]
            }
          },
          "additionalProperties": false
        },
        "FamilyHead": {
          "type": "string"
        }
      }
    },
    "get_family_members_by_head": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Set_of_String",
      "type": "array",
      "items": {
        "type": "string"
      },
      "uniqueItems": true
    },
    "get_family_members_by_label": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Nullable_Set_of_String",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "string"
      },
      "uniqueItems": true
    },
    "get_gateway_bond": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "GatewayBondResponse",
      "type": "object",
      "required": [
        "identity"
      ],
      "properties": {
        "gateway": {
          "anyOf": [
            {
              "$ref": "#/definitions/GatewayBond"
            },
            {
              "type": "null"
            }
          ]
        },
        "identity": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Gateway": {
          "type": "object",
          "required": [
            "clients_port",
            "host",
            "identity_key",
            "location",
            "mix_port",
            "sphinx_key",
            "version"
          ],
          "properties": {
            "clients_port": {
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "host": {
              "type": "string"
            },
            "identity_key": {
              "description": "Base58 encoded ed25519 EdDSA public key of the gateway used to derive shared keys with clients",
              "type": "string"
            },
            "location": {
              "type": "string"
            },
            "mix_port": {
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "sphinx_key": {
              "type": "string"
            },
            "version": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "GatewayBond": {
          "type": "object",
          "required": [
            "block_height",
            "gateway",
            "owner",
            "pledge_amount"
          ],
          "properties": {
            "block_height": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "gateway": {
              "$ref": "#/definitions/Gateway"
            },
            "owner": {
              "$ref": "#/definitions/Addr"
            },
            "pledge_amount": {
              "$ref": "#/definitions/Coin"
            },
            "proxy": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_gateways": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedGatewayResponse",
      "type": "object",
      "required": [
        "nodes",
        "per_page"
      ],
      "properties": {
        "nodes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/GatewayBond"
          }
        },
        "per_page": {
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        },
        "start_next_after": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Gateway": {
          "type": "object",
          "required": [
            "clients_port",
            "host",
            "identity_key",
            "location",
            "mix_port",
            "sphinx_key",
            "version"
          ],
          "properties": {
            "clients_port": {
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "host": {
              "type": "string"
            },
            "identity_key": {
              "description": "Base58 encoded ed25519 EdDSA public key of the gateway used to derive shared keys with clients",
              "type": "string"
            },
            "location": {
              "type": "string"
            },
            "mix_port": {
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "sphinx_key": {
              "type": "string"
            },
            "version": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "GatewayBond": {
          "type": "object",
          "required": [
            "block_height",
            "gateway",
            "owner",
            "pledge_amount"
          ],
          "properties": {
            "block_height": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "gateway": {
              "$ref": "#/definitions/Gateway"
            },
            "owner": {
              "$ref": "#/definitions/Addr"
            },
            "pledge_amount": {
              "$ref": "#/definitions/Coin"
            },
            "proxy": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_layer_distribution": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "LayerDistribution",
      "type": "object",
      "required": [
        "layer1",
        "layer2",
        "layer3"
      ],
      "properties": {
        "layer1": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "layer2": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "layer3": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        }
      },
      "additionalProperties": false
    },
    "get_mix_node_bonds": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedMixnodeBondsResponse",
      "type": "object",
      "required": [
        "nodes",
        "per_page"
      ],
      "properties": {
        "nodes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MixNodeBond"
          }
        },
        "per_page": {
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        },
        "start_next_after": {
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Layer": {
          "type": "string",
          "enum": [
            "One",
            "Two",
            "Three"
          ]
        },
        "MixNode": {
          "type": "object",
          "required": [
            "host",
            "http_api_port",
            "identity_key",
            "mix_port",
            "sphinx_key",
            "verloc_port",
            "version"
          ],
          "properties": {
            "host": {
              "description": "Network address of this mixnode, for example 1.1.1.1:1234 or foo.mixnode.com",
              "type": "string"
            },
            "http_api_port": {
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            },
            "mix_port": {
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "sphinx_key": {
              "description": "Base58-encoded x25519 public key used for sphinx key derivation.",
              "type": "string"
            },
            "verloc_port": {
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "version": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "MixNodeBond": {
          "type": "object",
          "required": [
            "bonding_height",
            "is_unbonding",
            "layer",
            "mix_id",
            "mix_node",
            "original_pledge",
            "owner"
          ],
          "properties": {
            "bonding_height": {
              "description": "Block height at which this mixnode has been bonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "is_unbonding": {
              "description": "Flag to indicate whether this node is in the process of unbonding, that will conclude upon the epoch finishing.",
              "type": "boolean"
            },
            "layer": {
              "description": "Layer assigned to this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Layer"
                }
              ]
            },
            "mix_id": {
              "description": "Unique id assigned to the bonded mixnode.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "mix_node": {
              "description": "Information provided by the operator for the purposes of bonding.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNode"
                }
              ]
            },
            "original_pledge": {
              "description": "Original amount pledged by the operator of this node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "owner": {
              "description": "Address of the owner of this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Entity who bonded this mixnode on behalf of the owner. If exists, it's most likely the address of the vesting contract.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_mix_nodes_detailed": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedMixnodesDetailsResponse",
      "type": "object",
      "required": [
        "nodes",
        "per_page"
      ],
      "properties": {
        "nodes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MixNodeDetails"
          }
        },
        "per_page": {
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        },
        "start_next_after": {
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Layer": {
          "type": "string",
          "enum": [
            "One",
            "Two",
            "Three"
          ]
        },
        "MixNode": {
          "type": "object",
          "required": [
            "host",
            "http_api_port",
            "identity_key",
            "mix_port",
            "sphinx_key",
            "verloc_port",
            "version"
          ],
          "properties": {
            "host": {
              "description": "Network address of this mixnode, for example 1.1.1.1:1234 or foo.mixnode.com",
              "type": "string"
            },
            "http_api_port": {
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            },
            "mix_port": {
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "sphinx_key": {
              "description": "Base58-encoded x25519 public key used for sphinx key derivation.",
              "type": "string"
            },
            "verloc_port": {
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "version": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "MixNodeBond": {
          "type": "object",
          "required": [
            "bonding_height",
            "is_unbonding",
            "layer",
            "mix_id",
            "mix_node",
            "original_pledge",
            "owner"
          ],
          "properties": {
            "bonding_height": {
              "description": "Block height at which this mixnode has been bonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "is_unbonding": {
              "description": "Flag to indicate whether this node is in the process of unbonding, that will conclude upon the epoch finishing.",
              "type": "boolean"
            },
            "layer": {
              "description": "Layer assigned to this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Layer"
                }
              ]
            },
            "mix_id": {
              "description": "Unique id assigned to the bonded mixnode.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "mix_node": {
              "description": "Information provided by the operator for the purposes of bonding.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNode"
                }
              ]
            },
            "original_pledge": {
              "description": "Original amount pledged by the operator of this node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "owner": {
              "description": "Address of the owner of this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Entity who bonded this mixnode on behalf of the owner. If exists, it's most likely the address of the vesting contract.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "MixNodeCostParams": {
          "type": "object",
          "required": [
            "interval_operating_cost",
            "profit_margin_percent"
          ],
          "properties": {
            "interval_operating_cost": {
              "description": "Operating cost of the associated mixnode per the entire interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "profit_margin_percent": {
              "$ref": "#/definitions/Percent"
            }
          },
          "additionalProperties": false
        },
        "MixNodeDetails": {
          "type": "object",
          "required": [
            "bond_information",
            "rewarding_details"
          ],
          "properties": {
            "bond_information": {
              "$ref": "#/definitions/MixNodeBond"
            },
            "pending_changes": {
              "default": {
                "pledge_change": null
              },
              "allOf": [
                {
                  "$ref": "#/definitions/PendingMixNodeChanges"
                }
              ]
            },
            "rewarding_details": {
              "$ref": "#/definitions/MixNodeRewarding"
            }
          },
          "additionalProperties": false
        },
        "MixNodeRewarding": {
          "type": "object",
          "required": [
            "cost_params",
            "delegates",
            "last_rewarded_epoch",
            "operator",
            "total_unit_reward",
            "unique_delegations",
            "unit_delegation"
          ],
          "properties": {
            "cost_params": {
              "description": "Information provided by the operator that influence the cost function.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNodeCostParams"
                }
              ]
            },
            "delegates": {
              "description": "Total delegation and compounded reward earned by all node delegators.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "last_rewarded_epoch": {
              "description": "Marks the epoch when this node was last rewarded so that we wouldn't accidentally attempt to reward it multiple times in the same epoch.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "operator": {
              "description": "Total pledge and compounded reward earned by the node operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "total_unit_reward": {
              "description": "Cumulative reward earned by the \"unit delegation\" since the block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "unique_delegations": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "unit_delegation": {
              "description": "Value of the theoretical \"unit delegation\" that has delegated to this mixnode at block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PendingMixNodeChanges": {
          "type": "object",
          "properties": {
            "pledge_change": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Percent": {
          "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_mixnode_delegations": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedMixNodeDelegationsResponse",
      "type": "object",
      "required": [
        "delegations"
      ],
      "properties": {
        "delegations": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Delegation"
          }
        },
        "start_next_after": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Delegation": {
          "type": "object",
          "required": [
            "amount",
            "cumulative_reward_ratio",
            "height",
            "mix_id",
            "owner"
          ],
          "properties": {
            "amount": {
              "description": "Original delegation amount. Note that it is never mutated as delegation accumulates rewards.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "cumulative_reward_ratio": {
              "description": "Value of the \"unit delegation\" associated with the mixnode at the time of delegation.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "height": {
              "description": "Block height where this delegation occurred.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "mix_id": {
              "description": "Id of the MixNode that this delegation was performed against.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "owner": {
              "description": "Address of the owner of this delegation.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Proxy address used to delegate the funds on behalf of another address",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_mixnode_details": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "MixnodeDetailsResponse",
      "type": "object",
      "required": [
        "mix_id"
      ],
      "properties": {
        "mix_id": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "mixnode_details": {
          "anyOf": [
            {
              "$ref": "#/definitions/MixNodeDetails"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Layer": {
          "type": "string",
          "enum": [
            "One",
            "Two",
            "Three"
          ]
        },
        "MixNode": {
          "type": "object",
          "required": [
            "host",
            "http_api_port",
            "identity_key",
            "mix_port",
            "sphinx_key",
            "verloc_port",
            "version"
          ],
          "properties": {
            "host": {
              "description": "Network address of this mixnode, for example 1.1.1.1:1234 or foo.mixnode.com",
              "type": "string"
            },
            "http_api_port": {
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            },
            "mix_port": {
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "sphinx_key": {
              "description": "Base58-encoded x25519 public key used for sphinx key derivation.",
              "type": "string"
            },
            "verloc_port": {
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "version": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "MixNodeBond": {
          "type": "object",
          "required": [
            "bonding_height",
            "is_unbonding",
            "layer",
            "mix_id",
            "mix_node",
            "original_pledge",
            "owner"
          ],
          "properties": {
            "bonding_height": {
              "description": "Block height at which this mixnode has been bonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "is_unbonding": {
              "description": "Flag to indicate whether this node is in the process of unbonding, that will conclude upon the epoch finishing.",
              "type": "boolean"
            },
            "layer": {
              "description": "Layer assigned to this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Layer"
                }
              ]
            },
            "mix_id": {
              "description": "Unique id assigned to the bonded mixnode.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "mix_node": {
              "description": "Information provided by the operator for the purposes of bonding.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNode"
                }
              ]
            },
            "original_pledge": {
              "description": "Original amount pledged by the operator of this node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "owner": {
              "description": "Address of the owner of this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Entity who bonded this mixnode on behalf of the owner. If exists, it's most likely the address of the vesting contract.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "MixNodeCostParams": {
          "type": "object",
          "required": [
            "interval_operating_cost",
            "profit_margin_percent"
          ],
          "properties": {
            "interval_operating_cost": {
              "description": "Operating cost of the associated mixnode per the entire interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "profit_margin_percent": {
              "$ref": "#/definitions/Percent"
            }
          },
          "additionalProperties": false
        },
        "MixNodeDetails": {
          "type": "object",
          "required": [
            "bond_information",
            "rewarding_details"
          ],
          "properties": {
            "bond_information": {
              "$ref": "#/definitions/MixNodeBond"
            },
            "pending_changes": {
              "default": {
                "pledge_change": null
              },
              "allOf": [
                {
                  "$ref": "#/definitions/PendingMixNodeChanges"
                }
              ]
            },
            "rewarding_details": {
              "$ref": "#/definitions/MixNodeRewarding"
            }
          },
          "additionalProperties": false
        },
        "MixNodeRewarding": {
          "type": "object",
          "required": [
            "cost_params",
            "delegates",
            "last_rewarded_epoch",
            "operator",
            "total_unit_reward",
            "unique_delegations",
            "unit_delegation"
          ],
          "properties": {
            "cost_params": {
              "description": "Information provided by the operator that influence the cost function.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNodeCostParams"
                }
              ]
            },
            "delegates": {
              "description": "Total delegation and compounded reward earned by all node delegators.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "last_rewarded_epoch": {
              "description": "Marks the epoch when this node was last rewarded so that we wouldn't accidentally attempt to reward it multiple times in the same epoch.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "operator": {
              "description": "Total pledge and compounded reward earned by the node operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "total_unit_reward": {
              "description": "Cumulative reward earned by the \"unit delegation\" since the block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "unique_delegations": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "unit_delegation": {
              "description": "Value of the theoretical \"unit delegation\" that has delegated to this mixnode at block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PendingMixNodeChanges": {
          "type": "object",
          "properties": {
            "pledge_change": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Percent": {
          "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_mixnode_rewarding_details": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "MixnodeRewardingDetailsResponse",
      "type": "object",
      "required": [
        "mix_id"
      ],
      "properties": {
        "mix_id": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "rewarding_details": {
          "anyOf": [
            {
              "$ref": "#/definitions/MixNodeRewarding"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "MixNodeCostParams": {
          "type": "object",
          "required": [
            "interval_operating_cost",
            "profit_margin_percent"
          ],
          "properties": {
            "interval_operating_cost": {
              "description": "Operating cost of the associated mixnode per the entire interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "profit_margin_percent": {
              "$ref": "#/definitions/Percent"
            }
          },
          "additionalProperties": false
        },
        "MixNodeRewarding": {
          "type": "object",
          "required": [
            "cost_params",
            "delegates",
            "last_rewarded_epoch",
            "operator",
            "total_unit_reward",
            "unique_delegations",
            "unit_delegation"
          ],
          "properties": {
            "cost_params": {
              "description": "Information provided by the operator that influence the cost function.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNodeCostParams"
                }
              ]
            },
            "delegates": {
              "description": "Total delegation and compounded reward earned by all node delegators.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "last_rewarded_epoch": {
              "description": "Marks the epoch when this node was last rewarded so that we wouldn't accidentally attempt to reward it multiple times in the same epoch.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "operator": {
              "description": "Total pledge and compounded reward earned by the node operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "total_unit_reward": {
              "description": "Cumulative reward earned by the \"unit delegation\" since the block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "unique_delegations": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "unit_delegation": {
              "description": "Value of the theoretical \"unit delegation\" that has delegated to this mixnode at block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Percent": {
          "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_number_of_pending_events": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "NumberOfPendingEventsResponse",
      "type": "object",
      "required": [
        "epoch_events",
        "interval_events"
      ],
      "properties": {
        "epoch_events": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "interval_events": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false
    },
    "get_owned_gateway": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "GatewayOwnershipResponse",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "address": {
          "$ref": "#/definitions/Addr"
        },
        "gateway": {
          "anyOf": [
            {
              "$ref": "#/definitions/GatewayBond"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Gateway": {
          "type": "object",
          "required": [
            "clients_port",
            "host",
            "identity_key",
            "location",
            "mix_port",
            "sphinx_key",
            "version"
          ],
          "properties": {
            "clients_port": {
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "host": {
              "type": "string"
            },
            "identity_key": {
              "description": "Base58 encoded ed25519 EdDSA public key of the gateway used to derive shared keys with clients",
              "type": "string"
            },
            "location": {
              "type": "string"
            },
            "mix_port": {
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "sphinx_key": {
              "type": "string"
            },
            "version": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "GatewayBond": {
          "type": "object",
          "required": [
            "block_height",
            "gateway",
            "owner",
            "pledge_amount"
          ],
          "properties": {
            "block_height": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "gateway": {
              "$ref": "#/definitions/Gateway"
            },
            "owner": {
              "$ref": "#/definitions/Addr"
            },
            "pledge_amount": {
              "$ref": "#/definitions/Coin"
            },
            "proxy": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_owned_mixnode": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "MixOwnershipResponse",
      "type": "object",
      "required": [
        "address"
      ],
      "properties": {
        "address": {
          "$ref": "#/definitions/Addr"
        },
        "mixnode_details": {
          "anyOf": [
            {
              "$ref": "#/definitions/MixNodeDetails"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Layer": {
          "type": "string",
          "enum": [
            "One",
            "Two",
            "Three"
          ]
        },
        "MixNode": {
          "type": "object",
          "required": [
            "host",
            "http_api_port",
            "identity_key",
            "mix_port",
            "sphinx_key",
            "verloc_port",
            "version"
          ],
          "properties": {
            "host": {
              "description": "Network address of this mixnode, for example 1.1.1.1:1234 or foo.mixnode.com",
              "type": "string"
            },
            "http_api_port": {
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "identity_key": {
              "description": "Base58-encoded ed25519 EdDSA public key.",
              "type": "string"
            },
            "mix_port": {
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "sphinx_key": {
              "description": "Base58-encoded x25519 public key used for sphinx key derivation.",
              "type": "string"
            },
            "verloc_port": {
              "type": "integer",
              "format": "uint16",
              "minimum": 0.0
            },
            "version": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "MixNodeBond": {
          "type": "object",
          "required": [
            "bonding_height",
            "is_unbonding",
            "layer",
            "mix_id",
            "mix_node",
            "original_pledge",
            "owner"
          ],
          "properties": {
            "bonding_height": {
              "description": "Block height at which this mixnode has been bonded.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "is_unbonding": {
              "description": "Flag to indicate whether this node is in the process of unbonding, that will conclude upon the epoch finishing.",
              "type": "boolean"
            },
            "layer": {
              "description": "Layer assigned to this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Layer"
                }
              ]
            },
            "mix_id": {
              "description": "Unique id assigned to the bonded mixnode.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "mix_node": {
              "description": "Information provided by the operator for the purposes of bonding.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNode"
                }
              ]
            },
            "original_pledge": {
              "description": "Original amount pledged by the operator of this node.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "owner": {
              "description": "Address of the owner of this mixnode.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "proxy": {
              "description": "Entity who bonded this mixnode on behalf of the owner. If exists, it's most likely the address of the vesting contract.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "MixNodeCostParams": {
          "type": "object",
          "required": [
            "interval_operating_cost",
            "profit_margin_percent"
          ],
          "properties": {
            "interval_operating_cost": {
              "description": "Operating cost of the associated mixnode per the entire interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "profit_margin_percent": {
              "$ref": "#/definitions/Percent"
            }
          },
          "additionalProperties": false
        },
        "MixNodeDetails": {
          "type": "object",
          "required": [
            "bond_information",
            "rewarding_details"
          ],
          "properties": {
            "bond_information": {
              "$ref": "#/definitions/MixNodeBond"
            },
            "pending_changes": {
              "default": {
                "pledge_change": null
              },
              "allOf": [
                {
                  "$ref": "#/definitions/PendingMixNodeChanges"
                }
              ]
            },
            "rewarding_details": {
              "$ref": "#/definitions/MixNodeRewarding"
            }
          },
          "additionalProperties": false
        },
        "MixNodeRewarding": {
          "type": "object",
          "required": [
            "cost_params",
            "delegates",
            "last_rewarded_epoch",
            "operator",
            "total_unit_reward",
            "unique_delegations",
            "unit_delegation"
          ],
          "properties": {
            "cost_params": {
              "description": "Information provided by the operator that influence the cost function.",
              "allOf": [
                {
                  "$ref": "#/definitions/MixNodeCostParams"
                }
              ]
            },
            "delegates": {
              "description": "Total delegation and compounded reward earned by all node delegators.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "last_rewarded_epoch": {
              "description": "Marks the epoch when this node was last rewarded so that we wouldn't accidentally attempt to reward it multiple times in the same epoch.",
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "operator": {
              "description": "Total pledge and compounded reward earned by the node operator.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "total_unit_reward": {
              "description": "Cumulative reward earned by the \"unit delegation\" since the block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "unique_delegations": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            },
            "unit_delegation": {
              "description": "Value of the theoretical \"unit delegation\" that has delegated to this mixnode at block 0.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "PendingMixNodeChanges": {
          "type": "object",
          "properties": {
            "pledge_change": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Percent": {
          "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_pending_delegator_reward": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PendingRewardResponse",
      "type": "object",
      "required": [
        "mixnode_still_fully_bonded"
      ],
      "properties": {
        "amount_earned": {
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "amount_earned_detailed": {
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "amount_staked": {
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "mixnode_still_fully_bonded": {
          "description": "The associated mixnode is still fully bonded, meaning it is neither unbonded nor in the process of unbonding that would have finished at the epoch transition.",
          "type": "boolean"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_pending_epoch_event": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PendingEpochEventResponse",
      "type": "object",
      "required": [
        "event_id"
      ],
      "properties": {
        "event": {
          "anyOf": [
            {
              "$ref": "#/definitions/PendingEpochEventData"
            },
            {
              "type": "null"
            }
          ]
        },
        "event_id": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "PendingEpochEventData": {
          "type": "object",
          "required": [
            "created_at",
            "kind"
          ],
          "properties": {
            "created_at": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "kind": {
              "$ref": "#/definitions/PendingEpochEventKind"
            }
          },
          "additionalProperties": false
        },
        "PendingEpochEventKind": {
          "oneOf": [
            {
              "type": "object",
              "required": [
                "delegate"
              ],
              "properties": {
                "delegate": {
                  "type": "object",
                  "required": [
                    "amount",
                    "mix_id",
                    "owner"
                  ],
                  "properties": {
                    "amount": {
                      "$ref": "#/definitions/Coin"
                    },
                    "mix_id": {
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    },
                    "owner": {
                      "$ref": "#/definitions/Addr"
                    },
                    "proxy": {
                      "anyOf": [
                        {
                          "$ref": "#/definitions/Addr"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "undelegate"
              ],
              "properties": {
                "undelegate": {
                  "type": "object",
                  "required": [
                    "mix_id",
                    "owner"
                  ],
                  "properties": {
                    "mix_id": {
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    },
                    "owner": {
                      "$ref": "#/definitions/Addr"
                    },
                    "proxy": {
                      "anyOf": [
                        {
                          "$ref": "#/definitions/Addr"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "pledge_more"
              ],
              "properties": {
                "pledge_more": {
                  "type": "object",
                  "required": [
                    "amount",
                    "mix_id"
                  ],
                  "properties": {
                    "amount": {
                      "$ref": "#/definitions/Coin"
                    },
                    "mix_id": {
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "decrease_pledge"
              ],
              "properties": {
                "decrease_pledge": {
                  "type": "object",
                  "required": [
                    "decrease_by",
                    "mix_id"
                  ],
                  "properties": {
                    "decrease_by": {
                      "$ref": "#/definitions/Coin"
                    },
                    "mix_id": {
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "unbond_mixnode"
              ],
              "properties": {
                "unbond_mixnode": {
                  "type": "object",
                  "required": [
                    "mix_id"
                  ],
                  "properties": {
                    "mix_id": {
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "update_active_set_size"
              ],
              "properties": {
                "update_active_set_size": {
                  "type": "object",
                  "required": [
                    "new_size"
                  ],
                  "properties": {
                    "new_size": {
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_pending_epoch_events": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PendingEpochEventsResponse",
      "type": "object",
      "required": [
        "events",
        "seconds_until_executable"
      ],
      "properties": {
        "events": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PendingEpochEvent"
          }
        },
        "seconds_until_executable": {
          "type": "integer",
          "format": "int64"
        },
        "start_next_after": {
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "PendingEpochEvent": {
          "type": "object",
          "required": [
            "event",
            "id"
          ],
          "properties": {
            "event": {
              "$ref": "#/definitions/PendingEpochEventData"
            },
            "id": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "PendingEpochEventData": {
          "type": "object",
          "required": [
            "created_at",
            "kind"
          ],
          "properties": {
            "created_at": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "kind": {
              "$ref": "#/definitions/PendingEpochEventKind"
            }
          },
          "additionalProperties": false
        },
        "PendingEpochEventKind": {
          "oneOf": [
            {
              "type": "object",
              "required": [
                "delegate"
              ],
              "properties": {
                "delegate": {
                  "type": "object",
                  "required": [
                    "amount",
                    "mix_id",
                    "owner"
                  ],
                  "properties": {
                    "amount": {
                      "$ref": "#/definitions/Coin"
                    },
                    "mix_id": {
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    },
                    "owner": {
                      "$ref": "#/definitions/Addr"
                    },
                    "proxy": {
                      "anyOf": [
                        {
                          "$ref": "#/definitions/Addr"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "undelegate"
              ],
              "properties": {
                "undelegate": {
                  "type": "object",
                  "required": [
                    "mix_id",
                    "owner"
                  ],
                  "properties": {
                    "mix_id": {
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    },
                    "owner": {
                      "$ref": "#/definitions/Addr"
                    },
                    "proxy": {
                      "anyOf": [
                        {
                          "$ref": "#/definitions/Addr"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "pledge_more"
              ],
              "properties": {
                "pledge_more": {
                  "type": "object",
                  "required": [
                    "amount",
                    "mix_id"
                  ],
                  "properties": {
                    "amount": {
                      "$ref": "#/definitions/Coin"
                    },
                    "mix_id": {
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "decrease_pledge"
              ],
              "properties": {
                "decrease_pledge": {
                  "type": "object",
                  "required": [
                    "decrease_by",
                    "mix_id"
                  ],
                  "properties": {
                    "decrease_by": {
                      "$ref": "#/definitions/Coin"
                    },
                    "mix_id": {
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "unbond_mixnode"
              ],
              "properties": {
                "unbond_mixnode": {
                  "type": "object",
                  "required": [
                    "mix_id"
                  ],
                  "properties": {
                    "mix_id": {
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "update_active_set_size"
              ],
              "properties": {
                "update_active_set_size": {
                  "type": "object",
                  "required": [
                    "new_size"
                  ],
                  "properties": {
                    "new_size": {
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_pending_interval_event": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PendingIntervalEventResponse",
      "type": "object",
      "required": [
        "event_id"
      ],
      "properties": {
        "event": {
          "anyOf": [
            {
              "$ref": "#/definitions/PendingIntervalEventData"
            },
            {
              "type": "null"
            }
          ]
        },
        "event_id": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "IntervalRewardingParamsUpdate": {
          "type": "object",
          "properties": {
            "active_set_work_factor": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Decimal"
                },
                {
                  "type": "null"
                }
              ]
            },
            "interval_pool_emission": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Percent"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reward_pool": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Decimal"
                },
                {
                  "type": "null"
                }
              ]
            },
            "rewarded_set_size": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            },
            "staking_supply": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Decimal"
                },
                {
                  "type": "null"
                }
              ]
            },
            "staking_supply_scale_factor": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Percent"
                },
                {
                  "type": "null"
                }
              ]
            },
            "sybil_resistance_percent": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Percent"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "MixNodeCostParams": {
          "type": "object",
          "required": [
            "interval_operating_cost",
            "profit_margin_percent"
          ],
          "properties": {
            "interval_operating_cost": {
              "description": "Operating cost of the associated mixnode per the entire interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "profit_margin_percent": {
              "$ref": "#/definitions/Percent"
            }
          },
          "additionalProperties": false
        },
        "PendingIntervalEventData": {
          "type": "object",
          "required": [
            "created_at",
            "kind"
          ],
          "properties": {
            "created_at": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "kind": {
              "$ref": "#/definitions/PendingIntervalEventKind"
            }
          },
          "additionalProperties": false
        },
        "PendingIntervalEventKind": {
          "oneOf": [
            {
              "type": "object",
              "required": [
                "change_mix_cost_params"
              ],
              "properties": {
                "change_mix_cost_params": {
                  "type": "object",
                  "required": [
                    "mix_id",
                    "new_costs"
                  ],
                  "properties": {
                    "mix_id": {
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    },
                    "new_costs": {
                      "$ref": "#/definitions/MixNodeCostParams"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "update_rewarding_params"
              ],
              "properties": {
                "update_rewarding_params": {
                  "type": "object",
                  "required": [
                    "update"
                  ],
                  "properties": {
                    "update": {
                      "$ref": "#/definitions/IntervalRewardingParamsUpdate"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "update_interval_config"
              ],
              "properties": {
                "update_interval_config": {
                  "type": "object",
                  "required": [
                    "epoch_duration_secs",
                    "epochs_in_interval"
                  ],
                  "properties": {
                    "epoch_duration_secs": {
                      "type": "integer",
                      "format": "uint64",
                      "minimum": 0.0
                    },
                    "epochs_in_interval": {
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Percent": {
          "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_pending_interval_events": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PendingIntervalEventsResponse",
      "type": "object",
      "required": [
        "events",
        "seconds_until_executable"
      ],
      "properties": {
        "events": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/PendingIntervalEvent"
          }
        },
        "seconds_until_executable": {
          "type": "integer",
          "format": "int64"
        },
        "start_next_after": {
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "IntervalRewardingParamsUpdate": {
          "type": "object",
          "properties": {
            "active_set_work_factor": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Decimal"
                },
                {
                  "type": "null"
                }
              ]
            },
            "interval_pool_emission": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Percent"
                },
                {
                  "type": "null"
                }
              ]
            },
            "reward_pool": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Decimal"
                },
                {
                  "type": "null"
                }
              ]
            },
            "rewarded_set_size": {
              "type": [
                "integer",
                "null"
              ],
              "format": "uint32",
              "minimum": 0.0
            },
            "staking_supply": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Decimal"
                },
                {
                  "type": "null"
                }
              ]
            },
            "staking_supply_scale_factor": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Percent"
                },
                {
                  "type": "null"
                }
              ]
            },
            "sybil_resistance_percent": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Percent"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "MixNodeCostParams": {
          "type": "object",
          "required": [
            "interval_operating_cost",
            "profit_margin_percent"
          ],
          "properties": {
            "interval_operating_cost": {
              "description": "Operating cost of the associated mixnode per the entire interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "profit_margin_percent": {
              "$ref": "#/definitions/Percent"
            }
          },
          "additionalProperties": false
        },
        "PendingIntervalEvent": {
          "type": "object",
          "required": [
            "event",
            "id"
          ],
          "properties": {
            "event": {
              "$ref": "#/definitions/PendingIntervalEventData"
            },
            "id": {
              "type": "integer",
              "format": "uint32",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "PendingIntervalEventData": {
          "type": "object",
          "required": [
            "created_at",
            "kind"
          ],
          "properties": {
            "created_at": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "kind": {
              "$ref": "#/definitions/PendingIntervalEventKind"
            }
          },
          "additionalProperties": false
        },
        "PendingIntervalEventKind": {
          "oneOf": [
            {
              "type": "object",
              "required": [
                "change_mix_cost_params"
              ],
              "properties": {
                "change_mix_cost_params": {
                  "type": "object",
                  "required": [
                    "mix_id",
                    "new_costs"
                  ],
                  "properties": {
                    "mix_id": {
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    },
                    "new_costs": {
                      "$ref": "#/definitions/MixNodeCostParams"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "update_rewarding_params"
              ],
              "properties": {
                "update_rewarding_params": {
                  "type": "object",
                  "required": [
                    "update"
                  ],
                  "properties": {
                    "update": {
                      "$ref": "#/definitions/IntervalRewardingParamsUpdate"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "update_interval_config"
              ],
              "properties": {
                "update_interval_config": {
                  "type": "object",
                  "required": [
                    "epoch_duration_secs",
                    "epochs_in_interval"
                  ],
                  "properties": {
                    "epoch_duration_secs": {
                      "type": "integer",
                      "format": "uint64",
                      "minimum": 0.0
                    },
                    "epochs_in_interval": {
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Percent": {
          "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_pending_mix_node_operator_reward": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PendingRewardResponse",
      "type": "object",
      "required": [
        "mixnode_still_fully_bonded"
      ],
      "properties": {
        "amount_earned": {
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "amount_earned_detailed": {
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "amount_staked": {
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "mixnode_still_fully_bonded": {
          "description": "The associated mixnode is still fully bonded, meaning it is neither unbonded nor in the process of unbonding that would have finished at the epoch transition.",
          "type": "boolean"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_pending_operator_reward": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PendingRewardResponse",
      "type": "object",
      "required": [
        "mixnode_still_fully_bonded"
      ],
      "properties": {
        "amount_earned": {
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "amount_earned_detailed": {
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "amount_staked": {
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "mixnode_still_fully_bonded": {
          "description": "The associated mixnode is still fully bonded, meaning it is neither unbonded nor in the process of unbonding that would have finished at the epoch transition.",
          "type": "boolean"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_rewarded_set": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedRewardedSetResponse",
      "type": "object",
      "required": [
        "nodes"
      ],
      "properties": {
        "nodes": {
          "type": "array",
          "items": {
            "type": "array",
            "items": [
              {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              {
                "$ref": "#/definitions/RewardedSetNodeStatus"
              }
            ],
            "maxItems": 2,
            "minItems": 2
          }
        },
        "start_next_after": {
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "RewardedSetNodeStatus": {
          "type": "string",
          "enum": [
            "active",
            "standby"
          ]
        }
      }
    },
    "get_rewarding_params": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "RewardingParams",
      "type": "object",
      "required": [
        "active_set_size",
        "interval",
        "rewarded_set_size"
      ],
      "properties": {
        "active_set_size": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "interval": {
          "description": "Parameters that should remain unchanged throughout an interval.",
          "allOf": [
            {
              "$ref": "#/definitions/IntervalRewardParams"
            }
          ]
        },
        "rewarded_set_size": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "IntervalRewardParams": {
          "description": "Parameters required by the mix-mining reward distribution that do not change during an interval.",
          "type": "object",
          "required": [
            "active_set_work_factor",
            "epoch_reward_budget",
            "interval_pool_emission",
            "reward_pool",
            "stake_saturation_point",
            "staking_supply",
            "staking_supply_scale_factor",
            "sybil_resistance"
          ],
          "properties": {
            "active_set_work_factor": {
              "description": "Current active set work factor. It is not really expected to be changing very often. As a matter of fact, unless there's a very specific reason, it should remain constant.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "epoch_reward_budget": {
              "description": "Current value of the computed reward budget per epoch, per node. It is expected to be constant throughout the interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "interval_pool_emission": {
              "description": "Current maximum interval pool emission. Assuming all nodes in the rewarded set are fully saturated and have 100% performance, this % of the reward pool would get distributed in rewards to all operators and its delegators. It is not really expected to be changing very often. As a matter of fact, unless there's a very specific reason, it should remain constant.",
              "allOf": [
                {
                  "$ref": "#/definitions/Percent"
                }
              ]
            },
            "reward_pool": {
              "description": "Current value of the rewarding pool. It is expected to be constant throughout the interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "stake_saturation_point": {
              "description": "Current value of the stake saturation point. It is expected to be constant throughout the interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "staking_supply": {
              "description": "Current value of the staking supply. It is expected to be constant throughout the interval.",
              "allOf": [
                {
                  "$ref": "#/definitions/Decimal"
                }
              ]
            },
            "staking_supply_scale_factor": {
              "description": "Defines the percentage of stake needed to reach saturation for all of the nodes in the rewarded set. Also known as `beta`.",
              "allOf": [
                {
                  "$ref": "#/definitions/Percent"
                }
              ]
            },
            "sybil_resistance": {
              "description": "Current value of the sybil resistance percent (`alpha`). It is not really expected to be changing very often. As a matter of fact, unless there's a very specific reason, it should remain constant.",
              "allOf": [
                {
                  "$ref": "#/definitions/Percent"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Percent": {
          "description": "Percent represents a value between 0 and 100% (i.e. between 0.0 and 1.0)",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        }
      }
    },
    "get_rewarding_validator_address": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "String",
      "type": "string"
    },
    "get_signing_nonce": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "uint32",
      "type": "integer",
      "format": "uint32",
      "minimum": 0.0
    },
    "get_stake_saturation": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "StakeSaturationResponse",
      "type": "object",
      "required": [
        "mix_id"
      ],
      "properties": {
        "current_saturation": {
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "mix_id": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "uncapped_saturation": {
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        }
      }
    },
    "get_state": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ContractState",
      "type": "object",
      "required": [
        "owner",
        "params",
        "rewarding_denom",
        "rewarding_validator_address",
        "vesting_contract_address"
      ],
      "properties": {
        "owner": {
          "$ref": "#/definitions/Addr"
        },
        "params": {
          "$ref": "#/definitions/ContractStateParams"
        },
        "rewarding_denom": {
          "type": "string"
        },
        "rewarding_validator_address": {
          "$ref": "#/definitions/Addr"
        },
        "vesting_contract_address": {
          "description": "Address of the vesting contract to which the mixnet contract would be sending all track-related messages.",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "ContractStateParams": {
          "type": "object",
          "required": [
            "minimum_gateway_pledge",
            "minimum_mixnode_pledge"
          ],
          "properties": {
            "minimum_gateway_pledge": {
              "description": "Minimum amount a gateway must pledge to get into the system.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "minimum_mixnode_delegation": {
              "description": "Minimum amount a delegator must stake in orders for his delegation to get accepted.",
              "anyOf": [
                {
                  "$ref": "#/definitions/Coin"
                },
                {
                  "type": "null"
                }
              ]
            },
            "minimum_mixnode_pledge": {
              "description": "Minimum amount a mixnode must pledge to get into the system.",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_state_params": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ContractStateParams",
      "type": "object",
      "required": [
        "minimum_gateway_pledge",
        "minimum_mixnode_pledge"
      ],
      "properties": {
        "minimum_gateway_pledge": {
          "description": "Minimum amount a gateway must pledge to get into the system.",
          "allOf": [
            {
              "$ref": "#/definitions/Coin"
            }
          ]
        },
        "minimum_mixnode_delegation": {
          "description": "Minimum amount a delegator must stake in orders for his delegation to get accepted.",
          "anyOf": [
            {
              "$ref": "#/definitions/Coin"
            },
            {
              "type": "null"
            }
          ]
        },
        "minimum_mixnode_pledge": {
          "description": "Minimum amount a mixnode must pledge to get into the system.",
          "allOf": [
            {
              "$ref": "#/definitions/Coin"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "get_unbonded_mix_node_information": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "UnbondedMixnodeResponse",
      "type": "object",
      "required": [
        "mix_id"
      ],
      "properties": {
        "mix_id": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "unbonded_info": {
          "anyOf": [
            {
              "$ref": "#/definitions/UnbondedMixnode"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "UnbondedMixnode": {
          "type": "object",
          "required": [
            "identity_key",
            "owner",
            "unbonding_height"
          ],
          "properties": {
            "identity_key": {
              "type": "string"
            },
            "owner": {
              "$ref": "#/definitions/Addr"
            },
            "proxy": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "unbonding_height": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      }
    },
    "get_unbonded_mix_nodes": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedUnbondedMixnodesResponse",
      "type": "object",
      "required": [
        "nodes",
        "per_page"
      ],
      "properties": {
        "nodes": {
          "type": "array",
          "items": {
            "type": "array",
            "items": [
              {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              {
                "$ref": "#/definitions/UnbondedMixnode"
              }
            ],
            "maxItems": 2,
            "minItems": 2
          }
        },
        "per_page": {
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        },
        "start_next_after": {
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "UnbondedMixnode": {
          "type": "object",
          "required": [
            "identity_key",
            "owner",
            "unbonding_height"
          ],
          "properties": {
            "identity_key": {
              "type": "string"
            },
            "owner": {
              "$ref": "#/definitions/Addr"
            },
            "proxy": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "unbonding_height": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      }
    },
    "get_unbonded_mix_nodes_by_identity_key": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedUnbondedMixnodesResponse",
      "type": "object",
      "required": [
        "nodes",
        "per_page"
      ],
      "properties": {
        "nodes": {
          "type": "array",
          "items": {
            "type": "array",
            "items": [
              {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              {
                "$ref": "#/definitions/UnbondedMixnode"
              }
            ],
            "maxItems": 2,
            "minItems": 2
          }
        },
        "per_page": {
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        },
        "start_next_after": {
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "UnbondedMixnode": {
          "type": "object",
          "required": [
            "identity_key",
            "owner",
            "unbonding_height"
          ],
          "properties": {
            "identity_key": {
              "type": "string"
            },
            "owner": {
              "$ref": "#/definitions/Addr"
            },
            "proxy": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "unbonding_height": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      }
    },
    "get_unbonded_mix_nodes_by_owner": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PagedUnbondedMixnodesResponse",
      "type": "object",
      "required": [
        "nodes",
        "per_page"
      ],
      "properties": {
        "nodes": {
          "type": "array",
          "items": {
            "type": "array",
            "items": [
              {
                "type": "integer",
                "format": "uint32",
                "minimum": 0.0
              },
              {
                "$ref": "#/definitions/UnbondedMixnode"
              }
            ],
            "maxItems": 2,
            "minItems": 2
          }
        },
        "per_page": {
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        },
        "start_next_after": {
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "UnbondedMixnode": {
          "type": "object",
          "required": [
            "identity_key",
            "owner",
            "unbonding_height"
          ],
          "properties": {
            "identity_key": {
              "type": "string"
            },
            "owner": {
              "$ref": "#/definitions/Addr"
            },
            "proxy": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Addr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "unbonding_height": {
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        }
      }
    }
  }
}
