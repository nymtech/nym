// This file is auto-generated by @hey-api/openapi-ts

import {
  type DefaultError,
  type InfiniteData,
  infiniteQueryOptions,
  queryOptions,
} from "@tanstack/react-query";
import { client as _heyApiClient } from "../client.gen";
import {
  type Options,
  buildInformation,
  gateways,
  gatewaysSkinny,
  getAllSessions,
  getEntryGatewayCountries,
  getEntryGateways,
  getEntryGatewaysByCountry,
  getExitGatewayCountries,
  getExitGateways,
  getExitGatewaysByCountry,
  getGateway,
  getGatewayCountries,
  getGateways,
  getGatewaysByCountry,
  getMixnodes,
  getStats,
  health,
  mixnodes,
  mixnodes2,
  nodeDelegations,
  nymNodes,
  summary,
  summaryHistory,
} from "../sdk.gen";
import type {
  BuildInformationData,
  GatewaysData,
  GatewaysResponse,
  GatewaysSkinnyData,
  GatewaysSkinnyResponse,
  GetAllSessionsData,
  GetAllSessionsResponse,
  GetEntryGatewayCountriesData,
  GetEntryGatewaysByCountryData,
  GetEntryGatewaysData,
  GetExitGatewayCountriesData,
  GetExitGatewaysByCountryData,
  GetExitGatewaysData,
  GetGatewayCountriesData,
  GetGatewayData,
  GetGatewaysByCountryData,
  GetGatewaysData,
  GetMixnodesData,
  GetStatsData,
  GetStatsResponse,
  HealthData,
  Mixnodes2Data,
  Mixnodes2Response,
  MixnodesData,
  MixnodesResponse,
  NodeDelegationsData,
  NymNodesData,
  NymNodesResponse,
  SummaryData,
  SummaryHistoryData,
} from "../types.gen";

export type QueryKey<TOptions extends Options> = [
  Pick<TOptions, "baseUrl" | "body" | "headers" | "path" | "query"> & {
    _id: string;
    _infinite?: boolean;
  },
];

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean,
): [QueryKey<TOptions>[0]] => {
  const params: QueryKey<TOptions>[0] = {
    _id: id,
    baseUrl: (options?.client ?? _heyApiClient).getConfig().baseUrl,
  } as QueryKey<TOptions>[0];
  if (infinite) {
    params._infinite = infinite;
  }
  if (options?.body) {
    params.body = options.body;
  }
  if (options?.headers) {
    params.headers = options.headers;
  }
  if (options?.path) {
    params.path = options.path;
  }
  if (options?.query) {
    params.query = options.query;
  }
  return [params];
};

export const getGatewaysQueryKey = (options?: Options<GetGatewaysData>) =>
  createQueryKey("getGateways", options);

/**
 * Gets available entry and exit gateways from the Nym network directory
 */
export const getGatewaysOptions = (options?: Options<GetGatewaysData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getGateways({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getGatewaysQueryKey(options),
  });
};

export const getGatewayCountriesQueryKey = (
  options?: Options<GetGatewayCountriesData>,
) => createQueryKey("getGatewayCountries", options);

/**
 * Gets available exit gateway countries as two-letter ISO country codes from the Nym network directory
 */
export const getGatewayCountriesOptions = (
  options?: Options<GetGatewayCountriesData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getGatewayCountries({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getGatewayCountriesQueryKey(options),
  });
};

export const getGatewaysByCountryQueryKey = (
  options: Options<GetGatewaysByCountryData>,
) => createQueryKey("getGatewaysByCountry", options);

/**
 * Gets available gateways from the Nym network directory by country
 */
export const getGatewaysByCountryOptions = (
  options: Options<GetGatewaysByCountryData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getGatewaysByCountry({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getGatewaysByCountryQueryKey(options),
  });
};

export const getEntryGatewaysQueryKey = (
  options?: Options<GetEntryGatewaysData>,
) => createQueryKey("getEntryGateways", options);

/**
 * Gets available entry gateways from the Nym network directory
 */
export const getEntryGatewaysOptions = (
  options?: Options<GetEntryGatewaysData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getEntryGateways({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getEntryGatewaysQueryKey(options),
  });
};

export const getEntryGatewayCountriesQueryKey = (
  options?: Options<GetEntryGatewayCountriesData>,
) => createQueryKey("getEntryGatewayCountries", options);

/**
 * Gets available entry gateway countries as two-letter ISO country codes from the Nym network directory
 */
export const getEntryGatewayCountriesOptions = (
  options?: Options<GetEntryGatewayCountriesData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getEntryGatewayCountries({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getEntryGatewayCountriesQueryKey(options),
  });
};

export const getEntryGatewaysByCountryQueryKey = (
  options: Options<GetEntryGatewaysByCountryData>,
) => createQueryKey("getEntryGatewaysByCountry", options);

/**
 * Gets available entry gateways from the Nym network directory by country
 */
export const getEntryGatewaysByCountryOptions = (
  options: Options<GetEntryGatewaysByCountryData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getEntryGatewaysByCountry({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getEntryGatewaysByCountryQueryKey(options),
  });
};

export const getExitGatewaysQueryKey = (
  options?: Options<GetExitGatewaysData>,
) => createQueryKey("getExitGateways", options);

/**
 * Gets available exit gateways from the Nym network directory
 */
export const getExitGatewaysOptions = (
  options?: Options<GetExitGatewaysData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getExitGateways({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getExitGatewaysQueryKey(options),
  });
};

export const getExitGatewayCountriesQueryKey = (
  options?: Options<GetExitGatewayCountriesData>,
) => createQueryKey("getExitGatewayCountries", options);

/**
 * Gets available exit gateway countries as two-letter ISO country codes from the Nym network directory
 */
export const getExitGatewayCountriesOptions = (
  options?: Options<GetExitGatewayCountriesData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getExitGatewayCountries({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getExitGatewayCountriesQueryKey(options),
  });
};

export const getExitGatewaysByCountryQueryKey = (
  options: Options<GetExitGatewaysByCountryData>,
) => createQueryKey("getExitGatewaysByCountry", options);

/**
 * Gets available exit gateways from the Nym network directory by country
 */
export const getExitGatewaysByCountryOptions = (
  options: Options<GetExitGatewaysByCountryData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getExitGatewaysByCountry({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getExitGatewaysByCountryQueryKey(options),
  });
};

export const nymNodesQueryKey = (options?: Options<NymNodesData>) =>
  createQueryKey("nymNodes", options);

export const nymNodesOptions = (options?: Options<NymNodesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await nymNodes({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: nymNodesQueryKey(options),
  });
};

const createInfiniteParams = <
  K extends Pick<QueryKey<Options>[0], "body" | "headers" | "path" | "query">,
>(
  queryKey: QueryKey<Options>,
  page: K,
) => {
  const params = {
    ...queryKey[0],
  };
  if (page.body) {
    params.body = {
      ...(queryKey[0].body as any),
      ...(page.body as any),
    };
  }
  if (page.headers) {
    params.headers = {
      ...queryKey[0].headers,
      ...page.headers,
    };
  }
  if (page.path) {
    params.path = {
      ...(queryKey[0].path as any),
      ...(page.path as any),
    };
  }
  if (page.query) {
    params.query = {
      ...(queryKey[0].query as any),
      ...(page.query as any),
    };
  }
  return params as unknown as typeof page;
};

export const nymNodesInfiniteQueryKey = (
  options?: Options<NymNodesData>,
): QueryKey<Options<NymNodesData>> => createQueryKey("nymNodes", options, true);

export const nymNodesInfiniteOptions = (options?: Options<NymNodesData>) => {
  return infiniteQueryOptions<
    NymNodesResponse,
    DefaultError,
    InfiniteData<NymNodesResponse>,
    QueryKey<Options<NymNodesData>>,
    | number
    | Pick<
        QueryKey<Options<NymNodesData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<NymNodesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await nymNodes({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: nymNodesInfiniteQueryKey(options),
    },
  );
};

export const nodeDelegationsQueryKey = (
  options: Options<NodeDelegationsData>,
) => createQueryKey("nodeDelegations", options);

export const nodeDelegationsOptions = (
  options: Options<NodeDelegationsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await nodeDelegations({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: nodeDelegationsQueryKey(options),
  });
};

export const gatewaysQueryKey = (options?: Options<GatewaysData>) =>
  createQueryKey("gateways", options);

export const gatewaysOptions = (options?: Options<GatewaysData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await gateways({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: gatewaysQueryKey(options),
  });
};

export const gatewaysInfiniteQueryKey = (
  options?: Options<GatewaysData>,
): QueryKey<Options<GatewaysData>> => createQueryKey("gateways", options, true);

export const gatewaysInfiniteOptions = (options?: Options<GatewaysData>) => {
  return infiniteQueryOptions<
    GatewaysResponse,
    DefaultError,
    InfiniteData<GatewaysResponse>,
    QueryKey<Options<GatewaysData>>,
    | number
    | Pick<
        QueryKey<Options<GatewaysData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GatewaysData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await gateways({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: gatewaysInfiniteQueryKey(options),
    },
  );
};

export const gatewaysSkinnyQueryKey = (options?: Options<GatewaysSkinnyData>) =>
  createQueryKey("gatewaysSkinny", options);

export const gatewaysSkinnyOptions = (
  options?: Options<GatewaysSkinnyData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await gatewaysSkinny({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: gatewaysSkinnyQueryKey(options),
  });
};

export const gatewaysSkinnyInfiniteQueryKey = (
  options?: Options<GatewaysSkinnyData>,
): QueryKey<Options<GatewaysSkinnyData>> =>
  createQueryKey("gatewaysSkinny", options, true);

export const gatewaysSkinnyInfiniteOptions = (
  options?: Options<GatewaysSkinnyData>,
) => {
  return infiniteQueryOptions<
    GatewaysSkinnyResponse,
    DefaultError,
    InfiniteData<GatewaysSkinnyResponse>,
    QueryKey<Options<GatewaysSkinnyData>>,
    | number
    | Pick<
        QueryKey<Options<GatewaysSkinnyData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GatewaysSkinnyData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await gatewaysSkinny({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: gatewaysSkinnyInfiniteQueryKey(options),
    },
  );
};

export const getGatewayQueryKey = (options: Options<GetGatewayData>) =>
  createQueryKey("getGateway", options);

export const getGatewayOptions = (options: Options<GetGatewayData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getGateway({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getGatewayQueryKey(options),
  });
};

export const getAllSessionsQueryKey = (options?: Options<GetAllSessionsData>) =>
  createQueryKey("getAllSessions", options);

export const getAllSessionsOptions = (
  options?: Options<GetAllSessionsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAllSessions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAllSessionsQueryKey(options),
  });
};

export const getAllSessionsInfiniteQueryKey = (
  options?: Options<GetAllSessionsData>,
): QueryKey<Options<GetAllSessionsData>> =>
  createQueryKey("getAllSessions", options, true);

export const getAllSessionsInfiniteOptions = (
  options?: Options<GetAllSessionsData>,
) => {
  return infiniteQueryOptions<
    GetAllSessionsResponse,
    DefaultError,
    InfiniteData<GetAllSessionsResponse>,
    QueryKey<Options<GetAllSessionsData>>,
    | number
    | Pick<
        QueryKey<Options<GetAllSessionsData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetAllSessionsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getAllSessions({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getAllSessionsInfiniteQueryKey(options),
    },
  );
};

export const mixnodesQueryKey = (options?: Options<MixnodesData>) =>
  createQueryKey("mixnodes", options);

export const mixnodesOptions = (options?: Options<MixnodesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await mixnodes({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: mixnodesQueryKey(options),
  });
};

export const mixnodesInfiniteQueryKey = (
  options?: Options<MixnodesData>,
): QueryKey<Options<MixnodesData>> => createQueryKey("mixnodes", options, true);

export const mixnodesInfiniteOptions = (options?: Options<MixnodesData>) => {
  return infiniteQueryOptions<
    MixnodesResponse,
    DefaultError,
    InfiniteData<MixnodesResponse>,
    QueryKey<Options<MixnodesData>>,
    | number
    | Pick<
        QueryKey<Options<MixnodesData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<MixnodesData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await mixnodes({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: mixnodesInfiniteQueryKey(options),
    },
  );
};

export const getStatsQueryKey = (options?: Options<GetStatsData>) =>
  createQueryKey("getStats", options);

export const getStatsOptions = (options?: Options<GetStatsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getStats({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getStatsQueryKey(options),
  });
};

export const getStatsInfiniteQueryKey = (
  options?: Options<GetStatsData>,
): QueryKey<Options<GetStatsData>> => createQueryKey("getStats", options, true);

export const getStatsInfiniteOptions = (options?: Options<GetStatsData>) => {
  return infiniteQueryOptions<
    GetStatsResponse,
    DefaultError,
    InfiniteData<GetStatsResponse>,
    QueryKey<Options<GetStatsData>>,
    | number
    | Pick<
        QueryKey<Options<GetStatsData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<GetStatsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getStats({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getStatsInfiniteQueryKey(options),
    },
  );
};

export const getMixnodesQueryKey = (options: Options<GetMixnodesData>) =>
  createQueryKey("getMixnodes", options);

export const getMixnodesOptions = (options: Options<GetMixnodesData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getMixnodes({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getMixnodesQueryKey(options),
  });
};

export const mixnodes2QueryKey = (options?: Options<Mixnodes2Data>) =>
  createQueryKey("mixnodes2", options);

export const mixnodes2Options = (options?: Options<Mixnodes2Data>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await mixnodes2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: mixnodes2QueryKey(options),
  });
};

export const mixnodes2InfiniteQueryKey = (
  options?: Options<Mixnodes2Data>,
): QueryKey<Options<Mixnodes2Data>> =>
  createQueryKey("mixnodes2", options, true);

export const mixnodes2InfiniteOptions = (options?: Options<Mixnodes2Data>) => {
  return infiniteQueryOptions<
    Mixnodes2Response,
    DefaultError,
    InfiniteData<Mixnodes2Response>,
    QueryKey<Options<Mixnodes2Data>>,
    | number
    | Pick<
        QueryKey<Options<Mixnodes2Data>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<Mixnodes2Data>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await mixnodes2({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: mixnodes2InfiniteQueryKey(options),
    },
  );
};

export const buildInformationQueryKey = (
  options?: Options<BuildInformationData>,
) => createQueryKey("buildInformation", options);

export const buildInformationOptions = (
  options?: Options<BuildInformationData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await buildInformation({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: buildInformationQueryKey(options),
  });
};

export const healthQueryKey = (options?: Options<HealthData>) =>
  createQueryKey("health", options);

export const healthOptions = (options?: Options<HealthData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await health({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: healthQueryKey(options),
  });
};

export const summaryQueryKey = (options?: Options<SummaryData>) =>
  createQueryKey("summary", options);

export const summaryOptions = (options?: Options<SummaryData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await summary({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: summaryQueryKey(options),
  });
};

export const summaryHistoryQueryKey = (options?: Options<SummaryHistoryData>) =>
  createQueryKey("summaryHistory", options);

export const summaryHistoryOptions = (
  options?: Options<SummaryHistoryData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await summaryHistory({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: summaryHistoryQueryKey(options),
  });
};
