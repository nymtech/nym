// Copyright 2020 Nym Technologies SA
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use nymsphinx::addressing::clients::Recipient;
use serde::{Deserialize, Serialize};
use std::convert::TryFrom;
use tokio_tungstenite::tungstenite::protocol::Message;

#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "type", rename_all = "camelCase")]
pub enum ClientRequest {
    Send {
        message: String,
        recipient: String,
        with_reply_surb: bool,
    },
    GetClients,
    SelfAddress,
}

impl TryFrom<String> for ClientRequest {
    type Error = serde_json::Error;

    fn try_from(msg: String) -> Result<Self, Self::Error> {
        serde_json::from_str(&msg)
    }
}

impl Into<Message> for ClientRequest {
    fn into(self) -> Message {
        let str_req = serde_json::to_string(&self).unwrap();
        Message::Text(str_req)
    }
}

pub enum BinaryClientRequest {
    Send {
        recipient: Recipient,
        data: Vec<u8>,
        with_reply_surb: bool,
    },
}

impl BinaryClientRequest {
    // TODO: perhaps do it the proper way and introduce an error type
    pub fn try_from_bytes(req: &[u8]) -> Option<Self> {
        if req.len() < Recipient::LEN + 1 {
            return None;
        }

        let with_reply_surb = match req[0] {
            n if n == 1 => true,
            n if n == 0 => false,
            n => return None, // we only 'accept' 0 or 1 byte here
        };

        let mut recipient_bytes = [0u8; Recipient::LEN];
        recipient_bytes.copy_from_slice(&req[1..Recipient::LEN + 1]);
        let recipient = Recipient::try_from_bytes(recipient_bytes).ok()?;

        Some(BinaryClientRequest::Send {
            recipient,
            data: req[1 + Recipient::LEN..].to_vec(),
            with_reply_surb,
        })
    }

    pub fn into_bytes(self) -> Vec<u8> {
        match self {
            Self::Send {
                recipient,
                data,
                with_reply_surb,
            } => std::iter::once(if with_reply_surb { 1u8 } else { 0u8 })
                .chain(recipient.into_bytes().iter().cloned())
                .chain(data.into_iter())
                .collect(),
        }
    }
}

impl Into<Message> for BinaryClientRequest {
    fn into(self) -> Message {
        Message::Binary(self.into_bytes())
    }
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "type", rename_all = "camelCase")]
pub enum ServerResponse {
    Send,
    Received { messages: Vec<String> },
    GetClients { clients: Vec<String> },
    SelfAddress { address: String },
    Error { message: String },
}

impl ServerResponse {
    pub fn new_error<S: Into<String>>(msg: S) -> Self {
        ServerResponse::Error {
            message: msg.into(),
        }
    }
}

impl TryFrom<String> for ServerResponse {
    type Error = serde_json::Error;

    fn try_from(msg: String) -> Result<Self, <ServerResponse as TryFrom<String>>::Error> {
        serde_json::from_str(&msg)
    }
}

impl Into<Message> for ServerResponse {
    fn into(self) -> Message {
        // it should be safe to call `unwrap` here as the message is generated by the server
        // so if it fails (and consequently panics) it's a bug that should be resolved
        let str_res = serde_json::to_string(&self).unwrap();
        Message::Text(str_res)
    }
}
