/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { InstantiateMsg, ExecuteMsg, FamilyHead, MessageSignature, Uint128, Percent, Decimal, PledgeCap, Coin, MixNodeCostParams, MixNodeConfigUpdate, VestingSpecification, MixNode, Gateway, GatewayConfigUpdate, QueryMsg, Timestamp, Uint64, MigrateMsg, Addr, Account, VestingPeriod, AccountsResponse, BaseVestingAccountInfo, VestingCoinsResponse, AccountVestingCoins, AllDelegationsResponse, VestingDelegation, ContractVersion, ContractBuildInformation, Period, DelegationTimesResponse, NullablePledgeData, PledgeData, OriginalVestingResponse } from "./Vesting.types";
import { GetCw2ContractVersionResponse } from './types';
export interface VestingReadOnlyInterface {
  contractAddress: string;
  getContractVersion: () => Promise<ContractBuildInformation>;
  getCw2ContractVersion: () => Promise<GetCw2ContractVersionResponse>;
  getAccountsPaged: ({
    limit,
    startNextAfter
  }: {
    limit?: number;
    startNextAfter?: string;
  }) => Promise<AccountsResponse>;
  getAccountsVestingCoinsPaged: ({
    limit,
    startNextAfter
  }: {
    limit?: number;
    startNextAfter?: string;
  }) => Promise<VestingCoinsResponse>;
  lockedCoins: ({
    blockTime,
    vestingAccountAddress
  }: {
    blockTime?: Timestamp;
    vestingAccountAddress: string;
  }) => Promise<Coin>;
  spendableCoins: ({
    blockTime,
    vestingAccountAddress
  }: {
    blockTime?: Timestamp;
    vestingAccountAddress: string;
  }) => Promise<Coin>;
  getVestedCoins: ({
    blockTime,
    vestingAccountAddress
  }: {
    blockTime?: Timestamp;
    vestingAccountAddress: string;
  }) => Promise<Coin>;
  getVestingCoins: ({
    blockTime,
    vestingAccountAddress
  }: {
    blockTime?: Timestamp;
    vestingAccountAddress: string;
  }) => Promise<Coin>;
  getStartTime: ({
    vestingAccountAddress
  }: {
    vestingAccountAddress: string;
  }) => Promise<Timestamp>;
  getEndTime: ({
    vestingAccountAddress
  }: {
    vestingAccountAddress: string;
  }) => Promise<Timestamp>;
  getOriginalVesting: ({
    vestingAccountAddress
  }: {
    vestingAccountAddress: string;
  }) => Promise<OriginalVestingResponse>;
  getHistoricalVestingStakingReward: ({
    vestingAccountAddress
  }: {
    vestingAccountAddress: string;
  }) => Promise<Coin>;
  getSpendableVestedCoins: ({
    vestingAccountAddress
  }: {
    vestingAccountAddress: string;
  }) => Promise<Coin>;
  getSpendableRewardCoins: ({
    vestingAccountAddress
  }: {
    vestingAccountAddress: string;
  }) => Promise<Coin>;
  getDelegatedCoins: ({
    vestingAccountAddress
  }: {
    vestingAccountAddress: string;
  }) => Promise<Coin>;
  getPledgedCoins: ({
    vestingAccountAddress
  }: {
    vestingAccountAddress: string;
  }) => Promise<Coin>;
  getStakedCoins: ({
    vestingAccountAddress
  }: {
    vestingAccountAddress: string;
  }) => Promise<Coin>;
  getWithdrawnCoins: ({
    vestingAccountAddress
  }: {
    vestingAccountAddress: string;
  }) => Promise<Coin>;
  getAccount: ({
    address
  }: {
    address: string;
  }) => Promise<Account>;
  getMixnode: ({
    address
  }: {
    address: string;
  }) => Promise<NullablePledgeData>;
  getGateway: ({
    address
  }: {
    address: string;
  }) => Promise<NullablePledgeData>;
  getCurrentVestingPeriod: ({
    address
  }: {
    address: string;
  }) => Promise<Period>;
  getDelegation: ({
    address,
    blockTimestampSecs,
    mixId
  }: {
    address: string;
    blockTimestampSecs: number;
    mixId: number;
  }) => Promise<VestingDelegation>;
  getTotalDelegationAmount: ({
    address,
    mixId
  }: {
    address: string;
    mixId: number;
  }) => Promise<Coin>;
  getDelegationTimes: ({
    address,
    mixId
  }: {
    address: string;
    mixId: number;
  }) => Promise<DelegationTimesResponse>;
  getAllDelegations: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number[][];
  }) => Promise<AllDelegationsResponse>;
}
export class VestingQueryClient implements VestingReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.getContractVersion = this.getContractVersion.bind(this);
    this.getCw2ContractVersion = this.getCw2ContractVersion.bind(this);
    this.getAccountsPaged = this.getAccountsPaged.bind(this);
    this.getAccountsVestingCoinsPaged = this.getAccountsVestingCoinsPaged.bind(this);
    this.lockedCoins = this.lockedCoins.bind(this);
    this.spendableCoins = this.spendableCoins.bind(this);
    this.getVestedCoins = this.getVestedCoins.bind(this);
    this.getVestingCoins = this.getVestingCoins.bind(this);
    this.getStartTime = this.getStartTime.bind(this);
    this.getEndTime = this.getEndTime.bind(this);
    this.getOriginalVesting = this.getOriginalVesting.bind(this);
    this.getHistoricalVestingStakingReward = this.getHistoricalVestingStakingReward.bind(this);
    this.getSpendableVestedCoins = this.getSpendableVestedCoins.bind(this);
    this.getSpendableRewardCoins = this.getSpendableRewardCoins.bind(this);
    this.getDelegatedCoins = this.getDelegatedCoins.bind(this);
    this.getPledgedCoins = this.getPledgedCoins.bind(this);
    this.getStakedCoins = this.getStakedCoins.bind(this);
    this.getWithdrawnCoins = this.getWithdrawnCoins.bind(this);
    this.getAccount = this.getAccount.bind(this);
    this.getMixnode = this.getMixnode.bind(this);
    this.getGateway = this.getGateway.bind(this);
    this.getCurrentVestingPeriod = this.getCurrentVestingPeriod.bind(this);
    this.getDelegation = this.getDelegation.bind(this);
    this.getTotalDelegationAmount = this.getTotalDelegationAmount.bind(this);
    this.getDelegationTimes = this.getDelegationTimes.bind(this);
    this.getAllDelegations = this.getAllDelegations.bind(this);
  }

  getContractVersion = async (): Promise<ContractBuildInformation> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_contract_version: {}
    });
  };
  getCw2ContractVersion = async (): Promise<GetCw2ContractVersionResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_cw2_contract_version: {}
    });
  };
  getAccountsPaged = async ({
    limit,
    startNextAfter
  }: {
    limit?: number;
    startNextAfter?: string;
  }): Promise<AccountsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_accounts_paged: {
        limit,
        start_next_after: startNextAfter
      }
    });
  };
  getAccountsVestingCoinsPaged = async ({
    limit,
    startNextAfter
  }: {
    limit?: number;
    startNextAfter?: string;
  }): Promise<VestingCoinsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_accounts_vesting_coins_paged: {
        limit,
        start_next_after: startNextAfter
      }
    });
  };
  lockedCoins = async ({
    blockTime,
    vestingAccountAddress
  }: {
    blockTime?: Timestamp;
    vestingAccountAddress: string;
  }): Promise<Coin> => {
    return this.client.queryContractSmart(this.contractAddress, {
      locked_coins: {
        block_time: blockTime,
        vesting_account_address: vestingAccountAddress
      }
    });
  };
  spendableCoins = async ({
    blockTime,
    vestingAccountAddress
  }: {
    blockTime?: Timestamp;
    vestingAccountAddress: string;
  }): Promise<Coin> => {
    return this.client.queryContractSmart(this.contractAddress, {
      spendable_coins: {
        block_time: blockTime,
        vesting_account_address: vestingAccountAddress
      }
    });
  };
  getVestedCoins = async ({
    blockTime,
    vestingAccountAddress
  }: {
    blockTime?: Timestamp;
    vestingAccountAddress: string;
  }): Promise<Coin> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_vested_coins: {
        block_time: blockTime,
        vesting_account_address: vestingAccountAddress
      }
    });
  };
  getVestingCoins = async ({
    blockTime,
    vestingAccountAddress
  }: {
    blockTime?: Timestamp;
    vestingAccountAddress: string;
  }): Promise<Coin> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_vesting_coins: {
        block_time: blockTime,
        vesting_account_address: vestingAccountAddress
      }
    });
  };
  getStartTime = async ({
    vestingAccountAddress
  }: {
    vestingAccountAddress: string;
  }): Promise<Timestamp> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_start_time: {
        vesting_account_address: vestingAccountAddress
      }
    });
  };
  getEndTime = async ({
    vestingAccountAddress
  }: {
    vestingAccountAddress: string;
  }): Promise<Timestamp> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_end_time: {
        vesting_account_address: vestingAccountAddress
      }
    });
  };
  getOriginalVesting = async ({
    vestingAccountAddress
  }: {
    vestingAccountAddress: string;
  }): Promise<OriginalVestingResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_original_vesting: {
        vesting_account_address: vestingAccountAddress
      }
    });
  };
  getHistoricalVestingStakingReward = async ({
    vestingAccountAddress
  }: {
    vestingAccountAddress: string;
  }): Promise<Coin> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_historical_vesting_staking_reward: {
        vesting_account_address: vestingAccountAddress
      }
    });
  };
  getSpendableVestedCoins = async ({
    vestingAccountAddress
  }: {
    vestingAccountAddress: string;
  }): Promise<Coin> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_spendable_vested_coins: {
        vesting_account_address: vestingAccountAddress
      }
    });
  };
  getSpendableRewardCoins = async ({
    vestingAccountAddress
  }: {
    vestingAccountAddress: string;
  }): Promise<Coin> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_spendable_reward_coins: {
        vesting_account_address: vestingAccountAddress
      }
    });
  };
  getDelegatedCoins = async ({
    vestingAccountAddress
  }: {
    vestingAccountAddress: string;
  }): Promise<Coin> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_delegated_coins: {
        vesting_account_address: vestingAccountAddress
      }
    });
  };
  getPledgedCoins = async ({
    vestingAccountAddress
  }: {
    vestingAccountAddress: string;
  }): Promise<Coin> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_pledged_coins: {
        vesting_account_address: vestingAccountAddress
      }
    });
  };
  getStakedCoins = async ({
    vestingAccountAddress
  }: {
    vestingAccountAddress: string;
  }): Promise<Coin> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_staked_coins: {
        vesting_account_address: vestingAccountAddress
      }
    });
  };
  getWithdrawnCoins = async ({
    vestingAccountAddress
  }: {
    vestingAccountAddress: string;
  }): Promise<Coin> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_withdrawn_coins: {
        vesting_account_address: vestingAccountAddress
      }
    });
  };
  getAccount = async ({
    address
  }: {
    address: string;
  }): Promise<Account> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_account: {
        address
      }
    });
  };
  getMixnode = async ({
    address
  }: {
    address: string;
  }): Promise<NullablePledgeData> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_mixnode: {
        address
      }
    });
  };
  getGateway = async ({
    address
  }: {
    address: string;
  }): Promise<NullablePledgeData> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_gateway: {
        address
      }
    });
  };
  getCurrentVestingPeriod = async ({
    address
  }: {
    address: string;
  }): Promise<Period> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_current_vesting_period: {
        address
      }
    });
  };
  getDelegation = async ({
    address,
    blockTimestampSecs,
    mixId
  }: {
    address: string;
    blockTimestampSecs: number;
    mixId: number;
  }): Promise<VestingDelegation> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_delegation: {
        address,
        block_timestamp_secs: blockTimestampSecs,
        mix_id: mixId
      }
    });
  };
  getTotalDelegationAmount = async ({
    address,
    mixId
  }: {
    address: string;
    mixId: number;
  }): Promise<Coin> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_total_delegation_amount: {
        address,
        mix_id: mixId
      }
    });
  };
  getDelegationTimes = async ({
    address,
    mixId
  }: {
    address: string;
    mixId: number;
  }): Promise<DelegationTimesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_delegation_times: {
        address,
        mix_id: mixId
      }
    });
  };
  getAllDelegations = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number[][];
  }): Promise<AllDelegationsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_all_delegations: {
        limit,
        start_after: startAfter
      }
    });
  };
}
export interface VestingInterface extends VestingReadOnlyInterface {
  contractAddress: string;
  sender: string;
  createFamily: ({
    label
  }: {
    label: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  joinFamily: ({
    familyHead,
    joinPermit
  }: {
    familyHead: FamilyHead;
    joinPermit: MessageSignature;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  leaveFamily: ({
    familyHead
  }: {
    familyHead: FamilyHead;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  kickFamilyMember: ({
    member
  }: {
    member: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  trackReward: ({
    address,
    amount
  }: {
    address: string;
    amount: Coin;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  claimOperatorReward: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  claimDelegatorReward: ({
    mixId
  }: {
    mixId: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateMixnodeCostParams: ({
    newCosts
  }: {
    newCosts: MixNodeCostParams;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateMixnodeConfig: ({
    newConfig
  }: {
    newConfig: MixNodeConfigUpdate;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateMixnetAddress: ({
    address
  }: {
    address: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  delegateToMixnode: ({
    amount,
    mixId,
    onBehalfOf
  }: {
    amount: Coin;
    mixId: number;
    onBehalfOf?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  undelegateFromMixnode: ({
    mixId,
    onBehalfOf
  }: {
    mixId: number;
    onBehalfOf?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  createAccount: ({
    cap,
    ownerAddress,
    stakingAddress,
    vestingSpec
  }: {
    cap?: PledgeCap;
    ownerAddress: string;
    stakingAddress?: string;
    vestingSpec?: VestingSpecification;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdrawVestedCoins: ({
    amount
  }: {
    amount: Coin;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  trackUndelegation: ({
    amount,
    mixId,
    owner
  }: {
    amount: Coin;
    mixId: number;
    owner: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  bondMixnode: ({
    amount,
    costParams,
    mixNode,
    ownerSignature
  }: {
    amount: Coin;
    costParams: MixNodeCostParams;
    mixNode: MixNode;
    ownerSignature: MessageSignature;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  pledgeMore: ({
    amount
  }: {
    amount: Coin;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  decreasePledge: ({
    amount
  }: {
    amount: Coin;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  unbondMixnode: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  trackUnbondMixnode: ({
    amount,
    owner
  }: {
    amount: Coin;
    owner: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  trackDecreasePledge: ({
    amount,
    owner
  }: {
    amount: Coin;
    owner: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  bondGateway: ({
    amount,
    gateway,
    ownerSignature
  }: {
    amount: Coin;
    gateway: Gateway;
    ownerSignature: MessageSignature;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  unbondGateway: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  trackUnbondGateway: ({
    amount,
    owner
  }: {
    amount: Coin;
    owner: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateGatewayConfig: ({
    newConfig
  }: {
    newConfig: GatewayConfigUpdate;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  transferOwnership: ({
    toAddress
  }: {
    toAddress: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateStakingAddress: ({
    toAddress
  }: {
    toAddress?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateLockedPledgeCap: ({
    address,
    cap
  }: {
    address: string;
    cap: PledgeCap;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class VestingClient extends VestingQueryClient implements VestingInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.createFamily = this.createFamily.bind(this);
    this.joinFamily = this.joinFamily.bind(this);
    this.leaveFamily = this.leaveFamily.bind(this);
    this.kickFamilyMember = this.kickFamilyMember.bind(this);
    this.trackReward = this.trackReward.bind(this);
    this.claimOperatorReward = this.claimOperatorReward.bind(this);
    this.claimDelegatorReward = this.claimDelegatorReward.bind(this);
    this.updateMixnodeCostParams = this.updateMixnodeCostParams.bind(this);
    this.updateMixnodeConfig = this.updateMixnodeConfig.bind(this);
    this.updateMixnetAddress = this.updateMixnetAddress.bind(this);
    this.delegateToMixnode = this.delegateToMixnode.bind(this);
    this.undelegateFromMixnode = this.undelegateFromMixnode.bind(this);
    this.createAccount = this.createAccount.bind(this);
    this.withdrawVestedCoins = this.withdrawVestedCoins.bind(this);
    this.trackUndelegation = this.trackUndelegation.bind(this);
    this.bondMixnode = this.bondMixnode.bind(this);
    this.pledgeMore = this.pledgeMore.bind(this);
    this.decreasePledge = this.decreasePledge.bind(this);
    this.unbondMixnode = this.unbondMixnode.bind(this);
    this.trackUnbondMixnode = this.trackUnbondMixnode.bind(this);
    this.trackDecreasePledge = this.trackDecreasePledge.bind(this);
    this.bondGateway = this.bondGateway.bind(this);
    this.unbondGateway = this.unbondGateway.bind(this);
    this.trackUnbondGateway = this.trackUnbondGateway.bind(this);
    this.updateGatewayConfig = this.updateGatewayConfig.bind(this);
    this.transferOwnership = this.transferOwnership.bind(this);
    this.updateStakingAddress = this.updateStakingAddress.bind(this);
    this.updateLockedPledgeCap = this.updateLockedPledgeCap.bind(this);
  }

  createFamily = async ({
    label
  }: {
    label: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_family: {
        label
      }
    }, fee, memo, _funds);
  };
  joinFamily = async ({
    familyHead,
    joinPermit
  }: {
    familyHead: FamilyHead;
    joinPermit: MessageSignature;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      join_family: {
        family_head: familyHead,
        join_permit: joinPermit
      }
    }, fee, memo, _funds);
  };
  leaveFamily = async ({
    familyHead
  }: {
    familyHead: FamilyHead;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      leave_family: {
        family_head: familyHead
      }
    }, fee, memo, _funds);
  };
  kickFamilyMember = async ({
    member
  }: {
    member: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      kick_family_member: {
        member
      }
    }, fee, memo, _funds);
  };
  trackReward = async ({
    address,
    amount
  }: {
    address: string;
    amount: Coin;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      track_reward: {
        address,
        amount
      }
    }, fee, memo, _funds);
  };
  claimOperatorReward = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      claim_operator_reward: {}
    }, fee, memo, _funds);
  };
  claimDelegatorReward = async ({
    mixId
  }: {
    mixId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      claim_delegator_reward: {
        mix_id: mixId
      }
    }, fee, memo, _funds);
  };
  updateMixnodeCostParams = async ({
    newCosts
  }: {
    newCosts: MixNodeCostParams;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_mixnode_cost_params: {
        new_costs: newCosts
      }
    }, fee, memo, _funds);
  };
  updateMixnodeConfig = async ({
    newConfig
  }: {
    newConfig: MixNodeConfigUpdate;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_mixnode_config: {
        new_config: newConfig
      }
    }, fee, memo, _funds);
  };
  updateMixnetAddress = async ({
    address
  }: {
    address: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_mixnet_address: {
        address
      }
    }, fee, memo, _funds);
  };
  delegateToMixnode = async ({
    amount,
    mixId,
    onBehalfOf
  }: {
    amount: Coin;
    mixId: number;
    onBehalfOf?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      delegate_to_mixnode: {
        amount,
        mix_id: mixId,
        on_behalf_of: onBehalfOf
      }
    }, fee, memo, _funds);
  };
  undelegateFromMixnode = async ({
    mixId,
    onBehalfOf
  }: {
    mixId: number;
    onBehalfOf?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      undelegate_from_mixnode: {
        mix_id: mixId,
        on_behalf_of: onBehalfOf
      }
    }, fee, memo, _funds);
  };
  createAccount = async ({
    cap,
    ownerAddress,
    stakingAddress,
    vestingSpec
  }: {
    cap?: PledgeCap;
    ownerAddress: string;
    stakingAddress?: string;
    vestingSpec?: VestingSpecification;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_account: {
        cap,
        owner_address: ownerAddress,
        staking_address: stakingAddress,
        vesting_spec: vestingSpec
      }
    }, fee, memo, _funds);
  };
  withdrawVestedCoins = async ({
    amount
  }: {
    amount: Coin;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_vested_coins: {
        amount
      }
    }, fee, memo, _funds);
  };
  trackUndelegation = async ({
    amount,
    mixId,
    owner
  }: {
    amount: Coin;
    mixId: number;
    owner: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      track_undelegation: {
        amount,
        mix_id: mixId,
        owner
      }
    }, fee, memo, _funds);
  };
  bondMixnode = async ({
    amount,
    costParams,
    mixNode,
    ownerSignature
  }: {
    amount: Coin;
    costParams: MixNodeCostParams;
    mixNode: MixNode;
    ownerSignature: MessageSignature;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      bond_mixnode: {
        amount,
        cost_params: costParams,
        mix_node: mixNode,
        owner_signature: ownerSignature
      }
    }, fee, memo, _funds);
  };
  pledgeMore = async ({
    amount
  }: {
    amount: Coin;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      pledge_more: {
        amount
      }
    }, fee, memo, _funds);
  };
  decreasePledge = async ({
    amount
  }: {
    amount: Coin;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      decrease_pledge: {
        amount
      }
    }, fee, memo, _funds);
  };
  unbondMixnode = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unbond_mixnode: {}
    }, fee, memo, _funds);
  };
  trackUnbondMixnode = async ({
    amount,
    owner
  }: {
    amount: Coin;
    owner: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      track_unbond_mixnode: {
        amount,
        owner
      }
    }, fee, memo, _funds);
  };
  trackDecreasePledge = async ({
    amount,
    owner
  }: {
    amount: Coin;
    owner: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      track_decrease_pledge: {
        amount,
        owner
      }
    }, fee, memo, _funds);
  };
  bondGateway = async ({
    amount,
    gateway,
    ownerSignature
  }: {
    amount: Coin;
    gateway: Gateway;
    ownerSignature: MessageSignature;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      bond_gateway: {
        amount,
        gateway,
        owner_signature: ownerSignature
      }
    }, fee, memo, _funds);
  };
  unbondGateway = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unbond_gateway: {}
    }, fee, memo, _funds);
  };
  trackUnbondGateway = async ({
    amount,
    owner
  }: {
    amount: Coin;
    owner: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      track_unbond_gateway: {
        amount,
        owner
      }
    }, fee, memo, _funds);
  };
  updateGatewayConfig = async ({
    newConfig
  }: {
    newConfig: GatewayConfigUpdate;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_gateway_config: {
        new_config: newConfig
      }
    }, fee, memo, _funds);
  };
  transferOwnership = async ({
    toAddress
  }: {
    toAddress: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      transfer_ownership: {
        to_address: toAddress
      }
    }, fee, memo, _funds);
  };
  updateStakingAddress = async ({
    toAddress
  }: {
    toAddress?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_staking_address: {
        to_address: toAddress
      }
    }, fee, memo, _funds);
  };
  updateLockedPledgeCap = async ({
    address,
    cap
  }: {
    address: string;
    cap: PledgeCap;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_locked_pledge_cap: {
        address,
        cap
      }
    }, fee, memo, _funds);
  };
}
