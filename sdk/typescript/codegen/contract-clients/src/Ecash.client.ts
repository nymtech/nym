/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.13.3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { ICosmWasmClient, ISigningCosmWasmClient } from "./baseClient";
import { StdFee } from "@interchainjs/types";
import { Uint128, InstantiateMsg, Coin, ExecuteMsg, QueryMsg, MigrateMsg, PagedBlacklistedAccountResponse, BlacklistedAccount, Blacklisting, BlacklistedAccountResponse, DepositResponse, Deposit, PagedDepositsResponse, DepositData, LatestDepositResponse } from "./Ecash.types";
export interface EcashReadOnlyInterface {
  contractAddress: string;
  getBlacklistedAccount: ({
    publicKey
  }: {
    publicKey: string;
  }) => Promise<BlacklistedAccountResponse>;
  getBlacklistPaged: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<PagedBlacklistedAccountResponse>;
  getRequiredDepositAmount: () => Promise<Coin>;
  getDeposit: ({
    depositId
  }: {
    depositId: number;
  }) => Promise<DepositResponse>;
  getLatestDeposit: () => Promise<LatestDepositResponse>;
  getDepositsPaged: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<PagedDepositsResponse>;
}
export class EcashQueryClient implements EcashReadOnlyInterface {
  client: ICosmWasmClient;
  contractAddress: string;
  constructor(client: ICosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.getBlacklistedAccount = this.getBlacklistedAccount.bind(this);
    this.getBlacklistPaged = this.getBlacklistPaged.bind(this);
    this.getRequiredDepositAmount = this.getRequiredDepositAmount.bind(this);
    this.getDeposit = this.getDeposit.bind(this);
    this.getLatestDeposit = this.getLatestDeposit.bind(this);
    this.getDepositsPaged = this.getDepositsPaged.bind(this);
  }
  getBlacklistedAccount = async ({
    publicKey
  }: {
    publicKey: string;
  }): Promise<BlacklistedAccountResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_blacklisted_account: {
        public_key: publicKey
      }
    });
  };
  getBlacklistPaged = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<PagedBlacklistedAccountResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_blacklist_paged: {
        limit,
        start_after: startAfter
      }
    });
  };
  getRequiredDepositAmount = async (): Promise<Coin> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_required_deposit_amount: {}
    });
  };
  getDeposit = async ({
    depositId
  }: {
    depositId: number;
  }): Promise<DepositResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_deposit: {
        deposit_id: depositId
      }
    });
  };
  getLatestDeposit = async (): Promise<LatestDepositResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_latest_deposit: {}
    });
  };
  getDepositsPaged = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<PagedDepositsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_deposits_paged: {
        limit,
        start_after: startAfter
      }
    });
  };
}
export interface EcashInterface extends EcashReadOnlyInterface {
  contractAddress: string;
  sender: string;
  depositTicketBookFunds: ({
    identityKey
  }: {
    identityKey: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  requestRedemption: ({
    commitmentBs58,
    numberOfTickets
  }: {
    commitmentBs58: string;
    numberOfTickets: number;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  redeemTickets: ({
    gw,
    n
  }: {
    gw: string;
    n: number;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  updateAdmin: ({
    admin
  }: {
    admin: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  updateDepositValue: ({
    newDeposit
  }: {
    newDeposit: Coin;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  proposeToBlacklist: ({
    publicKey
  }: {
    publicKey: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  addToBlacklist: ({
    publicKey
  }: {
    publicKey: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
}
export class EcashClient extends EcashQueryClient implements EcashInterface {
  client: ISigningCosmWasmClient;
  sender: string;
  contractAddress: string;
  constructor(client: ISigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.depositTicketBookFunds = this.depositTicketBookFunds.bind(this);
    this.requestRedemption = this.requestRedemption.bind(this);
    this.redeemTickets = this.redeemTickets.bind(this);
    this.updateAdmin = this.updateAdmin.bind(this);
    this.updateDepositValue = this.updateDepositValue.bind(this);
    this.proposeToBlacklist = this.proposeToBlacklist.bind(this);
    this.addToBlacklist = this.addToBlacklist.bind(this);
  }
  depositTicketBookFunds = async ({
    identityKey
  }: {
    identityKey: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      deposit_ticket_book_funds: {
        identity_key: identityKey
      }
    }, fee_, memo_, funds_);
  };
  requestRedemption = async ({
    commitmentBs58,
    numberOfTickets
  }: {
    commitmentBs58: string;
    numberOfTickets: number;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      request_redemption: {
        commitment_bs58: commitmentBs58,
        number_of_tickets: numberOfTickets
      }
    }, fee_, memo_, funds_);
  };
  redeemTickets = async ({
    gw,
    n
  }: {
    gw: string;
    n: number;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      redeem_tickets: {
        gw,
        n
      }
    }, fee_, memo_, funds_);
  };
  updateAdmin = async ({
    admin
  }: {
    admin: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_admin: {
        admin
      }
    }, fee_, memo_, funds_);
  };
  updateDepositValue = async ({
    newDeposit
  }: {
    newDeposit: Coin;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_deposit_value: {
        new_deposit: newDeposit
      }
    }, fee_, memo_, funds_);
  };
  proposeToBlacklist = async ({
    publicKey
  }: {
    publicKey: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      propose_to_blacklist: {
        public_key: publicKey
      }
    }, fee_, memo_, funds_);
  };
  addToBlacklist = async ({
    publicKey
  }: {
    publicKey: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_to_blacklist: {
        public_key: publicKey
      }
    }, fee_, memo_, funds_);
  };
}