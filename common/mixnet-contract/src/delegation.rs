// due to code generated by JsonSchema
#![allow(clippy::field_reassign_with_default)]

use crate::{Addr, IdentityKey};
use cosmwasm_std::{Coin, Uint128};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use std::fmt::Display;

#[derive(Clone, Debug, Deserialize, PartialEq, Serialize, JsonSchema)]
pub struct UnpackedDelegation<T> {
    pub owner: Addr,
    pub node_identity: IdentityKey,
    pub delegation_data: T, // proxy address used to delegate the funds on behalf of anouther address
}

impl<T> UnpackedDelegation<T> {
    pub fn new(owner: Addr, node_identity: IdentityKey, delegation_data: T) -> Self {
        UnpackedDelegation {
            owner,
            node_identity,
            delegation_data,
        }
    }
}

#[derive(Clone, Debug, Deserialize, PartialEq, Serialize, JsonSchema)]
pub struct RawDelegationData {
    pub amount: Uint128,
    pub block_height: u64,
    pub proxy_address: Option<Addr> // proxy address used to delegate the funds on behalf of anouther address
}

impl RawDelegationData {
    pub fn new(amount: Uint128, block_height: u64, proxy_address: Option<Addr>) -> Self {
        RawDelegationData {
            amount,
            block_height,
            proxy_address
        }
    }
}

#[derive(Clone, Debug, Deserialize, PartialEq, Serialize, JsonSchema)]
pub struct Delegation {
    owner: Addr,
    amount: Coin,
    block_height: u64,
}

impl Delegation {
    pub fn new(owner: Addr, amount: Coin, block_height: u64) -> Self {
        Delegation {
            owner,
            amount,
            block_height,
        }
    }

    pub fn amount(&self) -> &Coin {
        &self.amount
    }

    pub fn owner(&self) -> Addr {
        self.owner.clone()
    }

    pub fn block_height(&self) -> u64 {
        self.block_height
    }
}

impl Display for Delegation {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(
            f,
            "{} {} delegated by {} at block {}",
            self.amount.amount, self.amount.denom, self.owner, self.block_height
        )
    }
}

#[derive(Clone, Debug, Deserialize, PartialEq, Serialize, JsonSchema)]
pub struct PagedMixDelegationsResponse {
    pub node_identity: IdentityKey,
    pub delegations: Vec<Delegation>,
    pub start_next_after: Option<Addr>,
}

impl PagedMixDelegationsResponse {
    pub fn new(
        node_identity: IdentityKey,
        delegations: Vec<Delegation>,
        start_next_after: Option<Addr>,
    ) -> Self {
        PagedMixDelegationsResponse {
            node_identity,
            delegations,
            start_next_after,
        }
    }
}

#[derive(Clone, Debug, Deserialize, PartialEq, Serialize, JsonSchema)]
pub struct PagedReverseMixDelegationsResponse {
    pub delegation_owner: Addr,
    pub delegated_nodes: Vec<IdentityKey>,
    pub start_next_after: Option<IdentityKey>,
}

impl PagedReverseMixDelegationsResponse {
    pub fn new(
        delegation_owner: Addr,
        delegated_nodes: Vec<IdentityKey>,
        start_next_after: Option<IdentityKey>,
    ) -> Self {
        PagedReverseMixDelegationsResponse {
            delegation_owner,
            delegated_nodes,
            start_next_after,
        }
    }
}

#[derive(Clone, Debug, Deserialize, PartialEq, Serialize, JsonSchema)]
pub struct PagedAllDelegationsResponse<T> {
    pub delegations: Vec<UnpackedDelegation<T>>,
    pub start_next_after: Option<Vec<u8>>,
}

impl<T> PagedAllDelegationsResponse<T> {
    pub fn new(delegations: Vec<UnpackedDelegation<T>>, start_next_after: Option<Vec<u8>>) -> Self {
        PagedAllDelegationsResponse {
            delegations,
            start_next_after,
        }
    }
}
