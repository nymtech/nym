/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.13.3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/


import { StdFee, Coin } from '@interchainjs/types';
import { DirectSigner } from '@interchainjs/cosmos';
import { getSmartContractState } from 'interchainjs/cosmwasm/wasm/v1/query.rpc.func';
import { executeContract } from 'interchainjs/cosmwasm/wasm/v1/tx.rpc.func';
import { QuerySmartContractStateRequest, QuerySmartContractStateResponse } from 'interchainjs/cosmwasm/wasm/v1/query';
import { MsgExecuteContract } from 'interchainjs/cosmwasm/wasm/v1/tx';
import { Chain } from '@chain-registry/v2-types';

// Encoding utility functions
const fromUint8Array = <T>(uint8Array: Uint8Array): T => {
  const text = new TextDecoder().decode(uint8Array);
  return JSON.parse(text);
};

const toUint8Array = (obj: any): Uint8Array => {
  const text = JSON.stringify(obj);
  return new TextEncoder().encode(text);
};

// Chain registry configuration
// The amount under gasPrice represents gas price per unit
export interface ChainConfig {
  chain?: Chain;
  gasPrice?: {
    denom: string;
    amount: string;
  };
}

// Gas fee calculation utilities
export const calculateGasFromChain = (chain: Chain, gasAmount: string): StdFee => {
  try {
    const feeTokens = chain.fees?.feeTokens;
    
    if (feeTokens && feeTokens.length > 0) {
      const primaryToken = feeTokens[0];
      // v2 chain-registry uses camelCase: averageGasPrice, lowGasPrice, fixedMinGasPrice
      const gasPrice = primaryToken.averageGasPrice || primaryToken.lowGasPrice || primaryToken.fixedMinGasPrice || 0.025;
      const gasAmountNum = parseInt(gasAmount);
      const feeAmount = Math.ceil(gasAmountNum * gasPrice).toString();
      
      return {
        amount: [{
          denom: primaryToken.denom,
          amount: feeAmount
        }],
        gas: gasAmount
      };
    }
  } catch (error) {
    console.warn('Failed to calculate gas from chain registry:', error);
  }
  
  // Fallback to default
  return { amount: [], gas: gasAmount };
};

// Default gas amount - users can easily change this
export let DEFAULT_GAS_AMOUNT = '200000';

// Allow users to set their preferred default gas amount
export const setDefaultGasAmount = (gasAmount: string): void => {
  DEFAULT_GAS_AMOUNT = gasAmount;
};

// Get current default gas amount
export const getDefaultGasAmount = (): string => DEFAULT_GAS_AMOUNT;

export const getAutoGasFee = (chainConfig?: ChainConfig): StdFee => {
  const gasAmount = DEFAULT_GAS_AMOUNT;
  
  if (chainConfig?.chain) {
    return calculateGasFromChain(chainConfig.chain, gasAmount);
  }
  
  if (chainConfig?.gasPrice) {
    const gasAmountNum = parseInt(gasAmount);
    const gasPriceNum = parseFloat(chainConfig.gasPrice.amount);
    const feeAmount = Math.ceil(gasAmountNum * gasPriceNum).toString();
    
    return {
      amount: [{
        denom: chainConfig.gasPrice.denom,
        amount: feeAmount
      }],
      gas: gasAmount
    };
  }
  
  // Fallback: no fee tokens, just gas amount
  return { amount: [], gas: gasAmount };
};

// InterchainJS interfaces for CosmWasm clients
export interface ICosmWasmClient {
  queryContractSmart(contractAddr: string, query: any): Promise<any>;
}

export interface ISigningCosmWasmClient extends ICosmWasmClient {
  execute(
    sender: string, 
    contractAddress: string, 
    msg: any, 
    fee?: number | StdFee | "auto", 
    memo?: string, 
    funds?: Coin[], 
    chainConfig?: ChainConfig
  ): Promise<any>;
}

export interface ISigningClient {
  signAndBroadcast(
    signerAddress: string,
    messages: any[],
    fee: number | StdFee | "auto",
    memo?: string
  ): Promise<any>;
}

// Helper functions to create InterchainJS clients
export function getCosmWasmClient(rpcEndpoint: string): ICosmWasmClient {
  return {
    queryContractSmart: async (contractAddr: string, query: any) => {
      // Create the request object
      const request: QuerySmartContractStateRequest = {
        address: contractAddr,
        queryData: toUint8Array(query)
      };
      
      // Execute the query using InterchainJS
      const response: QuerySmartContractStateResponse = await getSmartContractState(rpcEndpoint, request);
      
      // Parse and return the result
      return fromUint8Array(response.data);
    },
  };
}

export function getSigningCosmWasmClient(signingClient: DirectSigner, rpcEndpoint?: string): ISigningCosmWasmClient {
  return {
    queryContractSmart: async (contractAddr: string, query: any) => {
      if (!rpcEndpoint) {
        throw new Error('rpcEndpoint is required for queryContractSmart in signing client');
      }
      const request: QuerySmartContractStateRequest = {
        address: contractAddr,
        queryData: toUint8Array(query)
      };
      const response: QuerySmartContractStateResponse = await getSmartContractState(rpcEndpoint, request);
      return fromUint8Array(response.data);
    },
    execute: async (
      sender: string, 
      contractAddress: string, 
      msg: any, 
      fee?: number | StdFee | "auto", 
      memo?: string, 
      funds?: Coin[], 
      chainConfig?: ChainConfig
    ) => {
      // Handle fee conversion
      let finalFee: StdFee;
      if (typeof fee === 'number') {
        finalFee = { amount: [], gas: fee.toString() };
      } else if (fee === 'auto') {
        finalFee = getAutoGasFee(chainConfig);
      } else if (fee) {
        finalFee = fee;
      } else {
        finalFee = getAutoGasFee(chainConfig);
      }

      // Create the message object
      const message: MsgExecuteContract = {
        sender,
        contract: contractAddress,
        msg: toUint8Array(msg),
        funds: funds || []
      };
      
      // Execute the transaction using InterchainJS
      const result = await executeContract(
        signingClient as any,
        sender,
        message,
        finalFee,
        memo || ''
      );
      
      return result;
    },
  };
}
