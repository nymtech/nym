/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.13.3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { ICosmWasmClient, ISigningCosmWasmClient } from "./baseClient";
import { Coin, StdFee } from "@interchainjs/types";
import { InstantiateMsg, TimeConfiguration, ExecuteMsg, ContractSafeBytes, DealingChunkInfo, PartialContractDealing, QueryMsg, MigrateMsg, EpochState, Timestamp, Uint64, StateAdvanceResponse, StateProgress, ContractVersion, Addr, PagedDealerResponse, DealerDetails, Epoch, DealerDealingsStatusResponse, DealerType, DealerDetailsResponse, PagedDealerIndexResponse, DealingChunkResponse, DealingChunkStatusResponse, ChunkSubmissionStatus, DealingStatusResponse, DealingStatus, DealingMetadataResponse, DealingMetadata, PagedDealerAddressesResponse, NullableEpoch, RegisteredDealerDetails, DealerRegistrationDetails, Cw4Contract, State, VkShareResponse, ContractVKShare, PagedVKSharesResponse } from "./CoconutDkg.types";
export interface CoconutDkgReadOnlyInterface {
  contractAddress: string;
  getState: () => Promise<State>;
  getCurrentEpochState: () => Promise<Epoch>;
  getEpochStateAtHeight: ({
    height
  }: {
    height: number;
  }) => Promise<NullableEpoch>;
  getCurrentEpochThreshold: () => Promise<Uint64>;
  getEpochThreshold: ({
    epochId
  }: {
    epochId: number;
  }) => Promise<Uint64>;
  canAdvanceState: () => Promise<StateAdvanceResponse>;
  getRegisteredDealer: ({
    dealerAddress,
    epochId
  }: {
    dealerAddress: string;
    epochId?: number;
  }) => Promise<RegisteredDealerDetails>;
  getDealerDetails: ({
    dealerAddress
  }: {
    dealerAddress: string;
  }) => Promise<DealerDetailsResponse>;
  getEpochDealersAddresses: ({
    epochId,
    limit,
    startAfter
  }: {
    epochId: number;
    limit?: number;
    startAfter?: string;
  }) => Promise<PagedDealerAddressesResponse>;
  getEpochDealers: ({
    epochId,
    limit,
    startAfter
  }: {
    epochId: number;
    limit?: number;
    startAfter?: string;
  }) => Promise<PagedDealerResponse>;
  getCurrentDealers: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<PagedDealerResponse>;
  getDealerIndices: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<PagedDealerIndexResponse>;
  getDealingsMetadata: ({
    dealer,
    dealingIndex,
    epochId
  }: {
    dealer: string;
    dealingIndex: number;
    epochId: number;
  }) => Promise<DealingMetadataResponse>;
  getDealerDealingsStatus: ({
    dealer,
    epochId
  }: {
    dealer: string;
    epochId: number;
  }) => Promise<DealerDealingsStatusResponse>;
  getDealingStatus: ({
    dealer,
    dealingIndex,
    epochId
  }: {
    dealer: string;
    dealingIndex: number;
    epochId: number;
  }) => Promise<DealingStatusResponse>;
  getDealingChunkStatus: ({
    chunkIndex,
    dealer,
    dealingIndex,
    epochId
  }: {
    chunkIndex: number;
    dealer: string;
    dealingIndex: number;
    epochId: number;
  }) => Promise<DealingChunkStatusResponse>;
  getDealingChunk: ({
    chunkIndex,
    dealer,
    dealingIndex,
    epochId
  }: {
    chunkIndex: number;
    dealer: string;
    dealingIndex: number;
    epochId: number;
  }) => Promise<DealingChunkResponse>;
  getVerificationKey: ({
    epochId,
    owner
  }: {
    epochId: number;
    owner: string;
  }) => Promise<VkShareResponse>;
  getVerificationKeys: ({
    epochId,
    limit,
    startAfter
  }: {
    epochId: number;
    limit?: number;
    startAfter?: string;
  }) => Promise<PagedVKSharesResponse>;
  getCw2ContractVersion: () => Promise<GetCw2ContractVersionResponse>;
}
export class CoconutDkgQueryClient implements CoconutDkgReadOnlyInterface {
  client: ICosmWasmClient;
  contractAddress: string;
  constructor(client: ICosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.getState = this.getState.bind(this);
    this.getCurrentEpochState = this.getCurrentEpochState.bind(this);
    this.getEpochStateAtHeight = this.getEpochStateAtHeight.bind(this);
    this.getCurrentEpochThreshold = this.getCurrentEpochThreshold.bind(this);
    this.getEpochThreshold = this.getEpochThreshold.bind(this);
    this.canAdvanceState = this.canAdvanceState.bind(this);
    this.getRegisteredDealer = this.getRegisteredDealer.bind(this);
    this.getDealerDetails = this.getDealerDetails.bind(this);
    this.getEpochDealersAddresses = this.getEpochDealersAddresses.bind(this);
    this.getEpochDealers = this.getEpochDealers.bind(this);
    this.getCurrentDealers = this.getCurrentDealers.bind(this);
    this.getDealerIndices = this.getDealerIndices.bind(this);
    this.getDealingsMetadata = this.getDealingsMetadata.bind(this);
    this.getDealerDealingsStatus = this.getDealerDealingsStatus.bind(this);
    this.getDealingStatus = this.getDealingStatus.bind(this);
    this.getDealingChunkStatus = this.getDealingChunkStatus.bind(this);
    this.getDealingChunk = this.getDealingChunk.bind(this);
    this.getVerificationKey = this.getVerificationKey.bind(this);
    this.getVerificationKeys = this.getVerificationKeys.bind(this);
    this.getCw2ContractVersion = this.getCw2ContractVersion.bind(this);
  }
  getState = async (): Promise<State> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_state: {}
    });
  };
  getCurrentEpochState = async (): Promise<Epoch> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_current_epoch_state: {}
    });
  };
  getEpochStateAtHeight = async ({
    height
  }: {
    height: number;
  }): Promise<NullableEpoch> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_epoch_state_at_height: {
        height
      }
    });
  };
  getCurrentEpochThreshold = async (): Promise<Uint64> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_current_epoch_threshold: {}
    });
  };
  getEpochThreshold = async ({
    epochId
  }: {
    epochId: number;
  }): Promise<Uint64> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_epoch_threshold: {
        epoch_id: epochId
      }
    });
  };
  canAdvanceState = async (): Promise<StateAdvanceResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      can_advance_state: {}
    });
  };
  getRegisteredDealer = async ({
    dealerAddress,
    epochId
  }: {
    dealerAddress: string;
    epochId?: number;
  }): Promise<RegisteredDealerDetails> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_registered_dealer: {
        dealer_address: dealerAddress,
        epoch_id: epochId
      }
    });
  };
  getDealerDetails = async ({
    dealerAddress
  }: {
    dealerAddress: string;
  }): Promise<DealerDetailsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_dealer_details: {
        dealer_address: dealerAddress
      }
    });
  };
  getEpochDealersAddresses = async ({
    epochId,
    limit,
    startAfter
  }: {
    epochId: number;
    limit?: number;
    startAfter?: string;
  }): Promise<PagedDealerAddressesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_epoch_dealers_addresses: {
        epoch_id: epochId,
        limit,
        start_after: startAfter
      }
    });
  };
  getEpochDealers = async ({
    epochId,
    limit,
    startAfter
  }: {
    epochId: number;
    limit?: number;
    startAfter?: string;
  }): Promise<PagedDealerResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_epoch_dealers: {
        epoch_id: epochId,
        limit,
        start_after: startAfter
      }
    });
  };
  getCurrentDealers = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<PagedDealerResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_current_dealers: {
        limit,
        start_after: startAfter
      }
    });
  };
  getDealerIndices = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<PagedDealerIndexResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_dealer_indices: {
        limit,
        start_after: startAfter
      }
    });
  };
  getDealingsMetadata = async ({
    dealer,
    dealingIndex,
    epochId
  }: {
    dealer: string;
    dealingIndex: number;
    epochId: number;
  }): Promise<DealingMetadataResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_dealings_metadata: {
        dealer,
        dealing_index: dealingIndex,
        epoch_id: epochId
      }
    });
  };
  getDealerDealingsStatus = async ({
    dealer,
    epochId
  }: {
    dealer: string;
    epochId: number;
  }): Promise<DealerDealingsStatusResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_dealer_dealings_status: {
        dealer,
        epoch_id: epochId
      }
    });
  };
  getDealingStatus = async ({
    dealer,
    dealingIndex,
    epochId
  }: {
    dealer: string;
    dealingIndex: number;
    epochId: number;
  }): Promise<DealingStatusResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_dealing_status: {
        dealer,
        dealing_index: dealingIndex,
        epoch_id: epochId
      }
    });
  };
  getDealingChunkStatus = async ({
    chunkIndex,
    dealer,
    dealingIndex,
    epochId
  }: {
    chunkIndex: number;
    dealer: string;
    dealingIndex: number;
    epochId: number;
  }): Promise<DealingChunkStatusResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_dealing_chunk_status: {
        chunk_index: chunkIndex,
        dealer,
        dealing_index: dealingIndex,
        epoch_id: epochId
      }
    });
  };
  getDealingChunk = async ({
    chunkIndex,
    dealer,
    dealingIndex,
    epochId
  }: {
    chunkIndex: number;
    dealer: string;
    dealingIndex: number;
    epochId: number;
  }): Promise<DealingChunkResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_dealing_chunk: {
        chunk_index: chunkIndex,
        dealer,
        dealing_index: dealingIndex,
        epoch_id: epochId
      }
    });
  };
  getVerificationKey = async ({
    epochId,
    owner
  }: {
    epochId: number;
    owner: string;
  }): Promise<VkShareResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_verification_key: {
        epoch_id: epochId,
        owner
      }
    });
  };
  getVerificationKeys = async ({
    epochId,
    limit,
    startAfter
  }: {
    epochId: number;
    limit?: number;
    startAfter?: string;
  }): Promise<PagedVKSharesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_verification_keys: {
        epoch_id: epochId,
        limit,
        start_after: startAfter
      }
    });
  };
  getCw2ContractVersion = async (): Promise<GetCw2ContractVersionResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_cw2_contract_version: {}
    });
  };
}
export interface CoconutDkgInterface extends CoconutDkgReadOnlyInterface {
  contractAddress: string;
  sender: string;
  initiateDkg: (fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  registerDealer: ({
    announceAddress,
    bteKeyWithProof,
    identityKey,
    resharing
  }: {
    announceAddress: string;
    bteKeyWithProof: string;
    identityKey: string;
    resharing: boolean;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  commitDealingsMetadata: ({
    chunks,
    dealingIndex,
    resharing
  }: {
    chunks: DealingChunkInfo[];
    dealingIndex: number;
    resharing: boolean;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  commitDealingsChunk: ({
    chunk
  }: {
    chunk: PartialContractDealing;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  commitVerificationKeyShare: ({
    resharing,
    share
  }: {
    resharing: boolean;
    share: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  verifyVerificationKeyShare: ({
    owner,
    resharing
  }: {
    owner: string;
    resharing: boolean;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  advanceEpochState: (fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  triggerReset: (fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  triggerResharing: (fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  transferOwnership: ({
    transferTo
  }: {
    transferTo: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  updateAnnounceAddress: ({
    newAddress
  }: {
    newAddress: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
}
export class CoconutDkgClient extends CoconutDkgQueryClient implements CoconutDkgInterface {
  client: ISigningCosmWasmClient;
  sender: string;
  contractAddress: string;
  constructor(client: ISigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.initiateDkg = this.initiateDkg.bind(this);
    this.registerDealer = this.registerDealer.bind(this);
    this.commitDealingsMetadata = this.commitDealingsMetadata.bind(this);
    this.commitDealingsChunk = this.commitDealingsChunk.bind(this);
    this.commitVerificationKeyShare = this.commitVerificationKeyShare.bind(this);
    this.verifyVerificationKeyShare = this.verifyVerificationKeyShare.bind(this);
    this.advanceEpochState = this.advanceEpochState.bind(this);
    this.triggerReset = this.triggerReset.bind(this);
    this.triggerResharing = this.triggerResharing.bind(this);
    this.transferOwnership = this.transferOwnership.bind(this);
    this.updateAnnounceAddress = this.updateAnnounceAddress.bind(this);
  }
  initiateDkg = async (fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      initiate_dkg: {}
    }, fee_, memo_, funds_);
  };
  registerDealer = async ({
    announceAddress,
    bteKeyWithProof,
    identityKey,
    resharing
  }: {
    announceAddress: string;
    bteKeyWithProof: string;
    identityKey: string;
    resharing: boolean;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      register_dealer: {
        announce_address: announceAddress,
        bte_key_with_proof: bteKeyWithProof,
        identity_key: identityKey,
        resharing
      }
    }, fee_, memo_, funds_);
  };
  commitDealingsMetadata = async ({
    chunks,
    dealingIndex,
    resharing
  }: {
    chunks: DealingChunkInfo[];
    dealingIndex: number;
    resharing: boolean;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      commit_dealings_metadata: {
        chunks,
        dealing_index: dealingIndex,
        resharing
      }
    }, fee_, memo_, funds_);
  };
  commitDealingsChunk = async ({
    chunk
  }: {
    chunk: PartialContractDealing;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      commit_dealings_chunk: {
        chunk
      }
    }, fee_, memo_, funds_);
  };
  commitVerificationKeyShare = async ({
    resharing,
    share
  }: {
    resharing: boolean;
    share: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      commit_verification_key_share: {
        resharing,
        share
      }
    }, fee_, memo_, funds_);
  };
  verifyVerificationKeyShare = async ({
    owner,
    resharing
  }: {
    owner: string;
    resharing: boolean;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      verify_verification_key_share: {
        owner,
        resharing
      }
    }, fee_, memo_, funds_);
  };
  advanceEpochState = async (fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      advance_epoch_state: {}
    }, fee_, memo_, funds_);
  };
  triggerReset = async (fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      trigger_reset: {}
    }, fee_, memo_, funds_);
  };
  triggerResharing = async (fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      trigger_resharing: {}
    }, fee_, memo_, funds_);
  };
  transferOwnership = async ({
    transferTo
  }: {
    transferTo: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      transfer_ownership: {
        transfer_to: transferTo
      }
    }, fee_, memo_, funds_);
  };
  updateAnnounceAddress = async ({
    newAddress
  }: {
    newAddress: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_announce_address: {
        new_address: newAddress
      }
    }, fee_, memo_, funds_);
  };
}