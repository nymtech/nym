// Copyright 2020 Nym Technologies SA
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use nymsphinx::addressing::clients::Recipient;
use nymsphinx::anonymous_replies::ReplySURB;
use nymsphinx::params::{MessageType, DEFAULT_NUM_MIX_HOPS};
use nymsphinx::receiver::ReconstructedMessage;
use serde::{Deserialize, Serialize};
use std::convert::TryFrom;
use tokio_tungstenite::tungstenite::protocol::Message as WsMessage;

// 'Text'
#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "type", rename_all = "camelCase")]
pub enum ClientTextRequest {
    #[serde(rename_all = "camelCase")]
    Send {
        message: String,
        recipient: String,
        // Perhaps we could change it to a number to indicate how many reply_SURBs we want to include?
        with_reply_surb: bool,
    },
    SelfAddress,
    #[serde(rename_all = "camelCase")]
    Reply {
        message: String,
        reply_surb: String,
    },
}

impl TryFrom<String> for ClientTextRequest {
    type Error = serde_json::Error;

    fn try_from(msg: String) -> Result<Self, Self::Error> {
        serde_json::from_str(&msg)
    }
}

impl Into<WsMessage> for ClientTextRequest {
    fn into(self) -> WsMessage {
        let str_req = serde_json::to_string(&self).unwrap();
        WsMessage::Text(str_req)
    }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct ReceivedTextMessage {
    pub message: String,
    pub reply_surb: Option<String>,
}

impl<'a> TryFrom<&'a ReconstructedMessage> for ReceivedTextMessage {
    type Error = std::str::Utf8Error;

    fn try_from(reconstructed_message: &ReconstructedMessage) -> Result<Self, Self::Error> {
        Ok(ReceivedTextMessage {
            message: std::str::from_utf8(&reconstructed_message.message)?.to_string(),
            reply_surb: reconstructed_message
                .reply_SURB
                .as_ref()
                .map(|reply_surb| reply_surb.to_base58_string()),
        })
    }
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "type", rename_all = "camelCase")]
pub enum ServerTextResponse {
    Received(ReceivedTextMessage),
    GetClients { clients: Vec<String> },
    SelfAddress { address: String },
    Error { message: String },
}

impl ServerTextResponse {
    pub fn new_error<S: Into<String>>(msg: S) -> Self {
        ServerTextResponse::Error {
            message: msg.into(),
        }
    }
}

impl TryFrom<String> for ServerTextResponse {
    type Error = serde_json::Error;

    fn try_from(msg: String) -> Result<Self, <ServerTextResponse as TryFrom<String>>::Error> {
        serde_json::from_str(&msg)
    }
}

impl Into<WsMessage> for ServerTextResponse {
    fn into(self) -> WsMessage {
        // it should be safe to call `unwrap` here as the message is generated by the server
        // so if it fails (and consequently panics) it's a bug that should be resolved
        let str_res = serde_json::to_string(&self).unwrap();
        WsMessage::Text(str_res)
    }
}

// 'Binary'

// Note that control message, like 'SelfAddress', are not allowed as 'BinaryRequests' - but maybe
// they should be?
// Right now you can only send a `Send` or `Reply` binary message
#[allow(non_snake_case)]
#[derive(Debug)]
pub enum BinaryClientRequest {
    Send {
        recipient: Recipient,
        data: Vec<u8>,
        with_reply_surb: bool,
    },
    Reply {
        message: Vec<u8>,
        reply_surb: ReplySURB,
    },
}

impl BinaryClientRequest {
    // TODO: I really think this should be done with something like protobuf / flatbuffers / Cap'n Proto,
    // especially if people using different languages had to use it
    // Another reason for some proper schema: messages pushed back to the client which will require
    // extra parsing to determine when the actual message starts and which parts are the reply surb

    // TODO2: perhaps do it the proper way and introduce an error type
    // TODO3: but if this 'stays' this way, the function could definitely use a clean up
    pub fn try_from_bytes(req: &[u8]) -> Option<Self> {
        if req.is_empty() {
            return None;
        }
        let with_reply_surb = match req[0] {
            n if n == MessageType::WithReplySURB as u8 => true,
            n if n == MessageType::WithoutReplySURB as u8 => false,
            n if n == MessageType::IsReply as u8 => {
                // TODO: this is extremely fragile as only works for the very specific network topology
                // and number of hops - another reason for some proper serialization library
                let surb_len = ReplySURB::serialized_len(DEFAULT_NUM_MIX_HOPS);

                if req.len() < surb_len + 1 {
                    return None;
                }

                // note the extra +1 (due to message prefix)
                let surb_bytes = &req[1..1 + surb_len];
                let reply_surb = ReplySURB::from_bytes(surb_bytes).ok()?;

                return Some(BinaryClientRequest::Reply {
                    message: req[1 + surb_len..].to_vec(),
                    reply_surb,
                });
            }
            _ => return None, // no other option is valid in this context
        };

        if req.len() < Recipient::LEN + 1 {
            return None;
        }

        let mut recipient_bytes = [0u8; Recipient::LEN];
        recipient_bytes.copy_from_slice(&req[1..Recipient::LEN + 1]);
        let recipient = Recipient::try_from_bytes(recipient_bytes).ok()?;

        Some(BinaryClientRequest::Send {
            recipient,
            data: req[1 + Recipient::LEN..].to_vec(),
            with_reply_surb,
        })
    }

    pub fn into_bytes(self) -> Vec<u8> {
        match self {
            // (MessageType::WithReplySURB OR MessageType::WithoutReplySURB) || RECIPIENT || MESSAGE
            BinaryClientRequest::Send {
                recipient,
                data,
                with_reply_surb,
            } => std::iter::once(if with_reply_surb {
                MessageType::WithReplySURB as u8
            } else {
                MessageType::WithoutReplySURB as u8
            })
            .chain(recipient.into_bytes().iter().cloned())
            .chain(data.into_iter())
            .collect(),

            // MessageType::IsReply || REPLY_SURB || MESSAGE
            // TODO: this is fragile as reply_SURB length CAN BE variable. however temporarily
            // we are making 'unsafe' assumption that it will be constant
            BinaryClientRequest::Reply {
                message,
                reply_surb,
            } => std::iter::once(MessageType::IsReply as u8)
                .chain(reply_surb.to_bytes().into_iter())
                .chain(message.into_iter())
                .collect(),
        }
    }
}

impl Into<WsMessage> for BinaryClientRequest {
    fn into(self) -> WsMessage {
        WsMessage::Binary(self.into_bytes())
    }
}

pub enum BinaryServerResponse {
    Received(ReconstructedMessage),
}

impl BinaryServerResponse {
    pub fn into_bytes(self) -> Vec<u8> {
        match self {
            // this happens to work because right now there's only a single possible binary response
            BinaryServerResponse::Received(reconstructed_message) => {
                reconstructed_message.into_bytes()
            }
        }
    }

    // TODO: dont be lazy and define error type and change it into Result<Self, Error>
    pub fn try_from_bytes(b: &[u8]) -> Option<Self> {
        // this happens to work because right now there's only a single possible binary response
        Some(BinaryServerResponse::Received(
            ReconstructedMessage::try_from_bytes(b).ok()?,
        ))
    }
}

impl Into<WsMessage> for BinaryServerResponse {
    fn into(self) -> WsMessage {
        WsMessage::Binary(self.into_bytes())
    }
}
