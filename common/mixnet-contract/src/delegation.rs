// Copyright 2021 - Nym Technologies SA <contact@nymtech.net>
// SPDX-License-Identifier: Apache-2.0

// due to code generated by JsonSchema
#![allow(clippy::field_reassign_with_default)]

use crate::{Addr, IdentityKey};
use cosmwasm_std::{Coin, Uint128};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use std::fmt::Display;

#[derive(Clone, Debug, Deserialize, Serialize, PartialEq, JsonSchema)]
pub struct Delegation {
    pub owner: Addr,
    pub node_identity: IdentityKey,
    pub amount: Coin,
    pub block_height: u64,
    pub proxy: Option<Addr>, // proxy address used to delegate the funds on behalf of anouther address
}

impl Delegation {
    pub fn new(
        owner: Addr,
        node_identity: IdentityKey,
        amount: Coin,
        block_height: u64,
        proxy: Option<Addr>,
    ) -> Self {
        Delegation {
            owner,
            node_identity,
            amount,
            block_height,
            proxy,
        }
    }

    // TODO: change that to use .joined_key() and return Vec<u8>
    pub fn storage_key(&self) -> (IdentityKey, Addr) {
        (self.node_identity(), self.owner())
    }

    pub fn increment_amount(&mut self, amount: Uint128, at_height: Option<u64>) {
        self.amount.amount += amount;
        if let Some(at_height) = at_height {
            self.block_height = at_height;
        }
    }

    pub fn amount(&self) -> &Coin {
        &self.amount
    }

    pub fn node_identity(&self) -> IdentityKey {
        self.node_identity.clone()
    }

    pub fn owner(&self) -> Addr {
        self.owner.clone()
    }

    pub fn block_height(&self) -> u64 {
        self.block_height
    }
}

impl Display for Delegation {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(
            f,
            "{} delegated towards {} by {} at block {}",
            self.amount, self.node_identity, self.owner, self.block_height
        )
    }
}

#[derive(Clone, Debug, Deserialize, PartialEq, Serialize, JsonSchema)]
pub struct PagedMixDelegationsResponse {
    pub delegations: Vec<Delegation>,
    pub start_next_after: Option<String>,
}

impl PagedMixDelegationsResponse {
    pub fn new(delegations: Vec<Delegation>, start_next_after: Option<Addr>) -> Self {
        PagedMixDelegationsResponse {
            delegations,
            start_next_after: start_next_after.map(|s| s.to_string()),
        }
    }
}

#[derive(Clone, Debug, Deserialize, PartialEq, Serialize, JsonSchema)]
pub struct PagedDelegatorDelegationsResponse {
    pub delegations: Vec<Delegation>,
    pub start_next_after: Option<IdentityKey>,
}

impl PagedDelegatorDelegationsResponse {
    pub fn new(delegations: Vec<Delegation>, start_next_after: Option<IdentityKey>) -> Self {
        PagedDelegatorDelegationsResponse {
            delegations,
            start_next_after,
        }
    }
}

#[derive(Clone, Debug, Deserialize, PartialEq, Serialize, JsonSchema)]
pub struct PagedAllDelegationsResponse {
    pub delegations: Vec<Delegation>,
    pub start_next_after: Option<(IdentityKey, String)>,
}

impl PagedAllDelegationsResponse {
    pub fn new(
        delegations: Vec<Delegation>,
        start_next_after: Option<(IdentityKey, Addr)>,
    ) -> Self {
        PagedAllDelegationsResponse {
            delegations,
            start_next_after: start_next_after.map(|(id, addr)| (id, addr.to_string())),
        }
    }
}
