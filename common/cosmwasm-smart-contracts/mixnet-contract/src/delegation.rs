// Copyright 2021 - Nym Technologies SA <contact@nymtech.net>
// SPDX-License-Identifier: Apache-2.0

// due to code generated by JsonSchema
#![allow(clippy::field_reassign_with_default)]

use crate::mixnode::Period;
use crate::{Addr, IdentityKey, NodeId};
use cosmwasm_std::{Coin, Decimal, Uint128};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use std::fmt::Display;
use std::hash::{Hash, Hasher};

type OwnerAddressBytes = Vec<u8>;
type BlockHeight = u64;

pub fn generate_storage_key(address: &Addr, proxy: Option<&Addr>) -> Vec<u8> {
    if let Some(proxy) = &proxy {
        address
            .as_bytes()
            .iter()
            .zip(proxy.as_bytes())
            .map(|(x, y)| x ^ y)
            .collect()
    } else {
        address.as_bytes().to_vec()
    }
}

#[derive(Clone, Debug, Deserialize, Serialize, PartialEq, JsonSchema)]
pub struct Delegation {
    /// Address of the owner of this delegation.
    pub owner: Addr,

    /// Id of the MixNode that this delegation was performed against.
    pub node_id: NodeId,

    // pub node_identity: IdentityKey,

    // Note to UX devs: there's absolutely no point in displaying this value to the users,
    // it would serve them no purpose. It's only used for calculating rewards
    pub period: Period,

    /// Original delegation amount. Note that it is never mutated as delegation accumulates rewards.
    pub amount: Coin,

    /// Block height where this delegation occurred.
    pub height: u64,

    /// Proxy address used to delegate the funds on behalf of another address
    pub proxy: Option<Addr>,
}

// impl Eq for Delegation {}
//
// #[allow(clippy::derive_hash_xor_eq)]
// impl Hash for Delegation {
//     fn hash<H: Hasher>(&self, state: &mut H) {
//         self.owner.hash(state);
//         self.node_identity.hash(state);
//         self.block_height.hash(state);
//         self.proxy.hash(state);
//     }
// }

impl Delegation {
    pub fn new(
        owner: Addr,
        node_id: NodeId,
        period: Period,
        amount: Coin,
        height: u64,
        proxy: Option<Addr>,
    ) -> Self {
        Delegation {
            owner,
            node_id,
            period,
            amount,
            height,
            proxy,
        }
    }

    pub fn dec_amount(&self) -> Decimal {
        // the unwrap here is fine as we're guaranteed our base coin amount is going to fit in a Decimal
        // with 0 decimal places
        Decimal::from_atomics(self.amount.amount, 0).unwrap()
    }

    // pub fn storage_key(&self) -> (IdentityKey, OwnerAddressBytes, BlockHeight) {
    //     (
    //         self.node_identity(),
    //         self.proxy_storage_key(),
    //         self.block_height(),
    //     )
    // }
    //
    // pub fn event_storage_key(&self) -> (OwnerAddressBytes, BlockHeight, IdentityKey) {
    //     (
    //         self.proxy_storage_key(),
    //         self.block_height(),
    //         self.node_identity(),
    //     )
    // }
    //
    // pub fn proxy_storage_key(&self) -> OwnerAddressBytes {
    //     generate_storage_key(&self.owner, self.proxy.as_ref())
    // }
    //
    // pub fn proxy(&self) -> Option<&Addr> {
    //     self.proxy.as_ref()
    // }
    //
    // pub fn increment_amount(&mut self, amount: Uint128, at_height: Option<u64>) {
    //     self.amount.amount += amount;
    //     if let Some(at_height) = at_height {
    //         self.block_height = at_height;
    //     }
    // }
    //
    // pub fn amount(&self) -> &Coin {
    //     &self.amount
    // }
    //
    // pub fn node_identity(&self) -> IdentityKey {
    //     self.node_identity.clone()
    // }
    //
    // pub fn owner(&self) -> Addr {
    //     self.owner.clone()
    // }
    //
    // pub fn block_height(&self) -> u64 {
    //     self.block_height
    // }
}

// impl Display for Delegation {
//     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
//         write!(
//             f,
//             "{} delegated towards {} by {} at block {}",
//             self.amount, self.node_identity, self.owner, self.block_height
//         )
//     }
// }

#[derive(Clone, Debug, Deserialize, PartialEq, Serialize, JsonSchema)]
pub struct PagedMixDelegationsResponse {
    pub delegations: Vec<Delegation>,
    pub start_next_after: Option<(String, u64)>,
}

impl PagedMixDelegationsResponse {
    pub fn new(delegations: Vec<Delegation>, start_next_after: Option<(String, u64)>) -> Self {
        PagedMixDelegationsResponse {
            delegations,
            start_next_after,
        }
    }
}

#[derive(Clone, Debug, Deserialize, PartialEq, Serialize, JsonSchema)]
pub struct PagedDelegatorDelegationsResponse {
    pub delegations: Vec<Delegation>,
    pub start_next_after: Option<IdentityKey>,
}

impl PagedDelegatorDelegationsResponse {
    pub fn new(delegations: Vec<Delegation>, start_next_after: Option<IdentityKey>) -> Self {
        PagedDelegatorDelegationsResponse {
            delegations,
            start_next_after,
        }
    }
}

#[derive(Clone, Debug, Deserialize, PartialEq, Serialize, JsonSchema)]
pub struct PagedAllDelegationsResponse {
    pub delegations: Vec<Delegation>,
    pub start_next_after: Option<(IdentityKey, Vec<u8>, u64)>,
}

impl PagedAllDelegationsResponse {
    pub fn new(
        delegations: Vec<Delegation>,
        start_next_after: Option<(IdentityKey, Vec<u8>, u64)>,
    ) -> Self {
        PagedAllDelegationsResponse {
            delegations,
            start_next_after: start_next_after.map(|(id, addr, height)| (id, addr, height)),
        }
    }
}
